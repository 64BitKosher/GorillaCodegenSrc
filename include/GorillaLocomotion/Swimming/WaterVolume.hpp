// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: GorillaTag.GuidedRefs.BaseGuidedRefTargetMono
#include "GorillaTag/GuidedRefs/BaseGuidedRefTargetMono.hpp"
// Including type: GorillaLocomotion.Player/LiquidType
#include "GorillaLocomotion/Player_LiquidType.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GorillaLocomotion::Swimming
namespace GorillaLocomotion::Swimming {
  // Forward declaring type: WaterCurrent
  class WaterCurrent;
  // Forward declaring type: WaterParameters
  class WaterParameters;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: MeshCollider
  class MeshCollider;
  // Forward declaring type: Collider
  class Collider;
  // Skipping declaration: Object because it is already included!
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: RaycastHit
  struct RaycastHit;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: VRRig
  class VRRig;
}
// Forward declaring namespace: GorillaTag::GuidedRefs
namespace GorillaTag::GuidedRefs {
  // Forward declaring type: GuidedRefTargetIdSO
  class GuidedRefTargetIdSO;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: String
  class String;
}
// Completed forward declares
// Type namespace: GorillaLocomotion.Swimming
namespace GorillaLocomotion::Swimming {
  // Forward declaring type: WaterVolume
  class WaterVolume;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GorillaLocomotion::Swimming::WaterVolume);
DEFINE_IL2CPP_ARG_TYPE(::GorillaLocomotion::Swimming::WaterVolume*, "GorillaLocomotion.Swimming", "WaterVolume");
// Type namespace: GorillaLocomotion.Swimming
namespace GorillaLocomotion::Swimming {
  // Size: 0xD8
  #pragma pack(push, 1)
  // Autogenerated type: GorillaLocomotion.Swimming.WaterVolume
  // [TokenAttribute] Offset: FFFFFFFF
  // [RequireComponent] Offset: FFFFFFFF
  class WaterVolume : public ::GorillaTag::GuidedRefs::BaseGuidedRefTargetMono {
    public:
    // Writing base type padding for base size: 0x31 to desired offset: 0x38
    char ___base_padding[0x7] = {};
    // Nested type: ::GorillaLocomotion::Swimming::WaterVolume::SurfaceQuery
    struct SurfaceQuery;
    // Nested type: ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent
    class WaterVolumeEvent;
    public:
    // public UnityEngine.Transform surfacePlane
    // Size: 0x8
    // Offset: 0x38
    ::UnityEngine::Transform* surfacePlane;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Collections.Generic.List`1<UnityEngine.MeshCollider> surfaceColliders
    // Size: 0x8
    // Offset: 0x40
    ::System::Collections::Generic::List_1<::UnityEngine::MeshCollider*>* surfaceColliders;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::MeshCollider*>*) == 0x8);
    // public System.Collections.Generic.List`1<UnityEngine.Collider> volumeColliders
    // Size: 0x8
    // Offset: 0x48
    ::System::Collections::Generic::List_1<::UnityEngine::Collider*>* volumeColliders;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Collider*>*) == 0x8);
    // private GorillaLocomotion.Player/LiquidType liquidType
    // Size: 0x4
    // Offset: 0x50
    ::GorillaLocomotion::Player::LiquidType liquidType;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Player::LiquidType) == 0x4);
    // Padding between fields: liquidType and: waterCurrent
    char __padding3[0x4] = {};
    // private GorillaLocomotion.Swimming.WaterCurrent waterCurrent
    // Size: 0x8
    // Offset: 0x58
    ::GorillaLocomotion::Swimming::WaterCurrent* waterCurrent;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Swimming::WaterCurrent*) == 0x8);
    // private GorillaLocomotion.Swimming.WaterParameters waterParams
    // Size: 0x8
    // Offset: 0x60
    ::GorillaLocomotion::Swimming::WaterParameters* waterParams;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Swimming::WaterParameters*) == 0x8);
    // public System.Boolean isStationary
    // Size: 0x1
    // Offset: 0x68
    bool isStationary;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isStationary and: sharedMeshTris
    char __padding6[0x7] = {};
    // private System.Int32[] sharedMeshTris
    // Size: 0x8
    // Offset: 0x70
    ::ArrayW<int> sharedMeshTris;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // private UnityEngine.Vector3[] sharedMeshVerts
    // Size: 0x8
    // Offset: 0x78
    ::ArrayW<::UnityEngine::Vector3> sharedMeshVerts;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderEnteredVolume
    // Size: 0x8
    // Offset: 0x80
    ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* ColliderEnteredVolume;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*) == 0x8);
    // private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderExitedVolume
    // Size: 0x8
    // Offset: 0x88
    ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* ColliderExitedVolume;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*) == 0x8);
    // private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderEnteredWater
    // Size: 0x8
    // Offset: 0x90
    ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* ColliderEnteredWater;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*) == 0x8);
    // private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderExitedWater
    // Size: 0x8
    // Offset: 0x98
    ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* ColliderExitedWater;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*) == 0x8);
    // private VRRig playerVRRig
    // Size: 0x8
    // Offset: 0xA0
    ::GlobalNamespace::VRRig* playerVRRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRRig*) == 0x8);
    // private System.Single volumeMaxHeight
    // Size: 0x4
    // Offset: 0xA8
    float volumeMaxHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single volumeMinHeight
    // Size: 0x4
    // Offset: 0xAC
    float volumeMinHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean debugDrawSurfaceCast
    // Size: 0x1
    // Offset: 0xB0
    bool debugDrawSurfaceCast;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: debugDrawSurfaceCast and: triggerCollider
    char __padding16[0x7] = {};
    // private UnityEngine.Collider triggerCollider
    // Size: 0x8
    // Offset: 0xB8
    ::UnityEngine::Collider* triggerCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::Collider*) == 0x8);
    // private System.Collections.Generic.List`1<GorillaLocomotion.Swimming.WaterOverlappingCollider> persistentColliders
    // Size: 0x8
    // Offset: 0xC0
    ::System::Collections::Generic::List_1<::GorillaLocomotion::Swimming::WaterOverlappingCollider>* persistentColliders;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::GorillaLocomotion::Swimming::WaterOverlappingCollider>*) == 0x8);
    // private GorillaTag.GuidedRefs.GuidedRefTargetIdSO _guidedRefTargetId
    // Size: 0x8
    // Offset: 0xC8
    ::GorillaTag::GuidedRefs::GuidedRefTargetIdSO* guidedRefTargetId;
    // Field size check
    static_assert(sizeof(::GorillaTag::GuidedRefs::GuidedRefTargetIdSO*) == 0x8);
    // private UnityEngine.Object _guidedRefTargetObject
    // Size: 0x8
    // Offset: 0xD0
    ::UnityEngine::Object* guidedRefTargetObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::Object*) == 0x8);
    public:
    // static field const value: static public System.String WaterSplashRPC
    static constexpr const char* WaterSplashRPC = "PlaySplashEffect";
    // Get static field: static public System.String WaterSplashRPC
    static ::StringW _get_WaterSplashRPC();
    // Set static field: static public System.String WaterSplashRPC
    static void _set_WaterSplashRPC(::StringW value);
    // Get static field: static public System.Single[] splashRPCSendTimes
    static ::ArrayW<float> _get_splashRPCSendTimes();
    // Set static field: static public System.Single[] splashRPCSendTimes
    static void _set_splashRPCSendTimes(::ArrayW<float> value);
    // Get static field: static private System.Collections.Generic.Dictionary`2<UnityEngine.Collider,GorillaLocomotion.Swimming.WaterVolume> sharedColliderRegistry
    static ::System::Collections::Generic::Dictionary_2<::UnityEngine::Collider*, ::GorillaLocomotion::Swimming::WaterVolume*>* _get_sharedColliderRegistry();
    // Set static field: static private System.Collections.Generic.Dictionary`2<UnityEngine.Collider,GorillaLocomotion.Swimming.WaterVolume> sharedColliderRegistry
    static void _set_sharedColliderRegistry(::System::Collections::Generic::Dictionary_2<::UnityEngine::Collider*, ::GorillaLocomotion::Swimming::WaterVolume*>* value);
    // Get static field: static private System.Collections.Generic.Dictionary`2<UnityEngine.Mesh,System.Int32[]> meshTrianglesDict
    static ::System::Collections::Generic::Dictionary_2<::UnityEngine::Mesh*, ::ArrayW<int>>* _get_meshTrianglesDict();
    // Set static field: static private System.Collections.Generic.Dictionary`2<UnityEngine.Mesh,System.Int32[]> meshTrianglesDict
    static void _set_meshTrianglesDict(::System::Collections::Generic::Dictionary_2<::UnityEngine::Mesh*, ::ArrayW<int>>* value);
    // Get static field: static private System.Collections.Generic.Dictionary`2<UnityEngine.Mesh,UnityEngine.Vector3[]> meshVertsDict
    static ::System::Collections::Generic::Dictionary_2<::UnityEngine::Mesh*, ::ArrayW<::UnityEngine::Vector3>>* _get_meshVertsDict();
    // Set static field: static private System.Collections.Generic.Dictionary`2<UnityEngine.Mesh,UnityEngine.Vector3[]> meshVertsDict
    static void _set_meshVertsDict(::System::Collections::Generic::Dictionary_2<::UnityEngine::Mesh*, ::ArrayW<::UnityEngine::Vector3>>* value);
    // Get instance field reference: public UnityEngine.Transform surfacePlane
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_surfacePlane();
    // Get instance field reference: private System.Collections.Generic.List`1<UnityEngine.MeshCollider> surfaceColliders
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::MeshCollider*>*& dyn_surfaceColliders();
    // Get instance field reference: public System.Collections.Generic.List`1<UnityEngine.Collider> volumeColliders
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Collider*>*& dyn_volumeColliders();
    // Get instance field reference: private GorillaLocomotion.Player/LiquidType liquidType
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Player::LiquidType& dyn_liquidType();
    // Get instance field reference: private GorillaLocomotion.Swimming.WaterCurrent waterCurrent
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Swimming::WaterCurrent*& dyn_waterCurrent();
    // Get instance field reference: private GorillaLocomotion.Swimming.WaterParameters waterParams
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Swimming::WaterParameters*& dyn_waterParams();
    // Get instance field reference: public System.Boolean isStationary
    [[deprecated("Use field access instead!")]] bool& dyn_isStationary();
    // Get instance field reference: private System.Int32[] sharedMeshTris
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_sharedMeshTris();
    // Get instance field reference: private UnityEngine.Vector3[] sharedMeshVerts
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_sharedMeshVerts();
    // Get instance field reference: private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderEnteredVolume
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*& dyn_ColliderEnteredVolume();
    // Get instance field reference: private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderExitedVolume
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*& dyn_ColliderExitedVolume();
    // Get instance field reference: private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderEnteredWater
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*& dyn_ColliderEnteredWater();
    // Get instance field reference: private GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent ColliderExitedWater
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*& dyn_ColliderExitedWater();
    // Get instance field reference: private VRRig playerVRRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRRig*& dyn_playerVRRig();
    // Get instance field reference: private System.Single volumeMaxHeight
    [[deprecated("Use field access instead!")]] float& dyn_volumeMaxHeight();
    // Get instance field reference: private System.Single volumeMinHeight
    [[deprecated("Use field access instead!")]] float& dyn_volumeMinHeight();
    // Get instance field reference: private System.Boolean debugDrawSurfaceCast
    [[deprecated("Use field access instead!")]] bool& dyn_debugDrawSurfaceCast();
    // Get instance field reference: private UnityEngine.Collider triggerCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::Collider*& dyn_triggerCollider();
    // Get instance field reference: private System.Collections.Generic.List`1<GorillaLocomotion.Swimming.WaterOverlappingCollider> persistentColliders
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::GorillaLocomotion::Swimming::WaterOverlappingCollider>*& dyn_persistentColliders();
    // Get instance field reference: private GorillaTag.GuidedRefs.GuidedRefTargetIdSO _guidedRefTargetId
    [[deprecated("Use field access instead!")]] ::GorillaTag::GuidedRefs::GuidedRefTargetIdSO*& dyn__guidedRefTargetId();
    // Get instance field reference: private UnityEngine.Object _guidedRefTargetObject
    [[deprecated("Use field access instead!")]] ::UnityEngine::Object*& dyn__guidedRefTargetObject();
    // public System.Void add_ColliderEnteredVolume(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E25F0
    void add_ColliderEnteredVolume(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public System.Void remove_ColliderEnteredVolume(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E268C
    void remove_ColliderEnteredVolume(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public System.Void add_ColliderExitedVolume(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E2728
    void add_ColliderExitedVolume(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public System.Void remove_ColliderExitedVolume(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E27C4
    void remove_ColliderExitedVolume(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public System.Void add_ColliderEnteredWater(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E2860
    void add_ColliderEnteredWater(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public System.Void remove_ColliderEnteredWater(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E28FC
    void remove_ColliderEnteredWater(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public System.Void add_ColliderExitedWater(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E2998
    void add_ColliderExitedWater(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public System.Void remove_ColliderExitedWater(GorillaLocomotion.Swimming.WaterVolume/WaterVolumeEvent value)
    // Offset: 0x27E2A34
    void remove_ColliderExitedWater(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent* value);
    // public GorillaLocomotion.Player/LiquidType get_LiquidType()
    // Offset: 0x27E2AD0
    ::GorillaLocomotion::Player::LiquidType get_LiquidType();
    // public GorillaLocomotion.Swimming.WaterCurrent get_Current()
    // Offset: 0x27E2AD8
    ::GorillaLocomotion::Swimming::WaterCurrent* get_Current();
    // public GorillaLocomotion.Swimming.WaterParameters get_Parameters()
    // Offset: 0x27E2AE0
    ::GorillaLocomotion::Swimming::WaterParameters* get_Parameters();
    // private VRRig get_PlayerVRRig()
    // Offset: 0x27E2AE8
    ::GlobalNamespace::VRRig* get_PlayerVRRig();
    // public System.Boolean GetSurfaceQueryForPoint(UnityEngine.Vector3 point, out GorillaLocomotion.Swimming.WaterVolume/SurfaceQuery result, System.Boolean debugDraw)
    // Offset: 0x27DD938
    bool GetSurfaceQueryForPoint(::UnityEngine::Vector3 point, ByRef<::GorillaLocomotion::Swimming::WaterVolume::SurfaceQuery> result, bool debugDraw);
    // private System.Boolean HitOutsideSurfaceOfMesh(UnityEngine.Vector3 castDir, UnityEngine.MeshCollider meshCollider, UnityEngine.RaycastHit hit)
    // Offset: 0x27E2BC4
    bool HitOutsideSurfaceOfMesh(::UnityEngine::Vector3 castDir, ::UnityEngine::MeshCollider* meshCollider, ::UnityEngine::RaycastHit hit);
    // private System.Void DebugDrawMeshColliderHitTriangle(UnityEngine.RaycastHit hit)
    // Offset: 0x27E31D4
    void DebugDrawMeshColliderHitTriangle(::UnityEngine::RaycastHit hit);
    // public System.Boolean RaycastWater(UnityEngine.Vector3 origin, UnityEngine.Vector3 direction, out UnityEngine.RaycastHit hit, System.Single distance, System.Int32 layerMask)
    // Offset: 0x27E36C0
    bool RaycastWater(::UnityEngine::Vector3 origin, ::UnityEngine::Vector3 direction, ByRef<::UnityEngine::RaycastHit> hit, float distance, int layerMask);
    // public System.Boolean CheckColliderInVolume(UnityEngine.Collider collider, out System.Boolean inWater, out System.Boolean surfaceDetected)
    // Offset: 0x27E3888
    bool CheckColliderInVolume(::UnityEngine::Collider* collider, ByRef<bool> inWater, ByRef<bool> surfaceDetected);
    // private System.Void OnDisable()
    // Offset: 0x27E3C20
    void OnDisable();
    // private System.Void Update()
    // Offset: 0x27E40AC
    void Update();
    // private System.Void RemoveCollidersOutsideVolume(System.Single currentTime)
    // Offset: 0x27E3E6C
    void RemoveCollidersOutsideVolume(float currentTime);
    // private System.Void CheckColliderAgainstWater(ref GorillaLocomotion.Swimming.WaterOverlappingCollider persistentCollider, System.Single currentTime)
    // Offset: 0x27E42A4
    void CheckColliderAgainstWater(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider> persistentCollider, float currentTime);
    // private UnityEngine.Vector3 GetColliderVelocity(ref GorillaLocomotion.Swimming.WaterOverlappingCollider persistentCollider)
    // Offset: 0x27E5190
    ::UnityEngine::Vector3 GetColliderVelocity(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider> persistentCollider);
    // private System.Void OnWaterSurfaceEnter(ref GorillaLocomotion.Swimming.WaterOverlappingCollider persistentCollider)
    // Offset: 0x27E477C
    void OnWaterSurfaceEnter(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider> persistentCollider);
    // private System.Void OnWaterSurfaceExit(ref GorillaLocomotion.Swimming.WaterOverlappingCollider persistentCollider, System.Single currentTime)
    // Offset: 0x27E49F4
    void OnWaterSurfaceExit(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider> persistentCollider, float currentTime);
    // private System.Void ColliderOutOfWaterUpdate(ref GorillaLocomotion.Swimming.WaterOverlappingCollider persistentCollider, System.Single currentTime)
    // Offset: 0x27E4D7C
    void ColliderOutOfWaterUpdate(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider> persistentCollider, float currentTime);
    // private System.Void ColliderInWaterUpdate(ref GorillaLocomotion.Swimming.WaterOverlappingCollider persistentCollider, System.Single currentTime)
    // Offset: 0x27E4E68
    void ColliderInWaterUpdate(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider> persistentCollider, float currentTime);
    // private System.Void TryRegisterOwnershipOfCollider(UnityEngine.Collider collider, System.Boolean isInWater, System.Boolean isSurfaceDetected)
    // Offset: 0x27E45C4
    void TryRegisterOwnershipOfCollider(::UnityEngine::Collider* collider, bool isInWater, bool isSurfaceDetected);
    // private System.Void UnregisterOwnershipOfCollider(UnityEngine.Collider collider)
    // Offset: 0x27E50C0
    void UnregisterOwnershipOfCollider(::UnityEngine::Collider* collider);
    // private System.Boolean HasOwnershipOfCollider(UnityEngine.Collider collider)
    // Offset: 0x27E4C9C
    bool HasOwnershipOfCollider(::UnityEngine::Collider* collider);
    // private System.Void OnTriggerEnter(UnityEngine.Collider other)
    // Offset: 0x27E53CC
    void OnTriggerEnter(::UnityEngine::Collider* other);
    // private System.Void OnTriggerExit(UnityEngine.Collider other)
    // Offset: 0x27E5A1C
    void OnTriggerExit(::UnityEngine::Collider* other);
    // static private System.Void .cctor()
    // Offset: 0x27E5D9C
    static void _cctor();
    // protected override System.Void Awake()
    // Offset: 0x27E39D0
    // Implemented from: GorillaTag.GuidedRefs.BaseGuidedRefTargetMono
    // Base method: System.Void BaseGuidedRefTargetMono::Awake()
    void Awake();
    // public System.Void .ctor()
    // Offset: 0x27E5C60
    // Implemented from: GorillaTag.GuidedRefs.BaseGuidedRefTargetMono
    // Base method: System.Void BaseGuidedRefTargetMono::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static WaterVolume* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GorillaLocomotion::Swimming::WaterVolume::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<WaterVolume*, creationType>()));
    }
  }; // GorillaLocomotion.Swimming.WaterVolume
  #pragma pack(pop)
  static check_size<sizeof(WaterVolume), 208 + sizeof(::UnityEngine::Object*)> __GorillaLocomotion_Swimming_WaterVolumeSizeCheck;
  static_assert(sizeof(WaterVolume) == 0xD8);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::add_ColliderEnteredVolume
// Il2CppName: add_ColliderEnteredVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::add_ColliderEnteredVolume)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "add_ColliderEnteredVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::remove_ColliderEnteredVolume
// Il2CppName: remove_ColliderEnteredVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::remove_ColliderEnteredVolume)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "remove_ColliderEnteredVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::add_ColliderExitedVolume
// Il2CppName: add_ColliderExitedVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::add_ColliderExitedVolume)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "add_ColliderExitedVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::remove_ColliderExitedVolume
// Il2CppName: remove_ColliderExitedVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::remove_ColliderExitedVolume)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "remove_ColliderExitedVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::add_ColliderEnteredWater
// Il2CppName: add_ColliderEnteredWater
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::add_ColliderEnteredWater)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "add_ColliderEnteredWater", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::remove_ColliderEnteredWater
// Il2CppName: remove_ColliderEnteredWater
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::remove_ColliderEnteredWater)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "remove_ColliderEnteredWater", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::add_ColliderExitedWater
// Il2CppName: add_ColliderExitedWater
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::add_ColliderExitedWater)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "add_ColliderExitedWater", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::remove_ColliderExitedWater
// Il2CppName: remove_ColliderExitedWater
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::GorillaLocomotion::Swimming::WaterVolume::WaterVolumeEvent*)>(&GorillaLocomotion::Swimming::WaterVolume::remove_ColliderExitedWater)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/WaterVolumeEvent")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "remove_ColliderExitedWater", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::get_LiquidType
// Il2CppName: get_LiquidType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GorillaLocomotion::Player::LiquidType (GorillaLocomotion::Swimming::WaterVolume::*)()>(&GorillaLocomotion::Swimming::WaterVolume::get_LiquidType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "get_LiquidType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::get_Current
// Il2CppName: get_Current
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GorillaLocomotion::Swimming::WaterCurrent* (GorillaLocomotion::Swimming::WaterVolume::*)()>(&GorillaLocomotion::Swimming::WaterVolume::get_Current)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "get_Current", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::get_Parameters
// Il2CppName: get_Parameters
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GorillaLocomotion::Swimming::WaterParameters* (GorillaLocomotion::Swimming::WaterVolume::*)()>(&GorillaLocomotion::Swimming::WaterVolume::get_Parameters)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "get_Parameters", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::get_PlayerVRRig
// Il2CppName: get_PlayerVRRig
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::VRRig* (GorillaLocomotion::Swimming::WaterVolume::*)()>(&GorillaLocomotion::Swimming::WaterVolume::get_PlayerVRRig)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "get_PlayerVRRig", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::GetSurfaceQueryForPoint
// Il2CppName: GetSurfaceQueryForPoint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Vector3, ByRef<::GorillaLocomotion::Swimming::WaterVolume::SurfaceQuery>, bool)>(&GorillaLocomotion::Swimming::WaterVolume::GetSurfaceQueryForPoint)> {
  static const MethodInfo* get() {
    static auto* point = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* result = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterVolume/SurfaceQuery")->this_arg;
    static auto* debugDraw = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "GetSurfaceQueryForPoint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{point, result, debugDraw});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::HitOutsideSurfaceOfMesh
// Il2CppName: HitOutsideSurfaceOfMesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Vector3, ::UnityEngine::MeshCollider*, ::UnityEngine::RaycastHit)>(&GorillaLocomotion::Swimming::WaterVolume::HitOutsideSurfaceOfMesh)> {
  static const MethodInfo* get() {
    static auto* castDir = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* meshCollider = &::il2cpp_utils::GetClassFromName("UnityEngine", "MeshCollider")->byval_arg;
    static auto* hit = &::il2cpp_utils::GetClassFromName("UnityEngine", "RaycastHit")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "HitOutsideSurfaceOfMesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{castDir, meshCollider, hit});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::DebugDrawMeshColliderHitTriangle
// Il2CppName: DebugDrawMeshColliderHitTriangle
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::RaycastHit)>(&GorillaLocomotion::Swimming::WaterVolume::DebugDrawMeshColliderHitTriangle)> {
  static const MethodInfo* get() {
    static auto* hit = &::il2cpp_utils::GetClassFromName("UnityEngine", "RaycastHit")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "DebugDrawMeshColliderHitTriangle", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{hit});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::RaycastWater
// Il2CppName: RaycastWater
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3, ByRef<::UnityEngine::RaycastHit>, float, int)>(&GorillaLocomotion::Swimming::WaterVolume::RaycastWater)> {
  static const MethodInfo* get() {
    static auto* origin = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* direction = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* hit = &::il2cpp_utils::GetClassFromName("UnityEngine", "RaycastHit")->this_arg;
    static auto* distance = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* layerMask = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "RaycastWater", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{origin, direction, hit, distance, layerMask});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::CheckColliderInVolume
// Il2CppName: CheckColliderInVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Collider*, ByRef<bool>, ByRef<bool>)>(&GorillaLocomotion::Swimming::WaterVolume::CheckColliderInVolume)> {
  static const MethodInfo* get() {
    static auto* collider = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    static auto* inWater = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    static auto* surfaceDetected = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "CheckColliderInVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collider, inWater, surfaceDetected});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)()>(&GorillaLocomotion::Swimming::WaterVolume::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)()>(&GorillaLocomotion::Swimming::WaterVolume::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::RemoveCollidersOutsideVolume
// Il2CppName: RemoveCollidersOutsideVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(float)>(&GorillaLocomotion::Swimming::WaterVolume::RemoveCollidersOutsideVolume)> {
  static const MethodInfo* get() {
    static auto* currentTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "RemoveCollidersOutsideVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{currentTime});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::CheckColliderAgainstWater
// Il2CppName: CheckColliderAgainstWater
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider>, float)>(&GorillaLocomotion::Swimming::WaterVolume::CheckColliderAgainstWater)> {
  static const MethodInfo* get() {
    static auto* persistentCollider = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterOverlappingCollider")->this_arg;
    static auto* currentTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "CheckColliderAgainstWater", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{persistentCollider, currentTime});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::GetColliderVelocity
// Il2CppName: GetColliderVelocity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GorillaLocomotion::Swimming::WaterVolume::*)(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider>)>(&GorillaLocomotion::Swimming::WaterVolume::GetColliderVelocity)> {
  static const MethodInfo* get() {
    static auto* persistentCollider = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterOverlappingCollider")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "GetColliderVelocity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{persistentCollider});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::OnWaterSurfaceEnter
// Il2CppName: OnWaterSurfaceEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider>)>(&GorillaLocomotion::Swimming::WaterVolume::OnWaterSurfaceEnter)> {
  static const MethodInfo* get() {
    static auto* persistentCollider = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterOverlappingCollider")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "OnWaterSurfaceEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{persistentCollider});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::OnWaterSurfaceExit
// Il2CppName: OnWaterSurfaceExit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider>, float)>(&GorillaLocomotion::Swimming::WaterVolume::OnWaterSurfaceExit)> {
  static const MethodInfo* get() {
    static auto* persistentCollider = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterOverlappingCollider")->this_arg;
    static auto* currentTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "OnWaterSurfaceExit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{persistentCollider, currentTime});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::ColliderOutOfWaterUpdate
// Il2CppName: ColliderOutOfWaterUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider>, float)>(&GorillaLocomotion::Swimming::WaterVolume::ColliderOutOfWaterUpdate)> {
  static const MethodInfo* get() {
    static auto* persistentCollider = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterOverlappingCollider")->this_arg;
    static auto* currentTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "ColliderOutOfWaterUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{persistentCollider, currentTime});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::ColliderInWaterUpdate
// Il2CppName: ColliderInWaterUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(ByRef<::GorillaLocomotion::Swimming::WaterOverlappingCollider>, float)>(&GorillaLocomotion::Swimming::WaterVolume::ColliderInWaterUpdate)> {
  static const MethodInfo* get() {
    static auto* persistentCollider = &::il2cpp_utils::GetClassFromName("GorillaLocomotion.Swimming", "WaterOverlappingCollider")->this_arg;
    static auto* currentTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "ColliderInWaterUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{persistentCollider, currentTime});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::TryRegisterOwnershipOfCollider
// Il2CppName: TryRegisterOwnershipOfCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Collider*, bool, bool)>(&GorillaLocomotion::Swimming::WaterVolume::TryRegisterOwnershipOfCollider)> {
  static const MethodInfo* get() {
    static auto* collider = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    static auto* isInWater = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* isSurfaceDetected = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "TryRegisterOwnershipOfCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collider, isInWater, isSurfaceDetected});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::UnregisterOwnershipOfCollider
// Il2CppName: UnregisterOwnershipOfCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Collider*)>(&GorillaLocomotion::Swimming::WaterVolume::UnregisterOwnershipOfCollider)> {
  static const MethodInfo* get() {
    static auto* collider = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "UnregisterOwnershipOfCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collider});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::HasOwnershipOfCollider
// Il2CppName: HasOwnershipOfCollider
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Collider*)>(&GorillaLocomotion::Swimming::WaterVolume::HasOwnershipOfCollider)> {
  static const MethodInfo* get() {
    static auto* collider = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "HasOwnershipOfCollider", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collider});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::OnTriggerEnter
// Il2CppName: OnTriggerEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Collider*)>(&GorillaLocomotion::Swimming::WaterVolume::OnTriggerEnter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "OnTriggerEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::OnTriggerExit
// Il2CppName: OnTriggerExit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)(::UnityEngine::Collider*)>(&GorillaLocomotion::Swimming::WaterVolume::OnTriggerExit)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "OnTriggerExit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&GorillaLocomotion::Swimming::WaterVolume::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GorillaLocomotion::Swimming::WaterVolume::*)()>(&GorillaLocomotion::Swimming::WaterVolume::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GorillaLocomotion::Swimming::WaterVolume*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GorillaLocomotion::Swimming::WaterVolume::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
