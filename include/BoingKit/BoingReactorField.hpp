// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: BoingKit.BoingBase
#include "BoingKit/BoingBase.hpp"
// Including type: BoingKit.Aabb
#include "BoingKit/Aabb.hpp"
// Including type: BoingKit.BoingWork/Params
#include "BoingKit/BoingWork_Params.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: ComputeBuffer
  class ComputeBuffer;
  // Forward declaring type: ComputeShader
  class ComputeShader;
  // Forward declaring type: MaterialPropertyBlock
  class MaterialPropertyBlock;
  // Forward declaring type: Material
  class Material;
  // Skipping declaration: Vector4 because it is already included!
}
// Forward declaring namespace: BoingKit
namespace BoingKit {
  // Forward declaring type: SharedBoingParams
  class SharedBoingParams;
  // Skipping declaration: BoingEffector because it is already included!
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Completed forward declares
// Type namespace: BoingKit
namespace BoingKit {
  // Forward declaring type: BoingReactorField
  class BoingReactorField;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::BoingKit::BoingReactorField);
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingReactorField*, "BoingKit", "BoingReactorField");
// Type namespace: BoingKit
namespace BoingKit {
  // Size: 0x308
  #pragma pack(push, 1)
  // Autogenerated type: BoingKit.BoingReactorField
  // [TokenAttribute] Offset: FFFFFFFF
  class BoingReactorField : public ::BoingKit::BoingBase {
    public:
    // Nested type: ::BoingKit::BoingReactorField::HardwareModeEnum
    struct HardwareModeEnum;
    // Nested type: ::BoingKit::BoingReactorField::CellMoveModeEnum
    struct CellMoveModeEnum;
    // Nested type: ::BoingKit::BoingReactorField::FalloffModeEnum
    struct FalloffModeEnum;
    // Nested type: ::BoingKit::BoingReactorField::FalloffDimensionsEnum
    struct FalloffDimensionsEnum;
    // Nested type: ::BoingKit::BoingReactorField::ShaderPropertyIdSet
    class ShaderPropertyIdSet;
    // Nested type: ::BoingKit::BoingReactorField::FieldParams
    struct FieldParams;
    // Nested type: ::BoingKit::BoingReactorField::ComputeKernelId
    class ComputeKernelId;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: BoingKit.BoingReactorField/HardwareModeEnum
    // [TokenAttribute] Offset: FFFFFFFF
    struct HardwareModeEnum/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: HardwareModeEnum
      constexpr HardwareModeEnum(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public BoingKit.BoingReactorField/HardwareModeEnum CPU
      static constexpr const int CPU = 0;
      // Get static field: static public BoingKit.BoingReactorField/HardwareModeEnum CPU
      static ::BoingKit::BoingReactorField::HardwareModeEnum _get_CPU();
      // Set static field: static public BoingKit.BoingReactorField/HardwareModeEnum CPU
      static void _set_CPU(::BoingKit::BoingReactorField::HardwareModeEnum value);
      // static field const value: static public BoingKit.BoingReactorField/HardwareModeEnum GPU
      static constexpr const int GPU = 1;
      // Get static field: static public BoingKit.BoingReactorField/HardwareModeEnum GPU
      static ::BoingKit::BoingReactorField::HardwareModeEnum _get_GPU();
      // Set static field: static public BoingKit.BoingReactorField/HardwareModeEnum GPU
      static void _set_GPU(::BoingKit::BoingReactorField::HardwareModeEnum value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // BoingKit.BoingReactorField/HardwareModeEnum
    #pragma pack(pop)
    static check_size<sizeof(BoingReactorField::HardwareModeEnum), 0 + sizeof(int)> __BoingKit_BoingReactorField_HardwareModeEnumSizeCheck;
    static_assert(sizeof(BoingReactorField::HardwareModeEnum) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: BoingKit.BoingReactorField/CellMoveModeEnum
    // [TokenAttribute] Offset: FFFFFFFF
    struct CellMoveModeEnum/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: CellMoveModeEnum
      constexpr CellMoveModeEnum(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public BoingKit.BoingReactorField/CellMoveModeEnum Follow
      static constexpr const int Follow = 0;
      // Get static field: static public BoingKit.BoingReactorField/CellMoveModeEnum Follow
      static ::BoingKit::BoingReactorField::CellMoveModeEnum _get_Follow();
      // Set static field: static public BoingKit.BoingReactorField/CellMoveModeEnum Follow
      static void _set_Follow(::BoingKit::BoingReactorField::CellMoveModeEnum value);
      // static field const value: static public BoingKit.BoingReactorField/CellMoveModeEnum WrapAround
      static constexpr const int WrapAround = 1;
      // Get static field: static public BoingKit.BoingReactorField/CellMoveModeEnum WrapAround
      static ::BoingKit::BoingReactorField::CellMoveModeEnum _get_WrapAround();
      // Set static field: static public BoingKit.BoingReactorField/CellMoveModeEnum WrapAround
      static void _set_WrapAround(::BoingKit::BoingReactorField::CellMoveModeEnum value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // BoingKit.BoingReactorField/CellMoveModeEnum
    #pragma pack(pop)
    static check_size<sizeof(BoingReactorField::CellMoveModeEnum), 0 + sizeof(int)> __BoingKit_BoingReactorField_CellMoveModeEnumSizeCheck;
    static_assert(sizeof(BoingReactorField::CellMoveModeEnum) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: BoingKit.BoingReactorField/FalloffModeEnum
    // [TokenAttribute] Offset: FFFFFFFF
    struct FalloffModeEnum/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: FalloffModeEnum
      constexpr FalloffModeEnum(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public BoingKit.BoingReactorField/FalloffModeEnum None
      static constexpr const int None = 0;
      // Get static field: static public BoingKit.BoingReactorField/FalloffModeEnum None
      static ::BoingKit::BoingReactorField::FalloffModeEnum _get_None();
      // Set static field: static public BoingKit.BoingReactorField/FalloffModeEnum None
      static void _set_None(::BoingKit::BoingReactorField::FalloffModeEnum value);
      // static field const value: static public BoingKit.BoingReactorField/FalloffModeEnum Circle
      static constexpr const int Circle = 1;
      // Get static field: static public BoingKit.BoingReactorField/FalloffModeEnum Circle
      static ::BoingKit::BoingReactorField::FalloffModeEnum _get_Circle();
      // Set static field: static public BoingKit.BoingReactorField/FalloffModeEnum Circle
      static void _set_Circle(::BoingKit::BoingReactorField::FalloffModeEnum value);
      // static field const value: static public BoingKit.BoingReactorField/FalloffModeEnum Square
      static constexpr const int Square = 2;
      // Get static field: static public BoingKit.BoingReactorField/FalloffModeEnum Square
      static ::BoingKit::BoingReactorField::FalloffModeEnum _get_Square();
      // Set static field: static public BoingKit.BoingReactorField/FalloffModeEnum Square
      static void _set_Square(::BoingKit::BoingReactorField::FalloffModeEnum value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // BoingKit.BoingReactorField/FalloffModeEnum
    #pragma pack(pop)
    static check_size<sizeof(BoingReactorField::FalloffModeEnum), 0 + sizeof(int)> __BoingKit_BoingReactorField_FalloffModeEnumSizeCheck;
    static_assert(sizeof(BoingReactorField::FalloffModeEnum) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: BoingKit.BoingReactorField/FalloffDimensionsEnum
    // [TokenAttribute] Offset: FFFFFFFF
    struct FalloffDimensionsEnum/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: FalloffDimensionsEnum
      constexpr FalloffDimensionsEnum(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XYZ
      static constexpr const int XYZ = 0;
      // Get static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XYZ
      static ::BoingKit::BoingReactorField::FalloffDimensionsEnum _get_XYZ();
      // Set static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XYZ
      static void _set_XYZ(::BoingKit::BoingReactorField::FalloffDimensionsEnum value);
      // static field const value: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XY
      static constexpr const int XY = 1;
      // Get static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XY
      static ::BoingKit::BoingReactorField::FalloffDimensionsEnum _get_XY();
      // Set static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XY
      static void _set_XY(::BoingKit::BoingReactorField::FalloffDimensionsEnum value);
      // static field const value: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XZ
      static constexpr const int XZ = 2;
      // Get static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XZ
      static ::BoingKit::BoingReactorField::FalloffDimensionsEnum _get_XZ();
      // Set static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum XZ
      static void _set_XZ(::BoingKit::BoingReactorField::FalloffDimensionsEnum value);
      // static field const value: static public BoingKit.BoingReactorField/FalloffDimensionsEnum YZ
      static constexpr const int YZ = 3;
      // Get static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum YZ
      static ::BoingKit::BoingReactorField::FalloffDimensionsEnum _get_YZ();
      // Set static field: static public BoingKit.BoingReactorField/FalloffDimensionsEnum YZ
      static void _set_YZ(::BoingKit::BoingReactorField::FalloffDimensionsEnum value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // BoingKit.BoingReactorField/FalloffDimensionsEnum
    #pragma pack(pop)
    static check_size<sizeof(BoingReactorField::FalloffDimensionsEnum), 0 + sizeof(int)> __BoingKit_BoingReactorField_FalloffDimensionsEnumSizeCheck;
    static_assert(sizeof(BoingReactorField::FalloffDimensionsEnum) == 0x4);
    // Size: 0x70
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: BoingKit.BoingReactorField/FieldParams
    // [TokenAttribute] Offset: FFFFFFFF
    struct FieldParams/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Int32 CellsX
      // Size: 0x4
      // Offset: 0x0
      int CellsX;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 CellsY
      // Size: 0x4
      // Offset: 0x4
      int CellsY;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 CellsZ
      // Size: 0x4
      // Offset: 0x8
      int CellsZ;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 NumEffectors
      // Size: 0x4
      // Offset: 0xC
      int NumEffectors;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 iCellBaseX
      // Size: 0x4
      // Offset: 0x10
      int iCellBaseX;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 iCellBaseY
      // Size: 0x4
      // Offset: 0x14
      int iCellBaseY;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 iCellBaseZ
      // Size: 0x4
      // Offset: 0x18
      int iCellBaseZ;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 m_padding0
      // Size: 0x4
      // Offset: 0x1C
      int m_padding0;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 FalloffMode
      // Size: 0x4
      // Offset: 0x20
      int FalloffMode;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 FalloffDimensions
      // Size: 0x4
      // Offset: 0x24
      int FalloffDimensions;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 PropagationDepth
      // Size: 0x4
      // Offset: 0x28
      int PropagationDepth;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 m_padding1
      // Size: 0x4
      // Offset: 0x2C
      int m_padding1;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public UnityEngine.Vector3 GridCenter
      // Size: 0xC
      // Offset: 0x30
      ::UnityEngine::Vector3 GridCenter;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // private System.Single m_padding3
      // Size: 0x4
      // Offset: 0x3C
      float m_padding3;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public UnityEngine.Vector3 UpWs
      // Size: 0xC
      // Offset: 0x40
      ::UnityEngine::Vector3 UpWs;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // private System.Single m_padding2
      // Size: 0x4
      // Offset: 0x4C
      float m_padding2;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public UnityEngine.Vector3 FieldPosition
      // Size: 0xC
      // Offset: 0x50
      ::UnityEngine::Vector3 FieldPosition;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public System.Single m_padding4
      // Size: 0x4
      // Offset: 0x5C
      float m_padding4;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single FalloffRatio
      // Size: 0x4
      // Offset: 0x60
      float FalloffRatio;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single CellSize
      // Size: 0x4
      // Offset: 0x64
      float CellSize;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single DeltaTime
      // Size: 0x4
      // Offset: 0x68
      float DeltaTime;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // private System.Single m_padding5
      // Size: 0x4
      // Offset: 0x6C
      float m_padding5;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      public:
      // Creating value type constructor for type: FieldParams
      constexpr FieldParams(int CellsX_ = {}, int CellsY_ = {}, int CellsZ_ = {}, int NumEffectors_ = {}, int iCellBaseX_ = {}, int iCellBaseY_ = {}, int iCellBaseZ_ = {}, int m_padding0_ = {}, int FalloffMode_ = {}, int FalloffDimensions_ = {}, int PropagationDepth_ = {}, int m_padding1_ = {}, ::UnityEngine::Vector3 GridCenter_ = {}, float m_padding3_ = {}, ::UnityEngine::Vector3 UpWs_ = {}, float m_padding2_ = {}, ::UnityEngine::Vector3 FieldPosition_ = {}, float m_padding4_ = {}, float FalloffRatio_ = {}, float CellSize_ = {}, float DeltaTime_ = {}, float m_padding5_ = {}) noexcept : CellsX{CellsX_}, CellsY{CellsY_}, CellsZ{CellsZ_}, NumEffectors{NumEffectors_}, iCellBaseX{iCellBaseX_}, iCellBaseY{iCellBaseY_}, iCellBaseZ{iCellBaseZ_}, m_padding0{m_padding0_}, FalloffMode{FalloffMode_}, FalloffDimensions{FalloffDimensions_}, PropagationDepth{PropagationDepth_}, m_padding1{m_padding1_}, GridCenter{GridCenter_}, m_padding3{m_padding3_}, UpWs{UpWs_}, m_padding2{m_padding2_}, FieldPosition{FieldPosition_}, m_padding4{m_padding4_}, FalloffRatio{FalloffRatio_}, CellSize{CellSize_}, DeltaTime{DeltaTime_}, m_padding5{m_padding5_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get static field: static public readonly System.Int32 Stride
      static int _get_Stride();
      // Set static field: static public readonly System.Int32 Stride
      static void _set_Stride(int value);
      // Get instance field reference: public System.Int32 CellsX
      [[deprecated("Use field access instead!")]] int& dyn_CellsX();
      // Get instance field reference: public System.Int32 CellsY
      [[deprecated("Use field access instead!")]] int& dyn_CellsY();
      // Get instance field reference: public System.Int32 CellsZ
      [[deprecated("Use field access instead!")]] int& dyn_CellsZ();
      // Get instance field reference: public System.Int32 NumEffectors
      [[deprecated("Use field access instead!")]] int& dyn_NumEffectors();
      // Get instance field reference: public System.Int32 iCellBaseX
      [[deprecated("Use field access instead!")]] int& dyn_iCellBaseX();
      // Get instance field reference: public System.Int32 iCellBaseY
      [[deprecated("Use field access instead!")]] int& dyn_iCellBaseY();
      // Get instance field reference: public System.Int32 iCellBaseZ
      [[deprecated("Use field access instead!")]] int& dyn_iCellBaseZ();
      // Get instance field reference: public System.Int32 m_padding0
      [[deprecated("Use field access instead!")]] int& dyn_m_padding0();
      // Get instance field reference: public System.Int32 FalloffMode
      [[deprecated("Use field access instead!")]] int& dyn_FalloffMode();
      // Get instance field reference: public System.Int32 FalloffDimensions
      [[deprecated("Use field access instead!")]] int& dyn_FalloffDimensions();
      // Get instance field reference: public System.Int32 PropagationDepth
      [[deprecated("Use field access instead!")]] int& dyn_PropagationDepth();
      // Get instance field reference: public System.Int32 m_padding1
      [[deprecated("Use field access instead!")]] int& dyn_m_padding1();
      // Get instance field reference: public UnityEngine.Vector3 GridCenter
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_GridCenter();
      // Get instance field reference: private System.Single m_padding3
      [[deprecated("Use field access instead!")]] float& dyn_m_padding3();
      // Get instance field reference: public UnityEngine.Vector3 UpWs
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_UpWs();
      // Get instance field reference: private System.Single m_padding2
      [[deprecated("Use field access instead!")]] float& dyn_m_padding2();
      // Get instance field reference: public UnityEngine.Vector3 FieldPosition
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_FieldPosition();
      // Get instance field reference: public System.Single m_padding4
      [[deprecated("Use field access instead!")]] float& dyn_m_padding4();
      // Get instance field reference: public System.Single FalloffRatio
      [[deprecated("Use field access instead!")]] float& dyn_FalloffRatio();
      // Get instance field reference: public System.Single CellSize
      [[deprecated("Use field access instead!")]] float& dyn_CellSize();
      // Get instance field reference: public System.Single DeltaTime
      [[deprecated("Use field access instead!")]] float& dyn_DeltaTime();
      // Get instance field reference: private System.Single m_padding5
      [[deprecated("Use field access instead!")]] float& dyn_m_padding5();
      // private System.Void SuppressWarnings()
      // Offset: 0x28F7C3C
      void SuppressWarnings();
      // static private System.Void .cctor()
      // Offset: 0x28F7C5C
      static void _cctor();
    }; // BoingKit.BoingReactorField/FieldParams
    #pragma pack(pop)
    static check_size<sizeof(BoingReactorField::FieldParams), 108 + sizeof(float)> __BoingKit_BoingReactorField_FieldParamsSizeCheck;
    static_assert(sizeof(BoingReactorField::FieldParams) == 0x70);
    public:
    // private BoingKit.BoingReactorField/FieldParams m_fieldParams
    // Size: 0x70
    // Offset: 0x44
    ::BoingKit::BoingReactorField::FieldParams m_fieldParams;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingReactorField::FieldParams) == 0x70);
    // public BoingKit.BoingReactorField/HardwareModeEnum HardwareMode
    // Size: 0x4
    // Offset: 0xB4
    ::BoingKit::BoingReactorField::HardwareModeEnum HardwareMode;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingReactorField::HardwareModeEnum) == 0x4);
    // private BoingKit.BoingReactorField/HardwareModeEnum m_hardwareMode
    // Size: 0x4
    // Offset: 0xB8
    ::BoingKit::BoingReactorField::HardwareModeEnum m_hardwareMode;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingReactorField::HardwareModeEnum) == 0x4);
    // public BoingKit.BoingReactorField/CellMoveModeEnum CellMoveMode
    // Size: 0x4
    // Offset: 0xBC
    ::BoingKit::BoingReactorField::CellMoveModeEnum CellMoveMode;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingReactorField::CellMoveModeEnum) == 0x4);
    // private BoingKit.BoingReactorField/CellMoveModeEnum m_cellMoveMode
    // Size: 0x4
    // Offset: 0xC0
    ::BoingKit::BoingReactorField::CellMoveModeEnum m_cellMoveMode;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingReactorField::CellMoveModeEnum) == 0x4);
    // public System.Single CellSize
    // Size: 0x4
    // Offset: 0xC4
    float CellSize;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Int32 CellsX
    // Size: 0x4
    // Offset: 0xC8
    int CellsX;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 CellsY
    // Size: 0x4
    // Offset: 0xCC
    int CellsY;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32 CellsZ
    // Size: 0x4
    // Offset: 0xD0
    int CellsZ;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 m_cellsX
    // Size: 0x4
    // Offset: 0xD4
    int m_cellsX;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 m_cellsY
    // Size: 0x4
    // Offset: 0xD8
    int m_cellsY;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 m_cellsZ
    // Size: 0x4
    // Offset: 0xDC
    int m_cellsZ;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 m_iCellBaseX
    // Size: 0x4
    // Offset: 0xE0
    int m_iCellBaseX;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 m_iCellBaseY
    // Size: 0x4
    // Offset: 0xE4
    int m_iCellBaseY;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 m_iCellBaseZ
    // Size: 0x4
    // Offset: 0xE8
    int m_iCellBaseZ;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public BoingKit.BoingReactorField/FalloffModeEnum FalloffMode
    // Size: 0x4
    // Offset: 0xEC
    ::BoingKit::BoingReactorField::FalloffModeEnum FalloffMode;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingReactorField::FalloffModeEnum) == 0x4);
    // public System.Single FalloffRatio
    // Size: 0x4
    // Offset: 0xF0
    float FalloffRatio;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public BoingKit.BoingReactorField/FalloffDimensionsEnum FalloffDimensions
    // Size: 0x4
    // Offset: 0xF4
    ::BoingKit::BoingReactorField::FalloffDimensionsEnum FalloffDimensions;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingReactorField::FalloffDimensionsEnum) == 0x4);
    // public BoingKit.BoingEffector[] Effectors
    // Size: 0x8
    // Offset: 0xF8
    ::ArrayW<::BoingKit::BoingEffector*> Effectors;
    // Field size check
    static_assert(sizeof(::ArrayW<::BoingKit::BoingEffector*>) == 0x8);
    // private System.Int32 m_numEffectors
    // Size: 0x4
    // Offset: 0x100
    int m_numEffectors;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private BoingKit.Aabb m_bounds
    // Size: 0x18
    // Offset: 0x104
    ::BoingKit::Aabb m_bounds;
    // Field size check
    static_assert(sizeof(::BoingKit::Aabb) == 0x18);
    // public System.Boolean TwoDDistanceCheck
    // Size: 0x1
    // Offset: 0x11C
    bool TwoDDistanceCheck;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean TwoDPositionInfluence
    // Size: 0x1
    // Offset: 0x11D
    bool TwoDPositionInfluence;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean TwoDRotationInfluence
    // Size: 0x1
    // Offset: 0x11E
    bool TwoDRotationInfluence;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean EnablePositionEffect
    // Size: 0x1
    // Offset: 0x11F
    bool EnablePositionEffect;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean EnableRotationEffect
    // Size: 0x1
    // Offset: 0x120
    bool EnableRotationEffect;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean GlobalReactionUpVector
    // Size: 0x1
    // Offset: 0x121
    bool GlobalReactionUpVector;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: GlobalReactionUpVector and: Params
    char __padding26[0x2] = {};
    // public BoingKit.BoingWork/Params Params
    // Size: 0x160
    // Offset: 0x124
    ::BoingKit::BoingWork::Params Params;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingWork::Params) == 0x160);
    // Padding between fields: Params and: SharedParams
    char __padding27[0x4] = {};
    // public BoingKit.SharedBoingParams SharedParams
    // Size: 0x8
    // Offset: 0x288
    ::BoingKit::SharedBoingParams* SharedParams;
    // Field size check
    static_assert(sizeof(::BoingKit::SharedBoingParams*) == 0x8);
    // public System.Boolean EnablePropagation
    // Size: 0x1
    // Offset: 0x290
    bool EnablePropagation;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: EnablePropagation and: PositionPropagation
    char __padding29[0x3] = {};
    // public System.Single PositionPropagation
    // Size: 0x4
    // Offset: 0x294
    float PositionPropagation;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single RotationPropagation
    // Size: 0x4
    // Offset: 0x298
    float RotationPropagation;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Int32 PropagationDepth
    // Size: 0x4
    // Offset: 0x29C
    int PropagationDepth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean AnchorPropagationAtBorder
    // Size: 0x1
    // Offset: 0x2A0
    bool AnchorPropagationAtBorder;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: AnchorPropagationAtBorder and: m_aCpuCell
    char __padding33[0x7] = {};
    // private BoingKit.BoingWork/Params/InstanceData[,,] m_aCpuCell
    // Size: 0x8
    // Offset: 0x2A8
    ::ArrayW<::BoingKit::BoingWork::Params::InstanceData> m_aCpuCell;
    // Field size check
    static_assert(sizeof(::ArrayW<::BoingKit::BoingWork::Params::InstanceData>) == 0x8);
    // private UnityEngine.ComputeShader m_shader
    // Size: 0x8
    // Offset: 0x2B0
    ::UnityEngine::ComputeShader* m_shader;
    // Field size check
    static_assert(sizeof(::UnityEngine::ComputeShader*) == 0x8);
    // private UnityEngine.ComputeBuffer m_effectorIndexBuffer
    // Size: 0x8
    // Offset: 0x2B8
    ::UnityEngine::ComputeBuffer* m_effectorIndexBuffer;
    // Field size check
    static_assert(sizeof(::UnityEngine::ComputeBuffer*) == 0x8);
    // private UnityEngine.ComputeBuffer m_reactorParamsBuffer
    // Size: 0x8
    // Offset: 0x2C0
    ::UnityEngine::ComputeBuffer* m_reactorParamsBuffer;
    // Field size check
    static_assert(sizeof(::UnityEngine::ComputeBuffer*) == 0x8);
    // private UnityEngine.ComputeBuffer m_fieldParamsBuffer
    // Size: 0x8
    // Offset: 0x2C8
    ::UnityEngine::ComputeBuffer* m_fieldParamsBuffer;
    // Field size check
    static_assert(sizeof(::UnityEngine::ComputeBuffer*) == 0x8);
    // private UnityEngine.ComputeBuffer m_cellsBuffer
    // Size: 0x8
    // Offset: 0x2D0
    ::UnityEngine::ComputeBuffer* m_cellsBuffer;
    // Field size check
    static_assert(sizeof(::UnityEngine::ComputeBuffer*) == 0x8);
    // private System.Int32 m_gpuResourceSetId
    // Size: 0x4
    // Offset: 0x2D8
    int m_gpuResourceSetId;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean m_init
    // Size: 0x1
    // Offset: 0x2DC
    bool m_init;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_init and: m_gridCenter
    char __padding41[0x3] = {};
    // private UnityEngine.Vector3 m_gridCenter
    // Size: 0xC
    // Offset: 0x2E0
    ::UnityEngine::Vector3 m_gridCenter;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 m_qPrevGridCenterNorm
    // Size: 0xC
    // Offset: 0x2EC
    ::UnityEngine::Vector3 m_qPrevGridCenterNorm;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Boolean m_cellBufferNeedsReset
    // Size: 0x1
    // Offset: 0x2F8
    bool m_cellBufferNeedsReset;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_cellBufferNeedsReset and: s_aReactorParams
    char __padding44[0x7] = {};
    // private BoingKit.BoingWork/Params[] s_aReactorParams
    // Size: 0x8
    // Offset: 0x300
    ::ArrayW<::BoingKit::BoingWork::Params> s_aReactorParams;
    // Field size check
    static_assert(sizeof(::ArrayW<::BoingKit::BoingWork::Params>) == 0x8);
    public:
    // Get static field: static private BoingKit.BoingReactorField/ShaderPropertyIdSet s_shaderPropertyId
    static ::BoingKit::BoingReactorField::ShaderPropertyIdSet* _get_s_shaderPropertyId();
    // Set static field: static private BoingKit.BoingReactorField/ShaderPropertyIdSet s_shaderPropertyId
    static void _set_s_shaderPropertyId(::BoingKit::BoingReactorField::ShaderPropertyIdSet* value);
    // Get static field: static private readonly System.Single kPropagationFactor
    static float _get_kPropagationFactor();
    // Set static field: static private readonly System.Single kPropagationFactor
    static void _set_kPropagationFactor(float value);
    // Get static field: static private BoingKit.BoingReactorField/ComputeKernelId s_computeKernelId
    static ::BoingKit::BoingReactorField::ComputeKernelId* _get_s_computeKernelId();
    // Set static field: static private BoingKit.BoingReactorField/ComputeKernelId s_computeKernelId
    static void _set_s_computeKernelId(::BoingKit::BoingReactorField::ComputeKernelId* value);
    // Get static field: static private UnityEngine.Vector3[] s_aCellOffset
    static ::ArrayW<::UnityEngine::Vector3> _get_s_aCellOffset();
    // Set static field: static private UnityEngine.Vector3[] s_aCellOffset
    static void _set_s_aCellOffset(::ArrayW<::UnityEngine::Vector3> value);
    // Get static field: static private System.Single[] s_aSqrtInv
    static ::ArrayW<float> _get_s_aSqrtInv();
    // Set static field: static private System.Single[] s_aSqrtInv
    static void _set_s_aSqrtInv(::ArrayW<float> value);
    // Get instance field reference: private BoingKit.BoingReactorField/FieldParams m_fieldParams
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingReactorField::FieldParams& dyn_m_fieldParams();
    // Get instance field reference: public BoingKit.BoingReactorField/HardwareModeEnum HardwareMode
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingReactorField::HardwareModeEnum& dyn_HardwareMode();
    // Get instance field reference: private BoingKit.BoingReactorField/HardwareModeEnum m_hardwareMode
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingReactorField::HardwareModeEnum& dyn_m_hardwareMode();
    // Get instance field reference: public BoingKit.BoingReactorField/CellMoveModeEnum CellMoveMode
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingReactorField::CellMoveModeEnum& dyn_CellMoveMode();
    // Get instance field reference: private BoingKit.BoingReactorField/CellMoveModeEnum m_cellMoveMode
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingReactorField::CellMoveModeEnum& dyn_m_cellMoveMode();
    // Get instance field reference: public System.Single CellSize
    [[deprecated("Use field access instead!")]] float& dyn_CellSize();
    // Get instance field reference: public System.Int32 CellsX
    [[deprecated("Use field access instead!")]] int& dyn_CellsX();
    // Get instance field reference: public System.Int32 CellsY
    [[deprecated("Use field access instead!")]] int& dyn_CellsY();
    // Get instance field reference: public System.Int32 CellsZ
    [[deprecated("Use field access instead!")]] int& dyn_CellsZ();
    // Get instance field reference: private System.Int32 m_cellsX
    [[deprecated("Use field access instead!")]] int& dyn_m_cellsX();
    // Get instance field reference: private System.Int32 m_cellsY
    [[deprecated("Use field access instead!")]] int& dyn_m_cellsY();
    // Get instance field reference: private System.Int32 m_cellsZ
    [[deprecated("Use field access instead!")]] int& dyn_m_cellsZ();
    // Get instance field reference: private System.Int32 m_iCellBaseX
    [[deprecated("Use field access instead!")]] int& dyn_m_iCellBaseX();
    // Get instance field reference: private System.Int32 m_iCellBaseY
    [[deprecated("Use field access instead!")]] int& dyn_m_iCellBaseY();
    // Get instance field reference: private System.Int32 m_iCellBaseZ
    [[deprecated("Use field access instead!")]] int& dyn_m_iCellBaseZ();
    // Get instance field reference: public BoingKit.BoingReactorField/FalloffModeEnum FalloffMode
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingReactorField::FalloffModeEnum& dyn_FalloffMode();
    // Get instance field reference: public System.Single FalloffRatio
    [[deprecated("Use field access instead!")]] float& dyn_FalloffRatio();
    // Get instance field reference: public BoingKit.BoingReactorField/FalloffDimensionsEnum FalloffDimensions
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingReactorField::FalloffDimensionsEnum& dyn_FalloffDimensions();
    // Get instance field reference: public BoingKit.BoingEffector[] Effectors
    [[deprecated("Use field access instead!")]] ::ArrayW<::BoingKit::BoingEffector*>& dyn_Effectors();
    // Get instance field reference: private System.Int32 m_numEffectors
    [[deprecated("Use field access instead!")]] int& dyn_m_numEffectors();
    // Get instance field reference: private BoingKit.Aabb m_bounds
    [[deprecated("Use field access instead!")]] ::BoingKit::Aabb& dyn_m_bounds();
    // Get instance field reference: public System.Boolean TwoDDistanceCheck
    [[deprecated("Use field access instead!")]] bool& dyn_TwoDDistanceCheck();
    // Get instance field reference: public System.Boolean TwoDPositionInfluence
    [[deprecated("Use field access instead!")]] bool& dyn_TwoDPositionInfluence();
    // Get instance field reference: public System.Boolean TwoDRotationInfluence
    [[deprecated("Use field access instead!")]] bool& dyn_TwoDRotationInfluence();
    // Get instance field reference: public System.Boolean EnablePositionEffect
    [[deprecated("Use field access instead!")]] bool& dyn_EnablePositionEffect();
    // Get instance field reference: public System.Boolean EnableRotationEffect
    [[deprecated("Use field access instead!")]] bool& dyn_EnableRotationEffect();
    // Get instance field reference: public System.Boolean GlobalReactionUpVector
    [[deprecated("Use field access instead!")]] bool& dyn_GlobalReactionUpVector();
    // Get instance field reference: public BoingKit.BoingWork/Params Params
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingWork::Params& dyn_Params();
    // Get instance field reference: public BoingKit.SharedBoingParams SharedParams
    [[deprecated("Use field access instead!")]] ::BoingKit::SharedBoingParams*& dyn_SharedParams();
    // Get instance field reference: public System.Boolean EnablePropagation
    [[deprecated("Use field access instead!")]] bool& dyn_EnablePropagation();
    // Get instance field reference: public System.Single PositionPropagation
    [[deprecated("Use field access instead!")]] float& dyn_PositionPropagation();
    // Get instance field reference: public System.Single RotationPropagation
    [[deprecated("Use field access instead!")]] float& dyn_RotationPropagation();
    // Get instance field reference: public System.Int32 PropagationDepth
    [[deprecated("Use field access instead!")]] int& dyn_PropagationDepth();
    // Get instance field reference: public System.Boolean AnchorPropagationAtBorder
    [[deprecated("Use field access instead!")]] bool& dyn_AnchorPropagationAtBorder();
    // Get instance field reference: private BoingKit.BoingWork/Params/InstanceData[,,] m_aCpuCell
    [[deprecated("Use field access instead!")]] ::ArrayW<::BoingKit::BoingWork::Params::InstanceData>& dyn_m_aCpuCell();
    // Get instance field reference: private UnityEngine.ComputeShader m_shader
    [[deprecated("Use field access instead!")]] ::UnityEngine::ComputeShader*& dyn_m_shader();
    // Get instance field reference: private UnityEngine.ComputeBuffer m_effectorIndexBuffer
    [[deprecated("Use field access instead!")]] ::UnityEngine::ComputeBuffer*& dyn_m_effectorIndexBuffer();
    // Get instance field reference: private UnityEngine.ComputeBuffer m_reactorParamsBuffer
    [[deprecated("Use field access instead!")]] ::UnityEngine::ComputeBuffer*& dyn_m_reactorParamsBuffer();
    // Get instance field reference: private UnityEngine.ComputeBuffer m_fieldParamsBuffer
    [[deprecated("Use field access instead!")]] ::UnityEngine::ComputeBuffer*& dyn_m_fieldParamsBuffer();
    // Get instance field reference: private UnityEngine.ComputeBuffer m_cellsBuffer
    [[deprecated("Use field access instead!")]] ::UnityEngine::ComputeBuffer*& dyn_m_cellsBuffer();
    // Get instance field reference: private System.Int32 m_gpuResourceSetId
    [[deprecated("Use field access instead!")]] int& dyn_m_gpuResourceSetId();
    // Get instance field reference: private System.Boolean m_init
    [[deprecated("Use field access instead!")]] bool& dyn_m_init();
    // Get instance field reference: private UnityEngine.Vector3 m_gridCenter
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_m_gridCenter();
    // Get instance field reference: private UnityEngine.Vector3 m_qPrevGridCenterNorm
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_m_qPrevGridCenterNorm();
    // Get instance field reference: private System.Boolean m_cellBufferNeedsReset
    [[deprecated("Use field access instead!")]] bool& dyn_m_cellBufferNeedsReset();
    // Get instance field reference: private BoingKit.BoingWork/Params[] s_aReactorParams
    [[deprecated("Use field access instead!")]] ::ArrayW<::BoingKit::BoingWork::Params>& dyn_s_aReactorParams();
    // static public BoingKit.BoingReactorField/ShaderPropertyIdSet get_ShaderPropertyId()
    // Offset: 0x28F28EC
    static ::BoingKit::BoingReactorField::ShaderPropertyIdSet* get_ShaderPropertyId();
    // public System.Boolean UpdateShaderConstants(UnityEngine.MaterialPropertyBlock props, System.Single positionSampleMultiplier, System.Single rotationSampleMultiplier)
    // Offset: 0x28F29B8
    bool UpdateShaderConstants(::UnityEngine::MaterialPropertyBlock* props, float positionSampleMultiplier, float rotationSampleMultiplier);
    // public System.Boolean UpdateShaderConstants(UnityEngine.Material material, System.Single positionSampleMultiplier, System.Single rotationSampleMultiplier)
    // Offset: 0x28F2ABC
    bool UpdateShaderConstants(::UnityEngine::Material* material, float positionSampleMultiplier, float rotationSampleMultiplier);
    // public System.Int32 get_GpuResourceSetId()
    // Offset: 0x28F2BC0
    int get_GpuResourceSetId();
    // public System.Void Reboot()
    // Offset: 0x28F2D0C
    void Reboot();
    // public System.Void OnEnable()
    // Offset: 0x28F3010
    void OnEnable();
    // public System.Void Start()
    // Offset: 0x28F306C
    void Start();
    // public System.Void OnDisable()
    // Offset: 0x28F3088
    void OnDisable();
    // public System.Void DisposeCpuResources()
    // Offset: 0x28F30F4
    void DisposeCpuResources();
    // public System.Void DisposeGpuResources()
    // Offset: 0x28F3108
    void DisposeGpuResources();
    // public System.Boolean SampleCpuGrid(UnityEngine.Vector3 p, out UnityEngine.Vector3 positionOffset, out UnityEngine.Vector4 rotationOffset)
    // Offset: 0x28F31D8
    bool SampleCpuGrid(::UnityEngine::Vector3 p, ByRef<::UnityEngine::Vector3> positionOffset, ByRef<::UnityEngine::Vector4> rotationOffset);
    // private System.Void UpdateFieldParamsGpu()
    // Offset: 0x28F4218
    void UpdateFieldParamsGpu();
    // private System.Void UpdateFlags()
    // Offset: 0x28F4564
    void UpdateFlags();
    // public System.Void UpdateBounds()
    // Offset: 0x28F461C
    void UpdateBounds();
    // public System.Void PrepareExecute()
    // Offset: 0x28F46EC
    void PrepareExecute();
    // private System.Void ValidateCpuResources()
    // Offset: 0x28F4878
    void ValidateCpuResources();
    // private System.Void ValidateGpuResources()
    // Offset: 0x28F4A98
    void ValidateGpuResources();
    // private System.Void FinishPrepareExecuteCpu()
    // Offset: 0x28F5814
    void FinishPrepareExecuteCpu();
    // private System.Void FinishPrepareExecuteGpu()
    // Offset: 0x28F59BC
    void FinishPrepareExecuteGpu();
    // public System.Void Init()
    // Offset: 0x28F4858
    void Init();
    // public System.Void Sanitize()
    // Offset: 0x28F5A58
    void Sanitize();
    // public System.Void HandleCellMove()
    // Offset: 0x28F5484
    void HandleCellMove();
    // private System.Void InitPropagationCpu(ref BoingKit.BoingWork/Params/InstanceData data)
    // Offset: 0x28F6174
    void InitPropagationCpu(ByRef<::BoingKit::BoingWork::Params::InstanceData> data);
    // private System.Void PropagateSpringCpu(ref BoingKit.BoingWork/Params/InstanceData data, System.Single dt)
    // Offset: 0x28F61E4
    void PropagateSpringCpu(ByRef<::BoingKit::BoingWork::Params::InstanceData> data, float dt);
    // private System.Void ExtendPropagationBorder(ref BoingKit.BoingWork/Params/InstanceData data, System.Single weight, System.Int32 adjDeltaX, System.Int32 adjDeltaY, System.Int32 adjDeltaZ)
    // Offset: 0x28F62CC
    void ExtendPropagationBorder(ByRef<::BoingKit::BoingWork::Params::InstanceData> data, float weight, int adjDeltaX, int adjDeltaY, int adjDeltaZ);
    // private System.Void AccumulatePropagationWeightedNeighbor(ref BoingKit.BoingWork/Params/InstanceData data, ref BoingKit.BoingWork/Params/InstanceData neighbor, System.Single weight)
    // Offset: 0x28F6330
    void AccumulatePropagationWeightedNeighbor(ByRef<::BoingKit::BoingWork::Params::InstanceData> data, ByRef<::BoingKit::BoingWork::Params::InstanceData> neighbor, float weight);
    // private System.Void GatherPropagation(ref BoingKit.BoingWork/Params/InstanceData data, System.Single weightSum)
    // Offset: 0x28F6388
    void GatherPropagation(ByRef<::BoingKit::BoingWork::Params::InstanceData> data, float weightSum);
    // private System.Void AnchorPropagationBorder(ref BoingKit.BoingWork/Params/InstanceData data)
    // Offset: 0x28F63E8
    void AnchorPropagationBorder(ByRef<::BoingKit::BoingWork::Params::InstanceData> data);
    // private System.Void PropagateCpu(System.Single dt)
    // Offset: 0x28F6458
    void PropagateCpu(float dt);
    // private System.Void WrapCpu(System.Int32 deltaX, System.Int32 deltaY, System.Int32 deltaZ)
    // Offset: 0x28F5B24
    void WrapCpu(int deltaX, int deltaY, int deltaZ);
    // private System.Void WrapGpu(System.Int32 deltaX, System.Int32 deltaY, System.Int32 deltaZ)
    // Offset: 0x28F5FA8
    void WrapGpu(int deltaX, int deltaY, int deltaZ);
    // public System.Void ExecuteCpu(System.Single dt)
    // Offset: 0x28F6BD0
    void ExecuteCpu(float dt);
    // public System.Void ExecuteGpu(System.Single dt, UnityEngine.ComputeBuffer effectorParamsBuffer, System.Collections.Generic.Dictionary`2<System.Int32,System.Int32> effectorParamsIndexMap)
    // Offset: 0x28F09BC
    void ExecuteGpu(float dt, ::UnityEngine::ComputeBuffer* effectorParamsBuffer, ::System::Collections::Generic::Dictionary_2<int, int>* effectorParamsIndexMap);
    // public System.Void OnDrawGizmosSelected()
    // Offset: 0x28F6EF4
    void OnDrawGizmosSelected();
    // private System.Void DrawGizmos(System.Boolean drawEffectors)
    // Offset: 0x28F6F20
    void DrawGizmos(bool drawEffectors);
    // private UnityEngine.Vector3 GetGridCenter()
    // Offset: 0x28F78E8
    ::UnityEngine::Vector3 GetGridCenter();
    // private UnityEngine.Vector3 QuantizeNorm(UnityEngine.Vector3 p)
    // Offset: 0x28F2E6C
    ::UnityEngine::Vector3 QuantizeNorm(::UnityEngine::Vector3 p);
    // private UnityEngine.Vector3 GetCellCenterOffset(System.Int32 x, System.Int32 y, System.Int32 z)
    // Offset: 0x28F4078
    ::UnityEngine::Vector3 GetCellCenterOffset(int x, int y, int z);
    // private System.Void ResolveCellIndex(System.Int32 x, System.Int32 y, System.Int32 z, System.Int32 baseMult, out System.Int32 resX, out System.Int32 resY, out System.Int32 resZ)
    // Offset: 0x28F4140
    void ResolveCellIndex(int x, int y, int z, int baseMult, ByRef<int> resX, ByRef<int> resY, ByRef<int> resZ);
    // static private System.Void .cctor()
    // Offset: 0x28F7954
    static void _cctor();
    // public System.Void .ctor()
    // Offset: 0x28F2BC8
    // Implemented from: BoingKit.BoingBase
    // Base method: System.Void BoingBase::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static BoingReactorField* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::BoingKit::BoingReactorField::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<BoingReactorField*, creationType>()));
    }
  }; // BoingKit.BoingReactorField
  #pragma pack(pop)
  static check_size<sizeof(BoingReactorField), 768 + sizeof(::ArrayW<::BoingKit::BoingWork::Params>)> __BoingKit_BoingReactorFieldSizeCheck;
  static_assert(sizeof(BoingReactorField) == 0x308);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingReactorField::FieldParams, "BoingKit", "BoingReactorField/FieldParams");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingReactorField::FalloffDimensionsEnum, "BoingKit", "BoingReactorField/FalloffDimensionsEnum");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingReactorField::FalloffModeEnum, "BoingKit", "BoingReactorField/FalloffModeEnum");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingReactorField::CellMoveModeEnum, "BoingKit", "BoingReactorField/CellMoveModeEnum");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingReactorField::HardwareModeEnum, "BoingKit", "BoingReactorField/HardwareModeEnum");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: BoingKit::BoingReactorField::get_ShaderPropertyId
// Il2CppName: get_ShaderPropertyId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::BoingKit::BoingReactorField::ShaderPropertyIdSet* (*)()>(&BoingKit::BoingReactorField::get_ShaderPropertyId)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "get_ShaderPropertyId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::UpdateShaderConstants
// Il2CppName: UpdateShaderConstants
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (BoingKit::BoingReactorField::*)(::UnityEngine::MaterialPropertyBlock*, float, float)>(&BoingKit::BoingReactorField::UpdateShaderConstants)> {
  static const MethodInfo* get() {
    static auto* props = &::il2cpp_utils::GetClassFromName("UnityEngine", "MaterialPropertyBlock")->byval_arg;
    static auto* positionSampleMultiplier = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* rotationSampleMultiplier = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "UpdateShaderConstants", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{props, positionSampleMultiplier, rotationSampleMultiplier});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::UpdateShaderConstants
// Il2CppName: UpdateShaderConstants
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (BoingKit::BoingReactorField::*)(::UnityEngine::Material*, float, float)>(&BoingKit::BoingReactorField::UpdateShaderConstants)> {
  static const MethodInfo* get() {
    static auto* material = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* positionSampleMultiplier = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* rotationSampleMultiplier = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "UpdateShaderConstants", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{material, positionSampleMultiplier, rotationSampleMultiplier});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::get_GpuResourceSetId
// Il2CppName: get_GpuResourceSetId
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::get_GpuResourceSetId)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "get_GpuResourceSetId", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::Reboot
// Il2CppName: Reboot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::Reboot)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "Reboot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::DisposeCpuResources
// Il2CppName: DisposeCpuResources
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::DisposeCpuResources)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "DisposeCpuResources", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::DisposeGpuResources
// Il2CppName: DisposeGpuResources
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::DisposeGpuResources)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "DisposeGpuResources", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::SampleCpuGrid
// Il2CppName: SampleCpuGrid
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (BoingKit::BoingReactorField::*)(::UnityEngine::Vector3, ByRef<::UnityEngine::Vector3>, ByRef<::UnityEngine::Vector4>)>(&BoingKit::BoingReactorField::SampleCpuGrid)> {
  static const MethodInfo* get() {
    static auto* p = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* positionOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* rotationOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector4")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "SampleCpuGrid", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p, positionOffset, rotationOffset});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::UpdateFieldParamsGpu
// Il2CppName: UpdateFieldParamsGpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::UpdateFieldParamsGpu)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "UpdateFieldParamsGpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::UpdateFlags
// Il2CppName: UpdateFlags
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::UpdateFlags)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "UpdateFlags", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::UpdateBounds
// Il2CppName: UpdateBounds
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::UpdateBounds)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "UpdateBounds", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::PrepareExecute
// Il2CppName: PrepareExecute
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::PrepareExecute)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "PrepareExecute", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::ValidateCpuResources
// Il2CppName: ValidateCpuResources
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::ValidateCpuResources)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "ValidateCpuResources", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::ValidateGpuResources
// Il2CppName: ValidateGpuResources
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::ValidateGpuResources)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "ValidateGpuResources", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::FinishPrepareExecuteCpu
// Il2CppName: FinishPrepareExecuteCpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::FinishPrepareExecuteCpu)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "FinishPrepareExecuteCpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::FinishPrepareExecuteGpu
// Il2CppName: FinishPrepareExecuteGpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::FinishPrepareExecuteGpu)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "FinishPrepareExecuteGpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::Init
// Il2CppName: Init
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::Init)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "Init", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::Sanitize
// Il2CppName: Sanitize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::Sanitize)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "Sanitize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::HandleCellMove
// Il2CppName: HandleCellMove
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::HandleCellMove)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "HandleCellMove", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::InitPropagationCpu
// Il2CppName: InitPropagationCpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(ByRef<::BoingKit::BoingWork::Params::InstanceData>)>(&BoingKit::BoingReactorField::InitPropagationCpu)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params/InstanceData")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "InitPropagationCpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::PropagateSpringCpu
// Il2CppName: PropagateSpringCpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(ByRef<::BoingKit::BoingWork::Params::InstanceData>, float)>(&BoingKit::BoingReactorField::PropagateSpringCpu)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params/InstanceData")->this_arg;
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "PropagateSpringCpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, dt});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::ExtendPropagationBorder
// Il2CppName: ExtendPropagationBorder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(ByRef<::BoingKit::BoingWork::Params::InstanceData>, float, int, int, int)>(&BoingKit::BoingReactorField::ExtendPropagationBorder)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params/InstanceData")->this_arg;
    static auto* weight = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* adjDeltaX = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* adjDeltaY = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* adjDeltaZ = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "ExtendPropagationBorder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, weight, adjDeltaX, adjDeltaY, adjDeltaZ});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::AccumulatePropagationWeightedNeighbor
// Il2CppName: AccumulatePropagationWeightedNeighbor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(ByRef<::BoingKit::BoingWork::Params::InstanceData>, ByRef<::BoingKit::BoingWork::Params::InstanceData>, float)>(&BoingKit::BoingReactorField::AccumulatePropagationWeightedNeighbor)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params/InstanceData")->this_arg;
    static auto* neighbor = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params/InstanceData")->this_arg;
    static auto* weight = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "AccumulatePropagationWeightedNeighbor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, neighbor, weight});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::GatherPropagation
// Il2CppName: GatherPropagation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(ByRef<::BoingKit::BoingWork::Params::InstanceData>, float)>(&BoingKit::BoingReactorField::GatherPropagation)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params/InstanceData")->this_arg;
    static auto* weightSum = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "GatherPropagation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data, weightSum});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::AnchorPropagationBorder
// Il2CppName: AnchorPropagationBorder
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(ByRef<::BoingKit::BoingWork::Params::InstanceData>)>(&BoingKit::BoingReactorField::AnchorPropagationBorder)> {
  static const MethodInfo* get() {
    static auto* data = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params/InstanceData")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "AnchorPropagationBorder", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{data});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::PropagateCpu
// Il2CppName: PropagateCpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(float)>(&BoingKit::BoingReactorField::PropagateCpu)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "PropagateCpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::WrapCpu
// Il2CppName: WrapCpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(int, int, int)>(&BoingKit::BoingReactorField::WrapCpu)> {
  static const MethodInfo* get() {
    static auto* deltaX = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* deltaY = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* deltaZ = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "WrapCpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{deltaX, deltaY, deltaZ});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::WrapGpu
// Il2CppName: WrapGpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(int, int, int)>(&BoingKit::BoingReactorField::WrapGpu)> {
  static const MethodInfo* get() {
    static auto* deltaX = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* deltaY = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* deltaZ = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "WrapGpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{deltaX, deltaY, deltaZ});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::ExecuteCpu
// Il2CppName: ExecuteCpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(float)>(&BoingKit::BoingReactorField::ExecuteCpu)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "ExecuteCpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::ExecuteGpu
// Il2CppName: ExecuteGpu
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(float, ::UnityEngine::ComputeBuffer*, ::System::Collections::Generic::Dictionary_2<int, int>*)>(&BoingKit::BoingReactorField::ExecuteGpu)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* effectorParamsBuffer = &::il2cpp_utils::GetClassFromName("UnityEngine", "ComputeBuffer")->byval_arg;
    static auto* effectorParamsIndexMap = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "Dictionary`2"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Int32"), ::il2cpp_utils::GetClassFromName("System", "Int32")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "ExecuteGpu", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt, effectorParamsBuffer, effectorParamsIndexMap});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::OnDrawGizmosSelected
// Il2CppName: OnDrawGizmosSelected
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::OnDrawGizmosSelected)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "OnDrawGizmosSelected", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::DrawGizmos
// Il2CppName: DrawGizmos
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(bool)>(&BoingKit::BoingReactorField::DrawGizmos)> {
  static const MethodInfo* get() {
    static auto* drawEffectors = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "DrawGizmos", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{drawEffectors});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::GetGridCenter
// Il2CppName: GetGridCenter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (BoingKit::BoingReactorField::*)()>(&BoingKit::BoingReactorField::GetGridCenter)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "GetGridCenter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::QuantizeNorm
// Il2CppName: QuantizeNorm
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (BoingKit::BoingReactorField::*)(::UnityEngine::Vector3)>(&BoingKit::BoingReactorField::QuantizeNorm)> {
  static const MethodInfo* get() {
    static auto* p = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "QuantizeNorm", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::GetCellCenterOffset
// Il2CppName: GetCellCenterOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (BoingKit::BoingReactorField::*)(int, int, int)>(&BoingKit::BoingReactorField::GetCellCenterOffset)> {
  static const MethodInfo* get() {
    static auto* x = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* y = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* z = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "GetCellCenterOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{x, y, z});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::ResolveCellIndex
// Il2CppName: ResolveCellIndex
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingReactorField::*)(int, int, int, int, ByRef<int>, ByRef<int>, ByRef<int>)>(&BoingKit::BoingReactorField::ResolveCellIndex)> {
  static const MethodInfo* get() {
    static auto* x = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* y = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* z = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* baseMult = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* resX = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* resY = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* resZ = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), "ResolveCellIndex", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{x, y, z, baseMult, resX, resY, resZ});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&BoingKit::BoingReactorField::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingReactorField*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingReactorField::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
