// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: BoingKit.BoingWork
#include "BoingKit/BoingWork.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Including type: BoingKit.Bits32
#include "BoingKit/Bits32.hpp"
// Including type: BoingKit.TwoDPlaneEnum
#include "BoingKit/TwoDPlaneEnum.hpp"
// Including type: BoingKit.ParameterMode
#include "BoingKit/ParameterMode.hpp"
// Including type: UnityEngine.Vector3
#include "UnityEngine/Vector3.hpp"
// Including type: BoingKit.BoingEffector
#include "BoingKit/BoingEffector.hpp"
// Including type: UnityEngine.Vector4
#include "UnityEngine/Vector4.hpp"
// Including type: BoingKit.Vector3Spring
#include "BoingKit/Vector3Spring.hpp"
// Including type: BoingKit.QuaternionSpring
#include "BoingKit/QuaternionSpring.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: BoingKit
namespace BoingKit {
  // Forward declaring type: BoingBones
  class BoingBones;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Skipping declaration: Quaternion because it is already included!
}
// Completed forward declares
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingWork::Params, "BoingKit", "BoingWork/Params");
// Type namespace: BoingKit
namespace BoingKit {
  // Size: 0x160
  #pragma pack(push, 1)
  // WARNING Layout: Sequential may not be correctly taken into account!
  // Autogenerated type: BoingKit.BoingWork/Params
  // [TokenAttribute] Offset: FFFFFFFF
  struct BoingWork::Params/*, public ::System::ValueType*/ {
    public:
    // Nested type: ::BoingKit::BoingWork::Params::InstanceData
    struct InstanceData;
    // Size: 0xF0
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: BoingKit.BoingWork/Params/InstanceData
    // [TokenAttribute] Offset: FFFFFFFF
    struct InstanceData/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.Vector3 PositionTarget
      // Size: 0xC
      // Offset: 0x0
      ::UnityEngine::Vector3 PositionTarget;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // private System.Single m_padding0
      // Size: 0x4
      // Offset: 0xC
      float m_padding0;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public UnityEngine.Vector3 PositionOrigin
      // Size: 0xC
      // Offset: 0x10
      ::UnityEngine::Vector3 PositionOrigin;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // private System.Single m_padding1
      // Size: 0x4
      // Offset: 0x1C
      float m_padding1;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public UnityEngine.Vector4 RotationTarget
      // Size: 0x10
      // Offset: 0x20
      ::UnityEngine::Vector4 RotationTarget;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
      // public UnityEngine.Vector4 RotationOrigin
      // Size: 0x10
      // Offset: 0x30
      ::UnityEngine::Vector4 RotationOrigin;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
      // public UnityEngine.Vector3 ScaleTarget
      // Size: 0xC
      // Offset: 0x40
      ::UnityEngine::Vector3 ScaleTarget;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // private System.Single m_padding2
      // Size: 0x4
      // Offset: 0x4C
      float m_padding2;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // private System.Int32 m_numEffectors
      // Size: 0x4
      // Offset: 0x50
      int m_numEffectors;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private System.Int32 m_instantAccumulation
      // Size: 0x4
      // Offset: 0x54
      int m_instantAccumulation;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private System.Int32 m_padding3
      // Size: 0x4
      // Offset: 0x58
      int m_padding3;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private System.Int32 m_padding4
      // Size: 0x4
      // Offset: 0x5C
      int m_padding4;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // private UnityEngine.Vector3 m_upWs
      // Size: 0xC
      // Offset: 0x60
      ::UnityEngine::Vector3 m_upWs;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // private System.Single m_minScale
      // Size: 0x4
      // Offset: 0x6C
      float m_minScale;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public BoingKit.Vector3Spring PositionSpring
      // Size: 0x20
      // Offset: 0x70
      ::BoingKit::Vector3Spring PositionSpring;
      // Field size check
      static_assert(sizeof(::BoingKit::Vector3Spring) == 0x20);
      // public BoingKit.QuaternionSpring RotationSpring
      // Size: 0x20
      // Offset: 0x90
      ::BoingKit::QuaternionSpring RotationSpring;
      // Field size check
      static_assert(sizeof(::BoingKit::QuaternionSpring) == 0x20);
      // public BoingKit.Vector3Spring ScaleSpring
      // Size: 0x20
      // Offset: 0xB0
      ::BoingKit::Vector3Spring ScaleSpring;
      // Field size check
      static_assert(sizeof(::BoingKit::Vector3Spring) == 0x20);
      // public UnityEngine.Vector3 PositionPropagationWorkData
      // Size: 0xC
      // Offset: 0xD0
      ::UnityEngine::Vector3 PositionPropagationWorkData;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // private System.Single m_padding5
      // Size: 0x4
      // Offset: 0xDC
      float m_padding5;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public UnityEngine.Vector4 RotationPropagationWorkData
      // Size: 0x10
      // Offset: 0xE0
      ::UnityEngine::Vector4 RotationPropagationWorkData;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
      public:
      // Creating value type constructor for type: InstanceData
      constexpr InstanceData(::UnityEngine::Vector3 PositionTarget_ = {}, float m_padding0_ = {}, ::UnityEngine::Vector3 PositionOrigin_ = {}, float m_padding1_ = {}, ::UnityEngine::Vector4 RotationTarget_ = {}, ::UnityEngine::Vector4 RotationOrigin_ = {}, ::UnityEngine::Vector3 ScaleTarget_ = {}, float m_padding2_ = {}, int m_numEffectors_ = {}, int m_instantAccumulation_ = {}, int m_padding3_ = {}, int m_padding4_ = {}, ::UnityEngine::Vector3 m_upWs_ = {}, float m_minScale_ = {}, ::BoingKit::Vector3Spring PositionSpring_ = {}, ::BoingKit::QuaternionSpring RotationSpring_ = {}, ::BoingKit::Vector3Spring ScaleSpring_ = {}, ::UnityEngine::Vector3 PositionPropagationWorkData_ = {}, float m_padding5_ = {}, ::UnityEngine::Vector4 RotationPropagationWorkData_ = {}) noexcept : PositionTarget{PositionTarget_}, m_padding0{m_padding0_}, PositionOrigin{PositionOrigin_}, m_padding1{m_padding1_}, RotationTarget{RotationTarget_}, RotationOrigin{RotationOrigin_}, ScaleTarget{ScaleTarget_}, m_padding2{m_padding2_}, m_numEffectors{m_numEffectors_}, m_instantAccumulation{m_instantAccumulation_}, m_padding3{m_padding3_}, m_padding4{m_padding4_}, m_upWs{m_upWs_}, m_minScale{m_minScale_}, PositionSpring{PositionSpring_}, RotationSpring{RotationSpring_}, ScaleSpring{ScaleSpring_}, PositionPropagationWorkData{PositionPropagationWorkData_}, m_padding5{m_padding5_}, RotationPropagationWorkData{RotationPropagationWorkData_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get static field: static public readonly System.Int32 Stride
      static int _get_Stride();
      // Set static field: static public readonly System.Int32 Stride
      static void _set_Stride(int value);
      // Get instance field reference: public UnityEngine.Vector3 PositionTarget
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_PositionTarget();
      // Get instance field reference: private System.Single m_padding0
      [[deprecated("Use field access instead!")]] float& dyn_m_padding0();
      // Get instance field reference: public UnityEngine.Vector3 PositionOrigin
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_PositionOrigin();
      // Get instance field reference: private System.Single m_padding1
      [[deprecated("Use field access instead!")]] float& dyn_m_padding1();
      // Get instance field reference: public UnityEngine.Vector4 RotationTarget
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_RotationTarget();
      // Get instance field reference: public UnityEngine.Vector4 RotationOrigin
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_RotationOrigin();
      // Get instance field reference: public UnityEngine.Vector3 ScaleTarget
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_ScaleTarget();
      // Get instance field reference: private System.Single m_padding2
      [[deprecated("Use field access instead!")]] float& dyn_m_padding2();
      // Get instance field reference: private System.Int32 m_numEffectors
      [[deprecated("Use field access instead!")]] int& dyn_m_numEffectors();
      // Get instance field reference: private System.Int32 m_instantAccumulation
      [[deprecated("Use field access instead!")]] int& dyn_m_instantAccumulation();
      // Get instance field reference: private System.Int32 m_padding3
      [[deprecated("Use field access instead!")]] int& dyn_m_padding3();
      // Get instance field reference: private System.Int32 m_padding4
      [[deprecated("Use field access instead!")]] int& dyn_m_padding4();
      // Get instance field reference: private UnityEngine.Vector3 m_upWs
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_m_upWs();
      // Get instance field reference: private System.Single m_minScale
      [[deprecated("Use field access instead!")]] float& dyn_m_minScale();
      // Get instance field reference: public BoingKit.Vector3Spring PositionSpring
      [[deprecated("Use field access instead!")]] ::BoingKit::Vector3Spring& dyn_PositionSpring();
      // Get instance field reference: public BoingKit.QuaternionSpring RotationSpring
      [[deprecated("Use field access instead!")]] ::BoingKit::QuaternionSpring& dyn_RotationSpring();
      // Get instance field reference: public BoingKit.Vector3Spring ScaleSpring
      [[deprecated("Use field access instead!")]] ::BoingKit::Vector3Spring& dyn_ScaleSpring();
      // Get instance field reference: public UnityEngine.Vector3 PositionPropagationWorkData
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_PositionPropagationWorkData();
      // Get instance field reference: private System.Single m_padding5
      [[deprecated("Use field access instead!")]] float& dyn_m_padding5();
      // Get instance field reference: public UnityEngine.Vector4 RotationPropagationWorkData
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_RotationPropagationWorkData();
      // public System.Void Reset()
      // Offset: 0x28F88F8
      void Reset();
      // public System.Void Reset(UnityEngine.Vector3 position, System.Boolean instantAccumulation)
      // Offset: 0x28FC448
      void Reset(::UnityEngine::Vector3 position, bool instantAccumulation);
      // public System.Void PrepareExecute(ref BoingKit.BoingWork/Params p, UnityEngine.Vector3 position, UnityEngine.Quaternion rotation, UnityEngine.Vector3 scale, System.Boolean accumulateEffectors)
      // Offset: 0x28FC58C
      void PrepareExecute(ByRef<::BoingKit::BoingWork::Params> p, ::UnityEngine::Vector3 position, ::UnityEngine::Quaternion rotation, ::UnityEngine::Vector3 scale, bool accumulateEffectors);
      // public System.Void PrepareExecute(ref BoingKit.BoingWork/Params p, UnityEngine.Vector3 gridCenter, UnityEngine.Quaternion gridRotation, UnityEngine.Vector3 cellOffset)
      // Offset: 0x28FC828
      void PrepareExecute(ByRef<::BoingKit::BoingWork::Params> p, ::UnityEngine::Vector3 gridCenter, ::UnityEngine::Quaternion gridRotation, ::UnityEngine::Vector3 cellOffset);
      // public System.Void AccumulateTarget(ref BoingKit.BoingWork/Params p, ref BoingKit.BoingEffector/Params effector, System.Single dt)
      // Offset: 0x28F89DC
      void AccumulateTarget(ByRef<::BoingKit::BoingWork::Params> p, ByRef<::BoingKit::BoingEffector::Params> effector, float dt);
      // public System.Void EndAccumulateTargets(ref BoingKit.BoingWork/Params p)
      // Offset: 0x28F9404
      void EndAccumulateTargets(ByRef<::BoingKit::BoingWork::Params> p);
      // public System.Void Execute(ref BoingKit.BoingWork/Params p, System.Single dt)
      // Offset: 0x28F954C
      void Execute(ByRef<::BoingKit::BoingWork::Params> p, float dt);
      // public System.Void PullResults(BoingKit.BoingBones bones)
      // Offset: 0x28FB7E0
      void PullResults(::BoingKit::BoingBones* bones);
      // private System.Void SuppressWarnings()
      // Offset: 0x28FD978
      void SuppressWarnings();
      // static private System.Void .cctor()
      // Offset: 0x28FD990
      static void _cctor();
    }; // BoingKit.BoingWork/Params/InstanceData
    #pragma pack(pop)
    static check_size<sizeof(BoingWork::Params::InstanceData), 224 + sizeof(::UnityEngine::Vector4)> __BoingKit_BoingWork_Params_InstanceDataSizeCheck;
    static_assert(sizeof(BoingWork::Params::InstanceData) == 0xF0);
    public:
    // public System.Int32 InstanceID
    // Size: 0x4
    // Offset: 0x0
    int InstanceID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public BoingKit.Bits32 Bits
    // Size: 0x4
    // Offset: 0x4
    ::BoingKit::Bits32 Bits;
    // Field size check
    static_assert(sizeof(::BoingKit::Bits32) == 0x4);
    // public BoingKit.TwoDPlaneEnum TwoDPlane
    // Size: 0x4
    // Offset: 0x8
    ::BoingKit::TwoDPlaneEnum TwoDPlane;
    // Field size check
    static_assert(sizeof(::BoingKit::TwoDPlaneEnum) == 0x4);
    // private System.Int32 m_padding0
    // Size: 0x4
    // Offset: 0xC
    int m_padding0;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public BoingKit.ParameterMode PositionParameterMode
    // Size: 0x4
    // Offset: 0x10
    ::BoingKit::ParameterMode PositionParameterMode;
    // Field size check
    static_assert(sizeof(::BoingKit::ParameterMode) == 0x4);
    // public BoingKit.ParameterMode RotationParameterMode
    // Size: 0x4
    // Offset: 0x14
    ::BoingKit::ParameterMode RotationParameterMode;
    // Field size check
    static_assert(sizeof(::BoingKit::ParameterMode) == 0x4);
    // public BoingKit.ParameterMode ScaleParameterMode
    // Size: 0x4
    // Offset: 0x18
    ::BoingKit::ParameterMode ScaleParameterMode;
    // Field size check
    static_assert(sizeof(::BoingKit::ParameterMode) == 0x4);
    // private System.Int32 m_padding1
    // Size: 0x4
    // Offset: 0x1C
    int m_padding1;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Single PositionExponentialHalfLife
    // Size: 0x4
    // Offset: 0x20
    float PositionExponentialHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single PositionOscillationHalfLife
    // Size: 0x4
    // Offset: 0x24
    float PositionOscillationHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single PositionOscillationFrequency
    // Size: 0x4
    // Offset: 0x28
    float PositionOscillationFrequency;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single PositionOscillationDampingRatio
    // Size: 0x4
    // Offset: 0x2C
    float PositionOscillationDampingRatio;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single MoveReactionMultiplier
    // Size: 0x4
    // Offset: 0x30
    float MoveReactionMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single LinearImpulseMultiplier
    // Size: 0x4
    // Offset: 0x34
    float LinearImpulseMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single RotationExponentialHalfLife
    // Size: 0x4
    // Offset: 0x38
    float RotationExponentialHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single RotationOscillationHalfLife
    // Size: 0x4
    // Offset: 0x3C
    float RotationOscillationHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single RotationOscillationFrequency
    // Size: 0x4
    // Offset: 0x40
    float RotationOscillationFrequency;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single RotationOscillationDampingRatio
    // Size: 0x4
    // Offset: 0x44
    float RotationOscillationDampingRatio;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single RotationReactionMultiplier
    // Size: 0x4
    // Offset: 0x48
    float RotationReactionMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single AngularImpulseMultiplier
    // Size: 0x4
    // Offset: 0x4C
    float AngularImpulseMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single ScaleExponentialHalfLife
    // Size: 0x4
    // Offset: 0x50
    float ScaleExponentialHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single ScaleOscillationHalfLife
    // Size: 0x4
    // Offset: 0x54
    float ScaleOscillationHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single ScaleOscillationFrequency
    // Size: 0x4
    // Offset: 0x58
    float ScaleOscillationFrequency;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single ScaleOscillationDampingRatio
    // Size: 0x4
    // Offset: 0x5C
    float ScaleOscillationDampingRatio;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Vector3 RotationReactionUp
    // Size: 0xC
    // Offset: 0x60
    ::UnityEngine::Vector3 RotationReactionUp;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single m_padding2
    // Size: 0x4
    // Offset: 0x6C
    float m_padding2;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public BoingKit.BoingWork/Params/InstanceData Instance
    // Size: 0xF0
    // Offset: 0x70
    ::BoingKit::BoingWork::Params::InstanceData Instance;
    // Field size check
    static_assert(sizeof(::BoingKit::BoingWork::Params::InstanceData) == 0xF0);
    public:
    // Creating value type constructor for type: Params
    constexpr Params(int InstanceID_ = {}, ::BoingKit::Bits32 Bits_ = {}, ::BoingKit::TwoDPlaneEnum TwoDPlane_ = {}, int m_padding0_ = {}, ::BoingKit::ParameterMode PositionParameterMode_ = {}, ::BoingKit::ParameterMode RotationParameterMode_ = {}, ::BoingKit::ParameterMode ScaleParameterMode_ = {}, int m_padding1_ = {}, float PositionExponentialHalfLife_ = {}, float PositionOscillationHalfLife_ = {}, float PositionOscillationFrequency_ = {}, float PositionOscillationDampingRatio_ = {}, float MoveReactionMultiplier_ = {}, float LinearImpulseMultiplier_ = {}, float RotationExponentialHalfLife_ = {}, float RotationOscillationHalfLife_ = {}, float RotationOscillationFrequency_ = {}, float RotationOscillationDampingRatio_ = {}, float RotationReactionMultiplier_ = {}, float AngularImpulseMultiplier_ = {}, float ScaleExponentialHalfLife_ = {}, float ScaleOscillationHalfLife_ = {}, float ScaleOscillationFrequency_ = {}, float ScaleOscillationDampingRatio_ = {}, ::UnityEngine::Vector3 RotationReactionUp_ = {}, float m_padding2_ = {}, ::BoingKit::BoingWork::Params::InstanceData Instance_ = {}) noexcept : InstanceID{InstanceID_}, Bits{Bits_}, TwoDPlane{TwoDPlane_}, m_padding0{m_padding0_}, PositionParameterMode{PositionParameterMode_}, RotationParameterMode{RotationParameterMode_}, ScaleParameterMode{ScaleParameterMode_}, m_padding1{m_padding1_}, PositionExponentialHalfLife{PositionExponentialHalfLife_}, PositionOscillationHalfLife{PositionOscillationHalfLife_}, PositionOscillationFrequency{PositionOscillationFrequency_}, PositionOscillationDampingRatio{PositionOscillationDampingRatio_}, MoveReactionMultiplier{MoveReactionMultiplier_}, LinearImpulseMultiplier{LinearImpulseMultiplier_}, RotationExponentialHalfLife{RotationExponentialHalfLife_}, RotationOscillationHalfLife{RotationOscillationHalfLife_}, RotationOscillationFrequency{RotationOscillationFrequency_}, RotationOscillationDampingRatio{RotationOscillationDampingRatio_}, RotationReactionMultiplier{RotationReactionMultiplier_}, AngularImpulseMultiplier{AngularImpulseMultiplier_}, ScaleExponentialHalfLife{ScaleExponentialHalfLife_}, ScaleOscillationHalfLife{ScaleOscillationHalfLife_}, ScaleOscillationFrequency{ScaleOscillationFrequency_}, ScaleOscillationDampingRatio{ScaleOscillationDampingRatio_}, RotationReactionUp{RotationReactionUp_}, m_padding2{m_padding2_}, Instance{Instance_} {}
    // Creating interface conversion operator: operator ::System::ValueType
    operator ::System::ValueType() noexcept {
      return *reinterpret_cast<::System::ValueType*>(this);
    }
    // Get static field: static public readonly System.Int32 Stride
    static int _get_Stride();
    // Set static field: static public readonly System.Int32 Stride
    static void _set_Stride(int value);
    // Get instance field reference: public System.Int32 InstanceID
    [[deprecated("Use field access instead!")]] int& dyn_InstanceID();
    // Get instance field reference: public BoingKit.Bits32 Bits
    [[deprecated("Use field access instead!")]] ::BoingKit::Bits32& dyn_Bits();
    // Get instance field reference: public BoingKit.TwoDPlaneEnum TwoDPlane
    [[deprecated("Use field access instead!")]] ::BoingKit::TwoDPlaneEnum& dyn_TwoDPlane();
    // Get instance field reference: private System.Int32 m_padding0
    [[deprecated("Use field access instead!")]] int& dyn_m_padding0();
    // Get instance field reference: public BoingKit.ParameterMode PositionParameterMode
    [[deprecated("Use field access instead!")]] ::BoingKit::ParameterMode& dyn_PositionParameterMode();
    // Get instance field reference: public BoingKit.ParameterMode RotationParameterMode
    [[deprecated("Use field access instead!")]] ::BoingKit::ParameterMode& dyn_RotationParameterMode();
    // Get instance field reference: public BoingKit.ParameterMode ScaleParameterMode
    [[deprecated("Use field access instead!")]] ::BoingKit::ParameterMode& dyn_ScaleParameterMode();
    // Get instance field reference: private System.Int32 m_padding1
    [[deprecated("Use field access instead!")]] int& dyn_m_padding1();
    // Get instance field reference: public System.Single PositionExponentialHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_PositionExponentialHalfLife();
    // Get instance field reference: public System.Single PositionOscillationHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_PositionOscillationHalfLife();
    // Get instance field reference: public System.Single PositionOscillationFrequency
    [[deprecated("Use field access instead!")]] float& dyn_PositionOscillationFrequency();
    // Get instance field reference: public System.Single PositionOscillationDampingRatio
    [[deprecated("Use field access instead!")]] float& dyn_PositionOscillationDampingRatio();
    // Get instance field reference: public System.Single MoveReactionMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_MoveReactionMultiplier();
    // Get instance field reference: public System.Single LinearImpulseMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_LinearImpulseMultiplier();
    // Get instance field reference: public System.Single RotationExponentialHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_RotationExponentialHalfLife();
    // Get instance field reference: public System.Single RotationOscillationHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_RotationOscillationHalfLife();
    // Get instance field reference: public System.Single RotationOscillationFrequency
    [[deprecated("Use field access instead!")]] float& dyn_RotationOscillationFrequency();
    // Get instance field reference: public System.Single RotationOscillationDampingRatio
    [[deprecated("Use field access instead!")]] float& dyn_RotationOscillationDampingRatio();
    // Get instance field reference: public System.Single RotationReactionMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_RotationReactionMultiplier();
    // Get instance field reference: public System.Single AngularImpulseMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_AngularImpulseMultiplier();
    // Get instance field reference: public System.Single ScaleExponentialHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_ScaleExponentialHalfLife();
    // Get instance field reference: public System.Single ScaleOscillationHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_ScaleOscillationHalfLife();
    // Get instance field reference: public System.Single ScaleOscillationFrequency
    [[deprecated("Use field access instead!")]] float& dyn_ScaleOscillationFrequency();
    // Get instance field reference: public System.Single ScaleOscillationDampingRatio
    [[deprecated("Use field access instead!")]] float& dyn_ScaleOscillationDampingRatio();
    // Get instance field reference: public UnityEngine.Vector3 RotationReactionUp
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_RotationReactionUp();
    // Get instance field reference: private System.Single m_padding2
    [[deprecated("Use field access instead!")]] float& dyn_m_padding2();
    // Get instance field reference: public BoingKit.BoingWork/Params/InstanceData Instance
    [[deprecated("Use field access instead!")]] ::BoingKit::BoingWork::Params::InstanceData& dyn_Instance();
    // static public System.Void Copy(ref BoingKit.BoingWork/Params from, ref BoingKit.BoingWork/Params to)
    // Offset: 0x28F887C
    static void Copy(ByRef<::BoingKit::BoingWork::Params> from, ByRef<::BoingKit::BoingWork::Params> to);
    // public System.Void Init()
    // Offset: 0x28F88A8
    void Init();
    // public System.Void AccumulateTarget(ref BoingKit.BoingEffector/Params effector, System.Single dt)
    // Offset: 0x28F89C8
    void AccumulateTarget(ByRef<::BoingKit::BoingEffector::Params> effector, float dt);
    // public System.Void EndAccumulateTargets()
    // Offset: 0x28F93FC
    void EndAccumulateTargets();
    // public System.Void Execute(System.Single dt)
    // Offset: 0x28F9540
    void Execute(float dt);
    // public System.Void Execute(BoingKit.BoingBones bones, System.Single dt)
    // Offset: 0x28F9B28
    void Execute(::BoingKit::BoingBones* bones, float dt);
    // public System.Void PullResults(BoingKit.BoingBones bones)
    // Offset: 0x28FB7DC
    void PullResults(::BoingKit::BoingBones* bones);
    // private System.Void SuppressWarnings()
    // Offset: 0x28FC2B0
    void SuppressWarnings();
    // static private System.Void .cctor()
    // Offset: 0x28FC2C0
    static void _cctor();
  }; // BoingKit.BoingWork/Params
  #pragma pack(pop)
  static check_size<sizeof(BoingWork::Params), 112 + sizeof(::BoingKit::BoingWork::Params::InstanceData)> __BoingKit_BoingWork_ParamsSizeCheck;
  static_assert(sizeof(BoingWork::Params) == 0x160);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::BoingKit::BoingWork::Params::InstanceData, "BoingKit", "BoingWork/Params/InstanceData");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::Copy
// Il2CppName: Copy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(ByRef<::BoingKit::BoingWork::Params>, ByRef<::BoingKit::BoingWork::Params>)>(&BoingKit::BoingWork::Params::Copy)> {
  static const MethodInfo* get() {
    static auto* from = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params")->this_arg;
    static auto* to = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingWork/Params")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "Copy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{from, to});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::Init
// Il2CppName: Init
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingWork::Params::*)()>(&BoingKit::BoingWork::Params::Init)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "Init", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::AccumulateTarget
// Il2CppName: AccumulateTarget
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingWork::Params::*)(ByRef<::BoingKit::BoingEffector::Params>, float)>(&BoingKit::BoingWork::Params::AccumulateTarget)> {
  static const MethodInfo* get() {
    static auto* effector = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingEffector/Params")->this_arg;
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "AccumulateTarget", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{effector, dt});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::EndAccumulateTargets
// Il2CppName: EndAccumulateTargets
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingWork::Params::*)()>(&BoingKit::BoingWork::Params::EndAccumulateTargets)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "EndAccumulateTargets", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::Execute
// Il2CppName: Execute
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingWork::Params::*)(float)>(&BoingKit::BoingWork::Params::Execute)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "Execute", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::Execute
// Il2CppName: Execute
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingWork::Params::*)(::BoingKit::BoingBones*, float)>(&BoingKit::BoingWork::Params::Execute)> {
  static const MethodInfo* get() {
    static auto* bones = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingBones")->byval_arg;
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "Execute", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bones, dt});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::PullResults
// Il2CppName: PullResults
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingWork::Params::*)(::BoingKit::BoingBones*)>(&BoingKit::BoingWork::Params::PullResults)> {
  static const MethodInfo* get() {
    static auto* bones = &::il2cpp_utils::GetClassFromName("BoingKit", "BoingBones")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "PullResults", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bones});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::SuppressWarnings
// Il2CppName: SuppressWarnings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (BoingKit::BoingWork::Params::*)()>(&BoingKit::BoingWork::Params::SuppressWarnings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), "SuppressWarnings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: BoingKit::BoingWork::Params::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&BoingKit::BoingWork::Params::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(BoingKit::BoingWork::Params), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
