// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Including type: UnityEngine.Vector3
#include "UnityEngine/Vector3.hpp"
// Including type: UnityEngine.PhysicsScene
#include "UnityEngine/PhysicsScene.hpp"
// Including type: UnityEngine.QueryParameters
#include "UnityEngine/QueryParameters.hpp"
// Including type: UnityEngine.ColliderHit
#include "UnityEngine/ColliderHit.hpp"
// Including type: Unity.Jobs.LowLevel.Unsafe.JobsUtility
#include "Unity/Jobs/LowLevel/Unsafe/JobsUtility.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Unity::Jobs
namespace Unity::Jobs {
  // Forward declaring type: JobHandle
  struct JobHandle;
}
// Forward declaring namespace: Unity::Collections
namespace Unity::Collections {
  // Forward declaring type: NativeArray`1<T>
  template<typename T>
  struct NativeArray_1;
}
// Completed forward declares
// Type namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: OverlapSphereCommand
  struct OverlapSphereCommand;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::OverlapSphereCommand, "UnityEngine", "OverlapSphereCommand");
// Type namespace: UnityEngine
namespace UnityEngine {
  // Size: 0x21
  #pragma pack(push, 1)
  // WARNING Layout: Sequential may not be correctly taken into account!
  // Autogenerated type: UnityEngine.OverlapSphereCommand
  // [TokenAttribute] Offset: FFFFFFFF
  // [NativeHeaderAttribute] Offset: FFFFFFFF
  struct OverlapSphereCommand/*, public ::System::ValueType*/ {
    public:
    public:
    // private UnityEngine.Vector3 <point>k__BackingField
    // Size: 0xC
    // Offset: 0x0
    ::UnityEngine::Vector3 point;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single <radius>k__BackingField
    // Size: 0x4
    // Offset: 0xC
    float radius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.PhysicsScene <physicsScene>k__BackingField
    // Size: 0x4
    // Offset: 0x10
    ::UnityEngine::PhysicsScene physicsScene;
    // Field size check
    static_assert(sizeof(::UnityEngine::PhysicsScene) == 0x4);
    // public UnityEngine.QueryParameters queryParameters
    // Size: 0xD
    // Offset: 0x14
    ::UnityEngine::QueryParameters queryParameters;
    // Field size check
    static_assert(sizeof(::UnityEngine::QueryParameters) == 0xD);
    public:
    // Creating value type constructor for type: OverlapSphereCommand
    constexpr OverlapSphereCommand(::UnityEngine::Vector3 point_ = {}, float radius_ = {}, ::UnityEngine::PhysicsScene physicsScene_ = {}, ::UnityEngine::QueryParameters queryParameters_ = {}) noexcept : point{point_}, radius{radius_}, physicsScene{physicsScene_}, queryParameters{queryParameters_} {}
    // Creating interface conversion operator: operator ::System::ValueType
    operator ::System::ValueType() noexcept {
      return *reinterpret_cast<::System::ValueType*>(this);
    }
    // Get instance field reference: private UnityEngine.Vector3 <point>k__BackingField
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_$point$k__BackingField();
    // Get instance field reference: private System.Single <radius>k__BackingField
    [[deprecated("Use field access instead!")]] float& dyn_$radius$k__BackingField();
    // Get instance field reference: private UnityEngine.PhysicsScene <physicsScene>k__BackingField
    [[deprecated("Use field access instead!")]] ::UnityEngine::PhysicsScene& dyn_$physicsScene$k__BackingField();
    // Get instance field reference: public UnityEngine.QueryParameters queryParameters
    [[deprecated("Use field access instead!")]] ::UnityEngine::QueryParameters& dyn_queryParameters();
    // public System.Void .ctor(UnityEngine.Vector3 point, System.Single radius, UnityEngine.QueryParameters queryParameters)
    // Offset: 0x5535F3C
    OverlapSphereCommand(::UnityEngine::Vector3 point, float radius, ::UnityEngine::QueryParameters queryParameters);
    // public System.Void set_point(UnityEngine.Vector3 value)
    // Offset: 0x5535FD4
    void set_point(::UnityEngine::Vector3 value);
    // public System.Void set_radius(System.Single value)
    // Offset: 0x5535FE0
    void set_radius(float value);
    // public System.Void set_physicsScene(UnityEngine.PhysicsScene value)
    // Offset: 0x5535FE8
    void set_physicsScene(::UnityEngine::PhysicsScene value);
    // static public Unity.Jobs.JobHandle ScheduleBatch(Unity.Collections.NativeArray`1<UnityEngine.OverlapSphereCommand> commands, Unity.Collections.NativeArray`1<UnityEngine.ColliderHit> results, System.Int32 minCommandsPerJob, System.Int32 maxHits, Unity.Jobs.JobHandle dependsOn)
    // Offset: 0x5535FF0
    static ::Unity::Jobs::JobHandle ScheduleBatch(::Unity::Collections::NativeArray_1<::UnityEngine::OverlapSphereCommand> commands, ::Unity::Collections::NativeArray_1<::UnityEngine::ColliderHit> results, int minCommandsPerJob, int maxHits, ::Unity::Jobs::JobHandle dependsOn);
    // static private Unity.Jobs.JobHandle ScheduleOverlapSphereBatch(ref Unity.Jobs.LowLevel.Unsafe.JobsUtility/JobScheduleParameters parameters, System.Void* commands, System.Int32 commandLen, System.Void* result, System.Int32 resultLen, System.Int32 minCommandsPerJob, System.Int32 maxHits)
    // Offset: 0x55361D4
    static ::Unity::Jobs::JobHandle ScheduleOverlapSphereBatch(ByRef<::Unity::Jobs::LowLevel::Unsafe::JobsUtility::JobScheduleParameters> parameters, void* commands, int commandLen, void* result, int resultLen, int minCommandsPerJob, int maxHits);
    // static private System.Void ScheduleOverlapSphereBatch_Injected(ref Unity.Jobs.LowLevel.Unsafe.JobsUtility/JobScheduleParameters parameters, System.Void* commands, System.Int32 commandLen, System.Void* result, System.Int32 resultLen, System.Int32 minCommandsPerJob, System.Int32 maxHits, out Unity.Jobs.JobHandle ret)
    // Offset: 0x5536270
    static void ScheduleOverlapSphereBatch_Injected(ByRef<::Unity::Jobs::LowLevel::Unsafe::JobsUtility::JobScheduleParameters> parameters, void* commands, int commandLen, void* result, int resultLen, int minCommandsPerJob, int maxHits, ByRef<::Unity::Jobs::JobHandle> ret);
  }; // UnityEngine.OverlapSphereCommand
  #pragma pack(pop)
  static check_size<sizeof(OverlapSphereCommand), 20 + sizeof(::UnityEngine::QueryParameters)> __UnityEngine_OverlapSphereCommandSizeCheck;
  static_assert(sizeof(OverlapSphereCommand) == 0x21);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: UnityEngine::OverlapSphereCommand::OverlapSphereCommand
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: UnityEngine::OverlapSphereCommand::set_point
// Il2CppName: set_point
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::OverlapSphereCommand::*)(::UnityEngine::Vector3)>(&UnityEngine::OverlapSphereCommand::set_point)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::OverlapSphereCommand), "set_point", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::OverlapSphereCommand::set_radius
// Il2CppName: set_radius
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::OverlapSphereCommand::*)(float)>(&UnityEngine::OverlapSphereCommand::set_radius)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::OverlapSphereCommand), "set_radius", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::OverlapSphereCommand::set_physicsScene
// Il2CppName: set_physicsScene
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::OverlapSphereCommand::*)(::UnityEngine::PhysicsScene)>(&UnityEngine::OverlapSphereCommand::set_physicsScene)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "PhysicsScene")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::OverlapSphereCommand), "set_physicsScene", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::OverlapSphereCommand::ScheduleBatch
// Il2CppName: ScheduleBatch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Unity::Jobs::JobHandle (*)(::Unity::Collections::NativeArray_1<::UnityEngine::OverlapSphereCommand>, ::Unity::Collections::NativeArray_1<::UnityEngine::ColliderHit>, int, int, ::Unity::Jobs::JobHandle)>(&UnityEngine::OverlapSphereCommand::ScheduleBatch)> {
  static const MethodInfo* get() {
    static auto* commands = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeArray`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "OverlapSphereCommand")})->byval_arg;
    static auto* results = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeArray`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "ColliderHit")})->byval_arg;
    static auto* minCommandsPerJob = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* maxHits = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* dependsOn = &::il2cpp_utils::GetClassFromName("Unity.Jobs", "JobHandle")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::OverlapSphereCommand), "ScheduleBatch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{commands, results, minCommandsPerJob, maxHits, dependsOn});
  }
};
// Writing MetadataGetter for method: UnityEngine::OverlapSphereCommand::ScheduleOverlapSphereBatch
// Il2CppName: ScheduleOverlapSphereBatch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Unity::Jobs::JobHandle (*)(ByRef<::Unity::Jobs::LowLevel::Unsafe::JobsUtility::JobScheduleParameters>, void*, int, void*, int, int, int)>(&UnityEngine::OverlapSphereCommand::ScheduleOverlapSphereBatch)> {
  static const MethodInfo* get() {
    static auto* parameters = &::il2cpp_utils::GetClassFromName("Unity.Jobs.LowLevel.Unsafe", "JobsUtility/JobScheduleParameters")->this_arg;
    static auto* commands = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* commandLen = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* result = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* resultLen = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* minCommandsPerJob = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* maxHits = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::OverlapSphereCommand), "ScheduleOverlapSphereBatch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{parameters, commands, commandLen, result, resultLen, minCommandsPerJob, maxHits});
  }
};
// Writing MetadataGetter for method: UnityEngine::OverlapSphereCommand::ScheduleOverlapSphereBatch_Injected
// Il2CppName: ScheduleOverlapSphereBatch_Injected
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(ByRef<::Unity::Jobs::LowLevel::Unsafe::JobsUtility::JobScheduleParameters>, void*, int, void*, int, int, int, ByRef<::Unity::Jobs::JobHandle>)>(&UnityEngine::OverlapSphereCommand::ScheduleOverlapSphereBatch_Injected)> {
  static const MethodInfo* get() {
    static auto* parameters = &::il2cpp_utils::GetClassFromName("Unity.Jobs.LowLevel.Unsafe", "JobsUtility/JobScheduleParameters")->this_arg;
    static auto* commands = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* commandLen = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* result = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* resultLen = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* minCommandsPerJob = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* maxHits = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* ret = &::il2cpp_utils::GetClassFromName("Unity.Jobs", "JobHandle")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::OverlapSphereCommand), "ScheduleOverlapSphereBatch_Injected", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{parameters, commands, commandLen, result, resultLen, minCommandsPerJob, maxHits, ret});
  }
};
