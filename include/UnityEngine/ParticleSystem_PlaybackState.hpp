// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.ParticleSystem
#include "UnityEngine/ParticleSystem.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Skipping declaration: Seed because it is already included!
  // Skipping declaration: Seed4 because it is already included!
}
// Completed forward declares
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState, "UnityEngine", "ParticleSystem/PlaybackState");
// Type namespace: UnityEngine
namespace UnityEngine {
  // Size: 0x160
  #pragma pack(push, 1)
  // WARNING Layout: Sequential may not be correctly taken into account!
  // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState
  // [TokenAttribute] Offset: FFFFFFFF
  struct ParticleSystem::PlaybackState/*, public ::System::ValueType*/ {
    public:
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Seed
    struct Seed;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Seed4
    struct Seed4;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Emission
    struct Emission;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Initial
    struct Initial;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Shape
    struct Shape;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Force
    struct Force;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Collision
    struct Collision;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Noise
    struct Noise;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Lights
    struct Lights;
    // Nested type: ::UnityEngine::ParticleSystem::PlaybackState::Trail
    struct Trail;
    // Size: 0x10
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Seed
    // [TokenAttribute] Offset: FFFFFFFF
    struct Seed/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.UInt32 x
      // Size: 0x4
      // Offset: 0x0
      uint x;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 y
      // Size: 0x4
      // Offset: 0x4
      uint y;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 z
      // Size: 0x4
      // Offset: 0x8
      uint z;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 w
      // Size: 0x4
      // Offset: 0xC
      uint w;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      public:
      // Creating value type constructor for type: Seed
      constexpr Seed(uint x_ = {}, uint y_ = {}, uint z_ = {}, uint w_ = {}) noexcept : x{x_}, y{y_}, z{z_}, w{w_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.UInt32 x
      [[deprecated("Use field access instead!")]] uint& dyn_x();
      // Get instance field reference: public System.UInt32 y
      [[deprecated("Use field access instead!")]] uint& dyn_y();
      // Get instance field reference: public System.UInt32 z
      [[deprecated("Use field access instead!")]] uint& dyn_z();
      // Get instance field reference: public System.UInt32 w
      [[deprecated("Use field access instead!")]] uint& dyn_w();
    }; // UnityEngine.ParticleSystem/PlaybackState/Seed
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Seed), 12 + sizeof(uint)> __UnityEngine_ParticleSystem_PlaybackState_SeedSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Seed) == 0x10);
    // Size: 0x40
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Seed4
    // [TokenAttribute] Offset: FFFFFFFF
    struct Seed4/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.ParticleSystem/PlaybackState/Seed x
      // Size: 0x10
      // Offset: 0x0
      ::UnityEngine::ParticleSystem::PlaybackState::Seed x;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed) == 0x10);
      // public UnityEngine.ParticleSystem/PlaybackState/Seed y
      // Size: 0x10
      // Offset: 0x10
      ::UnityEngine::ParticleSystem::PlaybackState::Seed y;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed) == 0x10);
      // public UnityEngine.ParticleSystem/PlaybackState/Seed z
      // Size: 0x10
      // Offset: 0x20
      ::UnityEngine::ParticleSystem::PlaybackState::Seed z;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed) == 0x10);
      // public UnityEngine.ParticleSystem/PlaybackState/Seed w
      // Size: 0x10
      // Offset: 0x30
      ::UnityEngine::ParticleSystem::PlaybackState::Seed w;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed) == 0x10);
      public:
      // Creating value type constructor for type: Seed4
      constexpr Seed4(::UnityEngine::ParticleSystem::PlaybackState::Seed x_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Seed y_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Seed z_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Seed w_ = {}) noexcept : x{x_}, y{y_}, z{z_}, w{w_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed x
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed& dyn_x();
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed y
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed& dyn_y();
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed z
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed& dyn_z();
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed w
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed& dyn_w();
    }; // UnityEngine.ParticleSystem/PlaybackState/Seed4
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Seed4), 48 + sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed)> __UnityEngine_ParticleSystem_PlaybackState_Seed4SizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Seed4) == 0x40);
    // Size: 0x18
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Emission
    // [TokenAttribute] Offset: FFFFFFFF
    struct Emission/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Single m_ParticleSpacing
      // Size: 0x4
      // Offset: 0x0
      float m_ParticleSpacing;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single m_ToEmitAccumulator
      // Size: 0x4
      // Offset: 0x4
      float m_ToEmitAccumulator;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public UnityEngine.ParticleSystem/PlaybackState/Seed m_Random
      // Size: 0x10
      // Offset: 0x8
      ::UnityEngine::ParticleSystem::PlaybackState::Seed m_Random;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed) == 0x10);
      public:
      // Creating value type constructor for type: Emission
      constexpr Emission(float m_ParticleSpacing_ = {}, float m_ToEmitAccumulator_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Seed m_Random_ = {}) noexcept : m_ParticleSpacing{m_ParticleSpacing_}, m_ToEmitAccumulator{m_ToEmitAccumulator_}, m_Random{m_Random_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Single m_ParticleSpacing
      [[deprecated("Use field access instead!")]] float& dyn_m_ParticleSpacing();
      // Get instance field reference: public System.Single m_ToEmitAccumulator
      [[deprecated("Use field access instead!")]] float& dyn_m_ToEmitAccumulator();
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed m_Random
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed& dyn_m_Random();
    }; // UnityEngine.ParticleSystem/PlaybackState/Emission
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Emission), 8 + sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed)> __UnityEngine_ParticleSystem_PlaybackState_EmissionSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Emission) == 0x18);
    // Size: 0x40
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Initial
    // [TokenAttribute] Offset: FFFFFFFF
    struct Initial/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      // Size: 0x40
      // Offset: 0x0
      ::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed4) == 0x40);
      public:
      // Creating value type constructor for type: Initial
      constexpr Initial(::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random_ = {}) noexcept : m_Random{m_Random_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating conversion operator: operator ::UnityEngine::ParticleSystem::PlaybackState::Seed4
      constexpr operator ::UnityEngine::ParticleSystem::PlaybackState::Seed4() const noexcept {
        return m_Random;
      }
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed4& dyn_m_Random();
    }; // UnityEngine.ParticleSystem/PlaybackState/Initial
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Initial), 0 + sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed4)> __UnityEngine_ParticleSystem_PlaybackState_InitialSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Initial) == 0x40);
    // Size: 0x5C
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Shape
    // [TokenAttribute] Offset: FFFFFFFF
    struct Shape/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      // Size: 0x40
      // Offset: 0x0
      ::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed4) == 0x40);
      // public System.Single m_RadiusTimer
      // Size: 0x4
      // Offset: 0x40
      float m_RadiusTimer;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single m_RadiusTimerPrev
      // Size: 0x4
      // Offset: 0x44
      float m_RadiusTimerPrev;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single m_ArcTimer
      // Size: 0x4
      // Offset: 0x48
      float m_ArcTimer;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single m_ArcTimerPrev
      // Size: 0x4
      // Offset: 0x4C
      float m_ArcTimerPrev;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single m_MeshSpawnTimer
      // Size: 0x4
      // Offset: 0x50
      float m_MeshSpawnTimer;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single m_MeshSpawnTimerPrev
      // Size: 0x4
      // Offset: 0x54
      float m_MeshSpawnTimerPrev;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Int32 m_OrderedMeshVertexIndex
      // Size: 0x4
      // Offset: 0x58
      int m_OrderedMeshVertexIndex;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: Shape
      constexpr Shape(::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random_ = {}, float m_RadiusTimer_ = {}, float m_RadiusTimerPrev_ = {}, float m_ArcTimer_ = {}, float m_ArcTimerPrev_ = {}, float m_MeshSpawnTimer_ = {}, float m_MeshSpawnTimerPrev_ = {}, int m_OrderedMeshVertexIndex_ = {}) noexcept : m_Random{m_Random_}, m_RadiusTimer{m_RadiusTimer_}, m_RadiusTimerPrev{m_RadiusTimerPrev_}, m_ArcTimer{m_ArcTimer_}, m_ArcTimerPrev{m_ArcTimerPrev_}, m_MeshSpawnTimer{m_MeshSpawnTimer_}, m_MeshSpawnTimerPrev{m_MeshSpawnTimerPrev_}, m_OrderedMeshVertexIndex{m_OrderedMeshVertexIndex_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed4& dyn_m_Random();
      // Get instance field reference: public System.Single m_RadiusTimer
      [[deprecated("Use field access instead!")]] float& dyn_m_RadiusTimer();
      // Get instance field reference: public System.Single m_RadiusTimerPrev
      [[deprecated("Use field access instead!")]] float& dyn_m_RadiusTimerPrev();
      // Get instance field reference: public System.Single m_ArcTimer
      [[deprecated("Use field access instead!")]] float& dyn_m_ArcTimer();
      // Get instance field reference: public System.Single m_ArcTimerPrev
      [[deprecated("Use field access instead!")]] float& dyn_m_ArcTimerPrev();
      // Get instance field reference: public System.Single m_MeshSpawnTimer
      [[deprecated("Use field access instead!")]] float& dyn_m_MeshSpawnTimer();
      // Get instance field reference: public System.Single m_MeshSpawnTimerPrev
      [[deprecated("Use field access instead!")]] float& dyn_m_MeshSpawnTimerPrev();
      // Get instance field reference: public System.Int32 m_OrderedMeshVertexIndex
      [[deprecated("Use field access instead!")]] int& dyn_m_OrderedMeshVertexIndex();
    }; // UnityEngine.ParticleSystem/PlaybackState/Shape
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Shape), 88 + sizeof(int)> __UnityEngine_ParticleSystem_PlaybackState_ShapeSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Shape) == 0x5C);
    // Size: 0x40
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Force
    // [TokenAttribute] Offset: FFFFFFFF
    struct Force/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      // Size: 0x40
      // Offset: 0x0
      ::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed4) == 0x40);
      public:
      // Creating value type constructor for type: Force
      constexpr Force(::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random_ = {}) noexcept : m_Random{m_Random_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating conversion operator: operator ::UnityEngine::ParticleSystem::PlaybackState::Seed4
      constexpr operator ::UnityEngine::ParticleSystem::PlaybackState::Seed4() const noexcept {
        return m_Random;
      }
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed4& dyn_m_Random();
    }; // UnityEngine.ParticleSystem/PlaybackState/Force
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Force), 0 + sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed4)> __UnityEngine_ParticleSystem_PlaybackState_ForceSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Force) == 0x40);
    // Size: 0x40
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Collision
    // [TokenAttribute] Offset: FFFFFFFF
    struct Collision/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      // Size: 0x40
      // Offset: 0x0
      ::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed4) == 0x40);
      public:
      // Creating value type constructor for type: Collision
      constexpr Collision(::UnityEngine::ParticleSystem::PlaybackState::Seed4 m_Random_ = {}) noexcept : m_Random{m_Random_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating conversion operator: operator ::UnityEngine::ParticleSystem::PlaybackState::Seed4
      constexpr operator ::UnityEngine::ParticleSystem::PlaybackState::Seed4() const noexcept {
        return m_Random;
      }
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed4 m_Random
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed4& dyn_m_Random();
    }; // UnityEngine.ParticleSystem/PlaybackState/Collision
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Collision), 0 + sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed4)> __UnityEngine_ParticleSystem_PlaybackState_CollisionSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Collision) == 0x40);
    // Size: 0x4
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Noise
    // [TokenAttribute] Offset: FFFFFFFF
    struct Noise/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Single m_ScrollOffset
      // Size: 0x4
      // Offset: 0x0
      float m_ScrollOffset;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      public:
      // Creating value type constructor for type: Noise
      constexpr Noise(float m_ScrollOffset_ = {}) noexcept : m_ScrollOffset{m_ScrollOffset_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating conversion operator: operator float
      constexpr operator float() const noexcept {
        return m_ScrollOffset;
      }
      // Get instance field reference: public System.Single m_ScrollOffset
      [[deprecated("Use field access instead!")]] float& dyn_m_ScrollOffset();
    }; // UnityEngine.ParticleSystem/PlaybackState/Noise
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Noise), 0 + sizeof(float)> __UnityEngine_ParticleSystem_PlaybackState_NoiseSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Noise) == 0x4);
    // Size: 0x14
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Lights
    // [TokenAttribute] Offset: FFFFFFFF
    struct Lights/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.ParticleSystem/PlaybackState/Seed m_Random
      // Size: 0x10
      // Offset: 0x0
      ::UnityEngine::ParticleSystem::PlaybackState::Seed m_Random;
      // Field size check
      static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Seed) == 0x10);
      // public System.Single m_ParticleEmissionCounter
      // Size: 0x4
      // Offset: 0x10
      float m_ParticleEmissionCounter;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      public:
      // Creating value type constructor for type: Lights
      constexpr Lights(::UnityEngine::ParticleSystem::PlaybackState::Seed m_Random_ = {}, float m_ParticleEmissionCounter_ = {}) noexcept : m_Random{m_Random_}, m_ParticleEmissionCounter{m_ParticleEmissionCounter_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.ParticleSystem/PlaybackState/Seed m_Random
      [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Seed& dyn_m_Random();
      // Get instance field reference: public System.Single m_ParticleEmissionCounter
      [[deprecated("Use field access instead!")]] float& dyn_m_ParticleEmissionCounter();
    }; // UnityEngine.ParticleSystem/PlaybackState/Lights
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Lights), 16 + sizeof(float)> __UnityEngine_ParticleSystem_PlaybackState_LightsSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Lights) == 0x14);
    // Size: 0x4
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ParticleSystem/PlaybackState/Trail
    // [TokenAttribute] Offset: FFFFFFFF
    struct Trail/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Single m_Timer
      // Size: 0x4
      // Offset: 0x0
      float m_Timer;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      public:
      // Creating value type constructor for type: Trail
      constexpr Trail(float m_Timer_ = {}) noexcept : m_Timer{m_Timer_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating conversion operator: operator float
      constexpr operator float() const noexcept {
        return m_Timer;
      }
      // Get instance field reference: public System.Single m_Timer
      [[deprecated("Use field access instead!")]] float& dyn_m_Timer();
    }; // UnityEngine.ParticleSystem/PlaybackState/Trail
    #pragma pack(pop)
    static check_size<sizeof(ParticleSystem::PlaybackState::Trail), 0 + sizeof(float)> __UnityEngine_ParticleSystem_PlaybackState_TrailSizeCheck;
    static_assert(sizeof(ParticleSystem::PlaybackState::Trail) == 0x4);
    public:
    // System.Single m_AccumulatedDt
    // Size: 0x4
    // Offset: 0x0
    float m_AccumulatedDt;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // System.Single m_StartDelay
    // Size: 0x4
    // Offset: 0x4
    float m_StartDelay;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // System.Single m_PlaybackTime
    // Size: 0x4
    // Offset: 0x8
    float m_PlaybackTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // System.Int32 m_RingBufferIndex
    // Size: 0x4
    // Offset: 0xC
    int m_RingBufferIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // UnityEngine.ParticleSystem/PlaybackState/Emission m_Emission
    // Size: 0x18
    // Offset: 0x10
    ::UnityEngine::ParticleSystem::PlaybackState::Emission m_Emission;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Emission) == 0x18);
    // UnityEngine.ParticleSystem/PlaybackState/Initial m_Initial
    // Size: 0x40
    // Offset: 0x28
    ::UnityEngine::ParticleSystem::PlaybackState::Initial m_Initial;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Initial) == 0x40);
    // UnityEngine.ParticleSystem/PlaybackState/Shape m_Shape
    // Size: 0x5C
    // Offset: 0x68
    ::UnityEngine::ParticleSystem::PlaybackState::Shape m_Shape;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Shape) == 0x5C);
    // UnityEngine.ParticleSystem/PlaybackState/Force m_Force
    // Size: 0x40
    // Offset: 0xC4
    ::UnityEngine::ParticleSystem::PlaybackState::Force m_Force;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Force) == 0x40);
    // UnityEngine.ParticleSystem/PlaybackState/Collision m_Collision
    // Size: 0x40
    // Offset: 0x104
    ::UnityEngine::ParticleSystem::PlaybackState::Collision m_Collision;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Collision) == 0x40);
    // UnityEngine.ParticleSystem/PlaybackState/Noise m_Noise
    // Size: 0x4
    // Offset: 0x144
    ::UnityEngine::ParticleSystem::PlaybackState::Noise m_Noise;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Noise) == 0x4);
    // UnityEngine.ParticleSystem/PlaybackState/Lights m_Lights
    // Size: 0x14
    // Offset: 0x148
    ::UnityEngine::ParticleSystem::PlaybackState::Lights m_Lights;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Lights) == 0x14);
    // UnityEngine.ParticleSystem/PlaybackState/Trail m_Trail
    // Size: 0x4
    // Offset: 0x15C
    ::UnityEngine::ParticleSystem::PlaybackState::Trail m_Trail;
    // Field size check
    static_assert(sizeof(::UnityEngine::ParticleSystem::PlaybackState::Trail) == 0x4);
    public:
    // Creating value type constructor for type: PlaybackState
    constexpr PlaybackState(float m_AccumulatedDt_ = {}, float m_StartDelay_ = {}, float m_PlaybackTime_ = {}, int m_RingBufferIndex_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Emission m_Emission_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Initial m_Initial_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Shape m_Shape_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Force m_Force_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Collision m_Collision_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Noise m_Noise_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Lights m_Lights_ = {}, ::UnityEngine::ParticleSystem::PlaybackState::Trail m_Trail_ = {}) noexcept : m_AccumulatedDt{m_AccumulatedDt_}, m_StartDelay{m_StartDelay_}, m_PlaybackTime{m_PlaybackTime_}, m_RingBufferIndex{m_RingBufferIndex_}, m_Emission{m_Emission_}, m_Initial{m_Initial_}, m_Shape{m_Shape_}, m_Force{m_Force_}, m_Collision{m_Collision_}, m_Noise{m_Noise_}, m_Lights{m_Lights_}, m_Trail{m_Trail_} {}
    // Creating interface conversion operator: operator ::System::ValueType
    operator ::System::ValueType() noexcept {
      return *reinterpret_cast<::System::ValueType*>(this);
    }
    // Get instance field reference: System.Single m_AccumulatedDt
    [[deprecated("Use field access instead!")]] float& dyn_m_AccumulatedDt();
    // Get instance field reference: System.Single m_StartDelay
    [[deprecated("Use field access instead!")]] float& dyn_m_StartDelay();
    // Get instance field reference: System.Single m_PlaybackTime
    [[deprecated("Use field access instead!")]] float& dyn_m_PlaybackTime();
    // Get instance field reference: System.Int32 m_RingBufferIndex
    [[deprecated("Use field access instead!")]] int& dyn_m_RingBufferIndex();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Emission m_Emission
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Emission& dyn_m_Emission();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Initial m_Initial
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Initial& dyn_m_Initial();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Shape m_Shape
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Shape& dyn_m_Shape();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Force m_Force
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Force& dyn_m_Force();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Collision m_Collision
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Collision& dyn_m_Collision();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Noise m_Noise
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Noise& dyn_m_Noise();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Lights m_Lights
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Lights& dyn_m_Lights();
    // Get instance field reference: UnityEngine.ParticleSystem/PlaybackState/Trail m_Trail
    [[deprecated("Use field access instead!")]] ::UnityEngine::ParticleSystem::PlaybackState::Trail& dyn_m_Trail();
  }; // UnityEngine.ParticleSystem/PlaybackState
  #pragma pack(pop)
  static check_size<sizeof(ParticleSystem::PlaybackState), 348 + sizeof(::UnityEngine::ParticleSystem::PlaybackState::Trail)> __UnityEngine_ParticleSystem_PlaybackStateSizeCheck;
  static_assert(sizeof(ParticleSystem::PlaybackState) == 0x160);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Trail, "UnityEngine", "ParticleSystem/PlaybackState/Trail");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Lights, "UnityEngine", "ParticleSystem/PlaybackState/Lights");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Noise, "UnityEngine", "ParticleSystem/PlaybackState/Noise");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Collision, "UnityEngine", "ParticleSystem/PlaybackState/Collision");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Force, "UnityEngine", "ParticleSystem/PlaybackState/Force");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Shape, "UnityEngine", "ParticleSystem/PlaybackState/Shape");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Initial, "UnityEngine", "ParticleSystem/PlaybackState/Initial");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Emission, "UnityEngine", "ParticleSystem/PlaybackState/Emission");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Seed4, "UnityEngine", "ParticleSystem/PlaybackState/Seed4");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ParticleSystem::PlaybackState::Seed, "UnityEngine", "ParticleSystem/PlaybackState/Seed");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
