// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.UIElements.UIR.BaseShaderInfoStorage
#include "UnityEngine/UIElements/UIR/BaseShaderInfoStorage.hpp"
// Including type: UnityEngine.TextureFormat
#include "UnityEngine/TextureFormat.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: Unity.Collections.NativeArray`1
#include "Unity/Collections/NativeArray_1.hpp"
// Including type: UnityEngine.RectInt
#include "UnityEngine/RectInt.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System
namespace System {
  // Skipping declaration: ValueType because it is already included!
  // Forward declaring type: Func`2<T, TResult>
  template<typename T, typename TResult>
  class Func_2;
}
// Forward declaring namespace: UnityEngine::UIElements
namespace UnityEngine::UIElements {
  // Forward declaring type: UIRAtlasAllocator
  class UIRAtlasAllocator;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Texture2D
  class Texture2D;
}
// Completed forward declares
// Type namespace: UnityEngine.UIElements.UIR
namespace UnityEngine::UIElements::UIR {
  // Forward declaring type: ShaderInfoStorage`1<T>
  template<typename T>
  class ShaderInfoStorage_1;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(::UnityEngine::UIElements::UIR::ShaderInfoStorage_1, "UnityEngine.UIElements.UIR", "ShaderInfoStorage`1");
// Type namespace: UnityEngine.UIElements.UIR
namespace UnityEngine::UIElements::UIR {
  // WARNING Size may be invalid!
  // Autogenerated type: UnityEngine.UIElements.UIR.ShaderInfoStorage`1
  // [TokenAttribute] Offset: FFFFFFFF
  template<typename T>
  class ShaderInfoStorage_1 : public ::UnityEngine::UIElements::UIR::BaseShaderInfoStorage {
    public:
    public:
    // private readonly System.Int32 m_InitialSize
    // Size: 0x4
    // Offset: 0x0
    int m_InitialSize;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly System.Int32 m_MaxSize
    // Size: 0x4
    // Offset: 0x0
    int m_MaxSize;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private readonly UnityEngine.TextureFormat m_Format
    // Size: 0x4
    // Offset: 0x0
    ::UnityEngine::TextureFormat m_Format;
    // Field size check
    static_assert(sizeof(::UnityEngine::TextureFormat) == 0x4);
    // private readonly System.Func`2<UnityEngine.Color,T> m_Convert
    // Size: 0x8
    // Offset: 0x0
    ::System::Func_2<::UnityEngine::Color, T>* m_Convert;
    // Field size check
    static_assert(sizeof(::System::Func_2<::UnityEngine::Color, T>*) == 0x8);
    // private UnityEngine.UIElements.UIRAtlasAllocator m_Allocator
    // Size: 0x8
    // Offset: 0x0
    ::UnityEngine::UIElements::UIRAtlasAllocator* m_Allocator;
    // Field size check
    static_assert(sizeof(::UnityEngine::UIElements::UIRAtlasAllocator*) == 0x8);
    // private UnityEngine.Texture2D m_Texture
    // Size: 0x8
    // Offset: 0x0
    ::UnityEngine::Texture2D* m_Texture;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // private Unity.Collections.NativeArray`1<T> m_Texels
    // Size: 0xFFFFFFFF
    // Offset: 0x0
    ::Unity::Collections::NativeArray_1<T> m_Texels;
    public:
    // Deleting conversion operator: operator bool
    constexpr operator bool() const noexcept = delete;
    // Autogenerated instance field getter
    // Get instance field: private readonly System.Int32 m_InitialSize
    [[deprecated("Use field access instead!")]] int& dyn_m_InitialSize() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::dyn_m_InitialSize");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_InitialSize"))->offset;
      return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private readonly System.Int32 m_MaxSize
    [[deprecated("Use field access instead!")]] int& dyn_m_MaxSize() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::dyn_m_MaxSize");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_MaxSize"))->offset;
      return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private readonly UnityEngine.TextureFormat m_Format
    [[deprecated("Use field access instead!")]] ::UnityEngine::TextureFormat& dyn_m_Format() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::dyn_m_Format");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Format"))->offset;
      return *reinterpret_cast<::UnityEngine::TextureFormat*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private readonly System.Func`2<UnityEngine.Color,T> m_Convert
    [[deprecated("Use field access instead!")]] ::System::Func_2<::UnityEngine::Color, T>*& dyn_m_Convert() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::dyn_m_Convert");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Convert"))->offset;
      return *reinterpret_cast<::System::Func_2<::UnityEngine::Color, T>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private UnityEngine.UIElements.UIRAtlasAllocator m_Allocator
    [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIRAtlasAllocator*& dyn_m_Allocator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::dyn_m_Allocator");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Allocator"))->offset;
      return *reinterpret_cast<::UnityEngine::UIElements::UIRAtlasAllocator**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private UnityEngine.Texture2D m_Texture
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn_m_Texture() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::dyn_m_Texture");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Texture"))->offset;
      return *reinterpret_cast<::UnityEngine::Texture2D**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private Unity.Collections.NativeArray`1<T> m_Texels
    [[deprecated("Use field access instead!")]] ::Unity::Collections::NativeArray_1<T>& dyn_m_Texels() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::dyn_m_Texels");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "m_Texels"))->offset;
      return *reinterpret_cast<::Unity::Collections::NativeArray_1<T>*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // public System.Void .ctor(UnityEngine.TextureFormat format, System.Func`2<UnityEngine.Color,T> convert, System.Int32 initialSize, System.Int32 maxSize)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static ShaderInfoStorage_1<T>* New_ctor(::UnityEngine::TextureFormat format, ::System::Func_2<::UnityEngine::Color, T>* convert, int initialSize, int maxSize) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<ShaderInfoStorage_1<T>*, creationType>(format, convert, initialSize, maxSize)));
    }
    // private System.Void CreateOrExpandTexture()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void CreateOrExpandTexture() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::CreateOrExpandTexture");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "CreateOrExpandTexture", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // static private System.Void CpuBlit(Unity.Collections.NativeArray`1<T> src, System.Int32 srcWidth, System.Int32 srcHeight, Unity.Collections.NativeArray`1<T> dst, System.Int32 dstWidth, System.Int32 dstHeight)
    // Offset: 0xFFFFFFFFFFFFFFFF
    static void CpuBlit(::Unity::Collections::NativeArray_1<T> src, int srcWidth, int srcHeight, ::Unity::Collections::NativeArray_1<T> dst, int dstWidth, int dstHeight) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::CpuBlit");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<ShaderInfoStorage_1<T>*>::get(), "CpuBlit", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(src), ::il2cpp_utils::ExtractType(srcWidth), ::il2cpp_utils::ExtractType(srcHeight), ::il2cpp_utils::ExtractType(dst), ::il2cpp_utils::ExtractType(dstWidth), ::il2cpp_utils::ExtractType(dstHeight)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(static_cast<Il2CppObject*>(nullptr), ___internal__method, src, srcWidth, srcHeight, dst, dstWidth, dstHeight);
    }
    // protected override System.Void Dispose(System.Boolean disposing)
    // Offset: 0xFFFFFFFFFFFFFFFF
    // Implemented from: UnityEngine.UIElements.UIR.BaseShaderInfoStorage
    // Base method: System.Void BaseShaderInfoStorage::Dispose(System.Boolean disposing)
    void Dispose(bool disposing) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::Dispose");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::UnityEngine::UIElements::UIR::BaseShaderInfoStorage*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, disposing);
    }
    // public override UnityEngine.Texture2D get_texture()
    // Offset: 0xFFFFFFFFFFFFFFFF
    // Implemented from: UnityEngine.UIElements.UIR.BaseShaderInfoStorage
    // Base method: UnityEngine.Texture2D BaseShaderInfoStorage::get_texture()
    ::UnityEngine::Texture2D* get_texture() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::get_texture");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::UnityEngine::UIElements::UIR::BaseShaderInfoStorage*), -1));
      return ::il2cpp_utils::RunMethodRethrow<::UnityEngine::Texture2D*, false>(this, ___internal__method);
    }
    // public override System.Boolean AllocateRect(System.Int32 width, System.Int32 height, out UnityEngine.RectInt uvs)
    // Offset: 0xFFFFFFFFFFFFFFFF
    // Implemented from: UnityEngine.UIElements.UIR.BaseShaderInfoStorage
    // Base method: System.Boolean BaseShaderInfoStorage::AllocateRect(System.Int32 width, System.Int32 height, out UnityEngine.RectInt uvs)
    bool AllocateRect(int width, int height, ByRef<::UnityEngine::RectInt> uvs) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::AllocateRect");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::UnityEngine::UIElements::UIR::BaseShaderInfoStorage*), -1));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, width, height, byref(uvs));
    }
    // public override System.Void SetTexel(System.Int32 x, System.Int32 y, UnityEngine.Color color)
    // Offset: 0xFFFFFFFFFFFFFFFF
    // Implemented from: UnityEngine.UIElements.UIR.BaseShaderInfoStorage
    // Base method: System.Void BaseShaderInfoStorage::SetTexel(System.Int32 x, System.Int32 y, UnityEngine.Color color)
    void SetTexel(int x, int y, ::UnityEngine::Color color) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::SetTexel");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::UnityEngine::UIElements::UIR::BaseShaderInfoStorage*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, x, y, color);
    }
    // public override System.Void UpdateTexture()
    // Offset: 0xFFFFFFFFFFFFFFFF
    // Implemented from: UnityEngine.UIElements.UIR.BaseShaderInfoStorage
    // Base method: System.Void BaseShaderInfoStorage::UpdateTexture()
    void UpdateTexture() {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::ShaderInfoStorage_1::UpdateTexture");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::UnityEngine::UIElements::UIR::BaseShaderInfoStorage*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
  }; // UnityEngine.UIElements.UIR.ShaderInfoStorage`1
  // Could not write size check! Type: UnityEngine.UIElements.UIR.ShaderInfoStorage`1 is generic, or has no fields that are valid for size checks!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
