// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.IDisposable
#include "System/IDisposable.hpp"
// Including type: System.IntPtr
#include "System/IntPtr.hpp"
// Including type: Unity.Profiling.ProfilerMarker
#include "Unity/Profiling/ProfilerMarker.hpp"
// Including type: System.Nullable`1
#include "System/Nullable_1.hpp"
// Including type: UnityEngine.UIElements.Vertex
#include "UnityEngine/UIElements/Vertex.hpp"
// Including type: Unity.Collections.NativeSlice`1
#include "Unity/Collections/NativeSlice_1.hpp"
// Including type: UnityEngine.UIElements.UIR.Transform3x4
#include "UnityEngine/UIElements/UIR/Transform3x4.hpp"
// Including type: UnityEngine.UIElements.UIR.Utility
#include "UnityEngine/UIElements/UIR/Utility.hpp"
// Including type: UnityEngine.UIElements.UIR.DrawBufferRange
#include "UnityEngine/UIElements/UIR/DrawBufferRange.hpp"
// Including type: UnityEngine.UIElements.UIR.Alloc
#include "UnityEngine/UIElements/UIR/Alloc.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: MaterialPropertyBlock
  class MaterialPropertyBlock;
  // Forward declaring type: Texture2D
  class Texture2D;
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: Texture
  class Texture;
}
// Forward declaring namespace: UnityEngine::UIElements::UIR
namespace UnityEngine::UIElements::UIR {
  // Forward declaring type: MeshHandle
  class MeshHandle;
  // Forward declaring type: LinkedPool`1<T>
  template<typename T>
  class LinkedPool_1;
  // Forward declaring type: Page
  class Page;
  // Forward declaring type: DrawParams
  class DrawParams;
  // Forward declaring type: TextureSlotManager
  class TextureSlotManager;
  // Forward declaring type: RenderChainCommand
  class RenderChainCommand;
  // Skipping declaration: AllocToUpdate because it is already included!
  // Skipping declaration: DrawStatistics because it is already included!
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: LinkedList`1<T>
  template<typename T>
  class LinkedList_1;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Exception
  class Exception;
}
// Completed forward declares
// Type namespace: UnityEngine.UIElements.UIR
namespace UnityEngine::UIElements::UIR {
  // Forward declaring type: UIRenderDevice
  class UIRenderDevice;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::UnityEngine::UIElements::UIR::UIRenderDevice);
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::UIR::UIRenderDevice*, "UnityEngine.UIElements.UIR", "UIRenderDevice");
// Type namespace: UnityEngine.UIElements.UIR
namespace UnityEngine::UIElements::UIR {
  // Size: 0xAE
  #pragma pack(push, 1)
  // Autogenerated type: UnityEngine.UIElements.UIR.UIRenderDevice
  // [TokenAttribute] Offset: FFFFFFFF
  class UIRenderDevice : public ::Il2CppObject/*, public ::System::IDisposable*/ {
    public:
    // Nested type: ::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate
    struct AllocToUpdate;
    // Nested type: ::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToFree
    struct AllocToFree;
    // Nested type: ::UnityEngine::UIElements::UIR::UIRenderDevice::DeviceToFree
    struct DeviceToFree;
    // Nested type: ::UnityEngine::UIElements::UIR::UIRenderDevice::EvaluationState
    struct EvaluationState;
    // Nested type: ::UnityEngine::UIElements::UIR::UIRenderDevice::DrawStatistics
    struct DrawStatistics;
    // Nested type: ::UnityEngine::UIElements::UIR::UIRenderDevice::$$c
    class $$c;
    // Size: 0x49
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.UIElements.UIR.UIRenderDevice/AllocToUpdate
    // [TokenAttribute] Offset: FFFFFFFF
    struct AllocToUpdate/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.UInt32 id
      // Size: 0x4
      // Offset: 0x0
      uint id;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 allocTime
      // Size: 0x4
      // Offset: 0x4
      uint allocTime;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public UnityEngine.UIElements.UIR.MeshHandle meshHandle
      // Size: 0x8
      // Offset: 0x8
      ::UnityEngine::UIElements::UIR::MeshHandle* meshHandle;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::UIR::MeshHandle*) == 0x8);
      // public UnityEngine.UIElements.UIR.Alloc permAllocVerts
      // Size: 0x11
      // Offset: 0x10
      ::UnityEngine::UIElements::UIR::Alloc permAllocVerts;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::UIR::Alloc) == 0x11);
      // Padding between fields: permAllocVerts and: permAllocIndices
      char __padding3[0x7] = {};
      // public UnityEngine.UIElements.UIR.Alloc permAllocIndices
      // Size: 0x11
      // Offset: 0x28
      ::UnityEngine::UIElements::UIR::Alloc permAllocIndices;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::UIR::Alloc) == 0x11);
      // Padding between fields: permAllocIndices and: permPage
      char __padding4[0x7] = {};
      // public UnityEngine.UIElements.UIR.Page permPage
      // Size: 0x8
      // Offset: 0x40
      ::UnityEngine::UIElements::UIR::Page* permPage;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::UIR::Page*) == 0x8);
      // public System.Boolean copyBackIndices
      // Size: 0x1
      // Offset: 0x48
      bool copyBackIndices;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: AllocToUpdate
      constexpr AllocToUpdate(uint id_ = {}, uint allocTime_ = {}, ::UnityEngine::UIElements::UIR::MeshHandle* meshHandle_ = {}, ::UnityEngine::UIElements::UIR::Alloc permAllocVerts_ = {}, ::UnityEngine::UIElements::UIR::Alloc permAllocIndices_ = {}, ::UnityEngine::UIElements::UIR::Page* permPage_ = {}, bool copyBackIndices_ = {}) noexcept : id{id_}, allocTime{allocTime_}, meshHandle{meshHandle_}, permAllocVerts{permAllocVerts_}, permAllocIndices{permAllocIndices_}, permPage{permPage_}, copyBackIndices{copyBackIndices_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.UInt32 id
      [[deprecated("Use field access instead!")]] uint& dyn_id();
      // Get instance field reference: public System.UInt32 allocTime
      [[deprecated("Use field access instead!")]] uint& dyn_allocTime();
      // Get instance field reference: public UnityEngine.UIElements.UIR.MeshHandle meshHandle
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::MeshHandle*& dyn_meshHandle();
      // Get instance field reference: public UnityEngine.UIElements.UIR.Alloc permAllocVerts
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::Alloc& dyn_permAllocVerts();
      // Get instance field reference: public UnityEngine.UIElements.UIR.Alloc permAllocIndices
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::Alloc& dyn_permAllocIndices();
      // Get instance field reference: public UnityEngine.UIElements.UIR.Page permPage
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::Page*& dyn_permPage();
      // Get instance field reference: public System.Boolean copyBackIndices
      [[deprecated("Use field access instead!")]] bool& dyn_copyBackIndices();
    }; // UnityEngine.UIElements.UIR.UIRenderDevice/AllocToUpdate
    #pragma pack(pop)
    static check_size<sizeof(UIRenderDevice::AllocToUpdate), 72 + sizeof(bool)> __UnityEngine_UIElements_UIR_UIRenderDevice_AllocToUpdateSizeCheck;
    static_assert(sizeof(UIRenderDevice::AllocToUpdate) == 0x49);
    // Size: 0x21
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.UIElements.UIR.UIRenderDevice/AllocToFree
    // [TokenAttribute] Offset: FFFFFFFF
    struct AllocToFree/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.UIElements.UIR.Alloc alloc
      // Size: 0x11
      // Offset: 0x0
      ::UnityEngine::UIElements::UIR::Alloc alloc;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::UIR::Alloc) == 0x11);
      // Padding between fields: alloc and: page
      char __padding0[0x7] = {};
      // public UnityEngine.UIElements.UIR.Page page
      // Size: 0x8
      // Offset: 0x18
      ::UnityEngine::UIElements::UIR::Page* page;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::UIR::Page*) == 0x8);
      // public System.Boolean vertices
      // Size: 0x1
      // Offset: 0x20
      bool vertices;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: AllocToFree
      constexpr AllocToFree(::UnityEngine::UIElements::UIR::Alloc alloc_ = {}, ::UnityEngine::UIElements::UIR::Page* page_ = {}, bool vertices_ = {}) noexcept : alloc{alloc_}, page{page_}, vertices{vertices_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.UIElements.UIR.Alloc alloc
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::Alloc& dyn_alloc();
      // Get instance field reference: public UnityEngine.UIElements.UIR.Page page
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::Page*& dyn_page();
      // Get instance field reference: public System.Boolean vertices
      [[deprecated("Use field access instead!")]] bool& dyn_vertices();
    }; // UnityEngine.UIElements.UIR.UIRenderDevice/AllocToFree
    #pragma pack(pop)
    static check_size<sizeof(UIRenderDevice::AllocToFree), 32 + sizeof(bool)> __UnityEngine_UIElements_UIR_UIRenderDevice_AllocToFreeSizeCheck;
    static_assert(sizeof(UIRenderDevice::AllocToFree) == 0x21);
    // Size: 0x10
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.UIElements.UIR.UIRenderDevice/DeviceToFree
    // [TokenAttribute] Offset: FFFFFFFF
    struct DeviceToFree/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.UInt32 handle
      // Size: 0x4
      // Offset: 0x0
      uint handle;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // Padding between fields: handle and: page
      char __padding0[0x4] = {};
      // public UnityEngine.UIElements.UIR.Page page
      // Size: 0x8
      // Offset: 0x8
      ::UnityEngine::UIElements::UIR::Page* page;
      // Field size check
      static_assert(sizeof(::UnityEngine::UIElements::UIR::Page*) == 0x8);
      public:
      // Creating value type constructor for type: DeviceToFree
      constexpr DeviceToFree(uint handle_ = {}, ::UnityEngine::UIElements::UIR::Page* page_ = {}) noexcept : handle{handle_}, page{page_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.UInt32 handle
      [[deprecated("Use field access instead!")]] uint& dyn_handle();
      // Get instance field reference: public UnityEngine.UIElements.UIR.Page page
      [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::Page*& dyn_page();
      // public System.Void Dispose()
      // Offset: 0x55DA460
      void Dispose();
    }; // UnityEngine.UIElements.UIR.UIRenderDevice/DeviceToFree
    #pragma pack(pop)
    static check_size<sizeof(UIRenderDevice::DeviceToFree), 8 + sizeof(::UnityEngine::UIElements::UIR::Page*)> __UnityEngine_UIElements_UIR_UIRenderDevice_DeviceToFreeSizeCheck;
    static_assert(sizeof(UIRenderDevice::DeviceToFree) == 0x10);
    // Size: 0x24
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.UIElements.UIR.UIRenderDevice/DrawStatistics
    // [TokenAttribute] Offset: FFFFFFFF
    struct DrawStatistics/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Int32 currentFrameIndex
      // Size: 0x4
      // Offset: 0x0
      int currentFrameIndex;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.UInt32 totalIndices
      // Size: 0x4
      // Offset: 0x4
      uint totalIndices;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 commandCount
      // Size: 0x4
      // Offset: 0x8
      uint commandCount;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 drawCommandCount
      // Size: 0x4
      // Offset: 0xC
      uint drawCommandCount;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 materialSetCount
      // Size: 0x4
      // Offset: 0x10
      uint materialSetCount;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 drawRangeCount
      // Size: 0x4
      // Offset: 0x14
      uint drawRangeCount;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 drawRangeCallCount
      // Size: 0x4
      // Offset: 0x18
      uint drawRangeCallCount;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 immediateDraws
      // Size: 0x4
      // Offset: 0x1C
      uint immediateDraws;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      // public System.UInt32 stencilRefChanges
      // Size: 0x4
      // Offset: 0x20
      uint stencilRefChanges;
      // Field size check
      static_assert(sizeof(uint) == 0x4);
      public:
      // Creating value type constructor for type: DrawStatistics
      constexpr DrawStatistics(int currentFrameIndex_ = {}, uint totalIndices_ = {}, uint commandCount_ = {}, uint drawCommandCount_ = {}, uint materialSetCount_ = {}, uint drawRangeCount_ = {}, uint drawRangeCallCount_ = {}, uint immediateDraws_ = {}, uint stencilRefChanges_ = {}) noexcept : currentFrameIndex{currentFrameIndex_}, totalIndices{totalIndices_}, commandCount{commandCount_}, drawCommandCount{drawCommandCount_}, materialSetCount{materialSetCount_}, drawRangeCount{drawRangeCount_}, drawRangeCallCount{drawRangeCallCount_}, immediateDraws{immediateDraws_}, stencilRefChanges{stencilRefChanges_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Int32 currentFrameIndex
      [[deprecated("Use field access instead!")]] int& dyn_currentFrameIndex();
      // Get instance field reference: public System.UInt32 totalIndices
      [[deprecated("Use field access instead!")]] uint& dyn_totalIndices();
      // Get instance field reference: public System.UInt32 commandCount
      [[deprecated("Use field access instead!")]] uint& dyn_commandCount();
      // Get instance field reference: public System.UInt32 drawCommandCount
      [[deprecated("Use field access instead!")]] uint& dyn_drawCommandCount();
      // Get instance field reference: public System.UInt32 materialSetCount
      [[deprecated("Use field access instead!")]] uint& dyn_materialSetCount();
      // Get instance field reference: public System.UInt32 drawRangeCount
      [[deprecated("Use field access instead!")]] uint& dyn_drawRangeCount();
      // Get instance field reference: public System.UInt32 drawRangeCallCount
      [[deprecated("Use field access instead!")]] uint& dyn_drawRangeCallCount();
      // Get instance field reference: public System.UInt32 immediateDraws
      [[deprecated("Use field access instead!")]] uint& dyn_immediateDraws();
      // Get instance field reference: public System.UInt32 stencilRefChanges
      [[deprecated("Use field access instead!")]] uint& dyn_stencilRefChanges();
    }; // UnityEngine.UIElements.UIR.UIRenderDevice/DrawStatistics
    #pragma pack(pop)
    static check_size<sizeof(UIRenderDevice::DrawStatistics), 32 + sizeof(uint)> __UnityEngine_UIElements_UIR_UIRenderDevice_DrawStatisticsSizeCheck;
    static_assert(sizeof(UIRenderDevice::DrawStatistics) == 0x24);
    public:
    // private readonly System.Boolean m_MockDevice
    // Size: 0x1
    // Offset: 0x10
    bool m_MockDevice;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_MockDevice and: m_DefaultStencilState
    char __padding0[0x7] = {};
    // private System.IntPtr m_DefaultStencilState
    // Size: 0x8
    // Offset: 0x18
    ::System::IntPtr m_DefaultStencilState;
    // Field size check
    static_assert(sizeof(::System::IntPtr) == 0x8);
    // private System.IntPtr m_VertexDecl
    // Size: 0x8
    // Offset: 0x20
    ::System::IntPtr m_VertexDecl;
    // Field size check
    static_assert(sizeof(::System::IntPtr) == 0x8);
    // private UnityEngine.UIElements.UIR.Page m_FirstPage
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::UIElements::UIR::Page* m_FirstPage;
    // Field size check
    static_assert(sizeof(::UnityEngine::UIElements::UIR::Page*) == 0x8);
    // private System.UInt32 m_NextPageVertexCount
    // Size: 0x4
    // Offset: 0x30
    uint m_NextPageVertexCount;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.UInt32 m_LargeMeshVertexCount
    // Size: 0x4
    // Offset: 0x34
    uint m_LargeMeshVertexCount;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.Single m_IndexToVertexCountRatio
    // Size: 0x4
    // Offset: 0x38
    float m_IndexToVertexCountRatio;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: m_IndexToVertexCountRatio and: m_DeferredFrees
    char __padding6[0x4] = {};
    // private System.Collections.Generic.List`1<System.Collections.Generic.List`1<UnityEngine.UIElements.UIR.UIRenderDevice/AllocToFree>> m_DeferredFrees
    // Size: 0x8
    // Offset: 0x40
    ::System::Collections::Generic::List_1<::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToFree>*>* m_DeferredFrees;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToFree>*>*) == 0x8);
    // private System.Collections.Generic.List`1<System.Collections.Generic.List`1<UnityEngine.UIElements.UIR.UIRenderDevice/AllocToUpdate>> m_Updates
    // Size: 0x8
    // Offset: 0x48
    ::System::Collections::Generic::List_1<::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate>*>* m_Updates;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate>*>*) == 0x8);
    // private System.UInt32[] m_Fences
    // Size: 0x8
    // Offset: 0x50
    ::ArrayW<uint> m_Fences;
    // Field size check
    static_assert(sizeof(::ArrayW<uint>) == 0x8);
    // private UnityEngine.MaterialPropertyBlock m_StandardMatProps
    // Size: 0x8
    // Offset: 0x58
    ::UnityEngine::MaterialPropertyBlock* m_StandardMatProps;
    // Field size check
    static_assert(sizeof(::UnityEngine::MaterialPropertyBlock*) == 0x8);
    // private System.UInt32 m_FrameIndex
    // Size: 0x4
    // Offset: 0x60
    uint m_FrameIndex;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.UInt32 m_NextUpdateID
    // Size: 0x4
    // Offset: 0x64
    uint m_NextUpdateID;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private UnityEngine.UIElements.UIR.UIRenderDevice/DrawStatistics m_DrawStats
    // Size: 0x24
    // Offset: 0x68
    ::UnityEngine::UIElements::UIR::UIRenderDevice::DrawStatistics m_DrawStats;
    // Field size check
    static_assert(sizeof(::UnityEngine::UIElements::UIR::UIRenderDevice::DrawStatistics) == 0x24);
    // Padding between fields: m_DrawStats and: m_MeshHandles
    char __padding13[0x4] = {};
    // private readonly UnityEngine.UIElements.UIR.LinkedPool`1<UnityEngine.UIElements.UIR.MeshHandle> m_MeshHandles
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::UIElements::UIR::LinkedPool_1<::UnityEngine::UIElements::UIR::MeshHandle*>* m_MeshHandles;
    // Field size check
    static_assert(sizeof(::UnityEngine::UIElements::UIR::LinkedPool_1<::UnityEngine::UIElements::UIR::MeshHandle*>*) == 0x8);
    // private readonly UnityEngine.UIElements.UIR.DrawParams m_DrawParams
    // Size: 0x8
    // Offset: 0x98
    ::UnityEngine::UIElements::UIR::DrawParams* m_DrawParams;
    // Field size check
    static_assert(sizeof(::UnityEngine::UIElements::UIR::DrawParams*) == 0x8);
    // private readonly UnityEngine.UIElements.UIR.TextureSlotManager m_TextureSlotManager
    // Size: 0x8
    // Offset: 0xA0
    ::UnityEngine::UIElements::UIR::TextureSlotManager* m_TextureSlotManager;
    // Field size check
    static_assert(sizeof(::UnityEngine::UIElements::UIR::TextureSlotManager*) == 0x8);
    // private readonly System.UInt32 <maxVerticesPerPage>k__BackingField
    // Size: 0x4
    // Offset: 0xA8
    uint maxVerticesPerPage;
    // Field size check
    static_assert(sizeof(uint) == 0x4);
    // private System.Boolean <breakBatches>k__BackingField
    // Size: 0x1
    // Offset: 0xAC
    bool breakBatches;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean <disposed>k__BackingField
    // Size: 0x1
    // Offset: 0xAD
    bool disposed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator ::System::IDisposable
    operator ::System::IDisposable() noexcept {
      return *reinterpret_cast<::System::IDisposable*>(this);
    }
    // Get static field: static private System.Collections.Generic.LinkedList`1<UnityEngine.UIElements.UIR.UIRenderDevice/DeviceToFree> m_DeviceFreeQueue
    static ::System::Collections::Generic::LinkedList_1<::UnityEngine::UIElements::UIR::UIRenderDevice::DeviceToFree>* _get_m_DeviceFreeQueue();
    // Set static field: static private System.Collections.Generic.LinkedList`1<UnityEngine.UIElements.UIR.UIRenderDevice/DeviceToFree> m_DeviceFreeQueue
    static void _set_m_DeviceFreeQueue(::System::Collections::Generic::LinkedList_1<::UnityEngine::UIElements::UIR::UIRenderDevice::DeviceToFree>* value);
    // Get static field: static private System.Int32 m_ActiveDeviceCount
    static int _get_m_ActiveDeviceCount();
    // Set static field: static private System.Int32 m_ActiveDeviceCount
    static void _set_m_ActiveDeviceCount(int value);
    // Get static field: static private System.Boolean m_SubscribedToNotifications
    static bool _get_m_SubscribedToNotifications();
    // Set static field: static private System.Boolean m_SubscribedToNotifications
    static void _set_m_SubscribedToNotifications(bool value);
    // Get static field: static private System.Boolean m_SynchronousFree
    static bool _get_m_SynchronousFree();
    // Set static field: static private System.Boolean m_SynchronousFree
    static void _set_m_SynchronousFree(bool value);
    // Get static field: static private readonly System.Int32 s_GradientSettingsTexID
    static int _get_s_GradientSettingsTexID();
    // Set static field: static private readonly System.Int32 s_GradientSettingsTexID
    static void _set_s_GradientSettingsTexID(int value);
    // Get static field: static private readonly System.Int32 s_ShaderInfoTexID
    static int _get_s_ShaderInfoTexID();
    // Set static field: static private readonly System.Int32 s_ShaderInfoTexID
    static void _set_s_ShaderInfoTexID(int value);
    // Get static field: static private readonly System.Int32 s_TransformsPropID
    static int _get_s_TransformsPropID();
    // Set static field: static private readonly System.Int32 s_TransformsPropID
    static void _set_s_TransformsPropID(int value);
    // Get static field: static private readonly System.Int32 s_ClipRectsPropID
    static int _get_s_ClipRectsPropID();
    // Set static field: static private readonly System.Int32 s_ClipRectsPropID
    static void _set_s_ClipRectsPropID(int value);
    // Get static field: static private Unity.Profiling.ProfilerMarker s_MarkerAllocate
    static ::Unity::Profiling::ProfilerMarker _get_s_MarkerAllocate();
    // Set static field: static private Unity.Profiling.ProfilerMarker s_MarkerAllocate
    static void _set_s_MarkerAllocate(::Unity::Profiling::ProfilerMarker value);
    // Get static field: static private Unity.Profiling.ProfilerMarker s_MarkerFree
    static ::Unity::Profiling::ProfilerMarker _get_s_MarkerFree();
    // Set static field: static private Unity.Profiling.ProfilerMarker s_MarkerFree
    static void _set_s_MarkerFree(::Unity::Profiling::ProfilerMarker value);
    // Get static field: static private Unity.Profiling.ProfilerMarker s_MarkerAdvanceFrame
    static ::Unity::Profiling::ProfilerMarker _get_s_MarkerAdvanceFrame();
    // Set static field: static private Unity.Profiling.ProfilerMarker s_MarkerAdvanceFrame
    static void _set_s_MarkerAdvanceFrame(::Unity::Profiling::ProfilerMarker value);
    // Get static field: static private Unity.Profiling.ProfilerMarker s_MarkerFence
    static ::Unity::Profiling::ProfilerMarker _get_s_MarkerFence();
    // Set static field: static private Unity.Profiling.ProfilerMarker s_MarkerFence
    static void _set_s_MarkerFence(::Unity::Profiling::ProfilerMarker value);
    // Get static field: static private Unity.Profiling.ProfilerMarker s_MarkerBeforeDraw
    static ::Unity::Profiling::ProfilerMarker _get_s_MarkerBeforeDraw();
    // Set static field: static private Unity.Profiling.ProfilerMarker s_MarkerBeforeDraw
    static void _set_s_MarkerBeforeDraw(::Unity::Profiling::ProfilerMarker value);
    // Get static field: static private System.Nullable`1<System.Boolean> s_VertexTexturingIsAvailable
    static ::System::Nullable_1<bool> _get_s_VertexTexturingIsAvailable();
    // Set static field: static private System.Nullable`1<System.Boolean> s_VertexTexturingIsAvailable
    static void _set_s_VertexTexturingIsAvailable(::System::Nullable_1<bool> value);
    // Get static field: static private System.Nullable`1<System.Boolean> s_ShaderModelIs35
    static ::System::Nullable_1<bool> _get_s_ShaderModelIs35();
    // Set static field: static private System.Nullable`1<System.Boolean> s_ShaderModelIs35
    static void _set_s_ShaderModelIs35(::System::Nullable_1<bool> value);
    // Get static field: static private UnityEngine.Texture2D s_DefaultShaderInfoTexFloat
    static ::UnityEngine::Texture2D* _get_s_DefaultShaderInfoTexFloat();
    // Set static field: static private UnityEngine.Texture2D s_DefaultShaderInfoTexFloat
    static void _set_s_DefaultShaderInfoTexFloat(::UnityEngine::Texture2D* value);
    // Get static field: static private UnityEngine.Texture2D s_DefaultShaderInfoTexARGB8
    static ::UnityEngine::Texture2D* _get_s_DefaultShaderInfoTexARGB8();
    // Set static field: static private UnityEngine.Texture2D s_DefaultShaderInfoTexARGB8
    static void _set_s_DefaultShaderInfoTexARGB8(::UnityEngine::Texture2D* value);
    // Get instance field reference: private readonly System.Boolean m_MockDevice
    [[deprecated("Use field access instead!")]] bool& dyn_m_MockDevice();
    // Get instance field reference: private System.IntPtr m_DefaultStencilState
    [[deprecated("Use field access instead!")]] ::System::IntPtr& dyn_m_DefaultStencilState();
    // Get instance field reference: private System.IntPtr m_VertexDecl
    [[deprecated("Use field access instead!")]] ::System::IntPtr& dyn_m_VertexDecl();
    // Get instance field reference: private UnityEngine.UIElements.UIR.Page m_FirstPage
    [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::Page*& dyn_m_FirstPage();
    // Get instance field reference: private System.UInt32 m_NextPageVertexCount
    [[deprecated("Use field access instead!")]] uint& dyn_m_NextPageVertexCount();
    // Get instance field reference: private System.UInt32 m_LargeMeshVertexCount
    [[deprecated("Use field access instead!")]] uint& dyn_m_LargeMeshVertexCount();
    // Get instance field reference: private System.Single m_IndexToVertexCountRatio
    [[deprecated("Use field access instead!")]] float& dyn_m_IndexToVertexCountRatio();
    // Get instance field reference: private System.Collections.Generic.List`1<System.Collections.Generic.List`1<UnityEngine.UIElements.UIR.UIRenderDevice/AllocToFree>> m_DeferredFrees
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToFree>*>*& dyn_m_DeferredFrees();
    // Get instance field reference: private System.Collections.Generic.List`1<System.Collections.Generic.List`1<UnityEngine.UIElements.UIR.UIRenderDevice/AllocToUpdate>> m_Updates
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate>*>*& dyn_m_Updates();
    // Get instance field reference: private System.UInt32[] m_Fences
    [[deprecated("Use field access instead!")]] ::ArrayW<uint>& dyn_m_Fences();
    // Get instance field reference: private UnityEngine.MaterialPropertyBlock m_StandardMatProps
    [[deprecated("Use field access instead!")]] ::UnityEngine::MaterialPropertyBlock*& dyn_m_StandardMatProps();
    // Get instance field reference: private System.UInt32 m_FrameIndex
    [[deprecated("Use field access instead!")]] uint& dyn_m_FrameIndex();
    // Get instance field reference: private System.UInt32 m_NextUpdateID
    [[deprecated("Use field access instead!")]] uint& dyn_m_NextUpdateID();
    // Get instance field reference: private UnityEngine.UIElements.UIR.UIRenderDevice/DrawStatistics m_DrawStats
    [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::UIRenderDevice::DrawStatistics& dyn_m_DrawStats();
    // Get instance field reference: private readonly UnityEngine.UIElements.UIR.LinkedPool`1<UnityEngine.UIElements.UIR.MeshHandle> m_MeshHandles
    [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::LinkedPool_1<::UnityEngine::UIElements::UIR::MeshHandle*>*& dyn_m_MeshHandles();
    // Get instance field reference: private readonly UnityEngine.UIElements.UIR.DrawParams m_DrawParams
    [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::DrawParams*& dyn_m_DrawParams();
    // Get instance field reference: private readonly UnityEngine.UIElements.UIR.TextureSlotManager m_TextureSlotManager
    [[deprecated("Use field access instead!")]] ::UnityEngine::UIElements::UIR::TextureSlotManager*& dyn_m_TextureSlotManager();
    // Get instance field reference: private readonly System.UInt32 <maxVerticesPerPage>k__BackingField
    [[deprecated("Use field access instead!")]] uint& dyn_$maxVerticesPerPage$k__BackingField();
    // Get instance field reference: private System.Boolean <breakBatches>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$breakBatches$k__BackingField();
    // Get instance field reference: private System.Boolean <disposed>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$disposed$k__BackingField();
    // System.UInt32 get_maxVerticesPerPage()
    // Offset: 0x55D9334
    uint get_maxVerticesPerPage();
    // System.Boolean get_breakBatches()
    // Offset: 0x55D933C
    bool get_breakBatches();
    // System.Void set_breakBatches(System.Boolean value)
    // Offset: 0x55D9344
    void set_breakBatches(bool value);
    // static private System.Void .cctor()
    // Offset: 0x55D9350
    static void _cctor();
    // public System.Void .ctor(System.UInt32 initialVertexCapacity, System.UInt32 initialIndexCapacity)
    // Offset: 0x55D9684
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static UIRenderDevice* New_ctor(uint initialVertexCapacity, uint initialIndexCapacity) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::UIRenderDevice::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<UIRenderDevice*, creationType>(initialVertexCapacity, initialIndexCapacity)));
    }
    // protected System.Void .ctor(System.UInt32 initialVertexCapacity, System.UInt32 initialIndexCapacity, System.Boolean mockDevice)
    // Offset: 0x55D968C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static UIRenderDevice* New_ctor(uint initialVertexCapacity, uint initialIndexCapacity, bool mockDevice) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::UIRenderDevice::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<UIRenderDevice*, creationType>(initialVertexCapacity, initialIndexCapacity, mockDevice)));
    }
    // static UnityEngine.Texture2D get_defaultShaderInfoTexFloat()
    // Offset: 0x55D6238
    static ::UnityEngine::Texture2D* get_defaultShaderInfoTexFloat();
    // static UnityEngine.Texture2D get_defaultShaderInfoTexARGB8()
    // Offset: 0x55D5F5C
    static ::UnityEngine::Texture2D* get_defaultShaderInfoTexARGB8();
    // static System.Boolean get_vertexTexturingIsAvailable()
    // Offset: 0x55D68A0
    static bool get_vertexTexturingIsAvailable();
    // static System.Boolean get_shaderModelIs35()
    // Offset: 0x55D4704
    static bool get_shaderModelIs35();
    // private System.Void InitVertexDeclaration()
    // Offset: 0x55D9E20
    void InitVertexDeclaration();
    // private System.Void CompleteCreation()
    // Offset: 0x55DA0BC
    void CompleteCreation();
    // private System.Boolean get_fullyCreated()
    // Offset: 0x55DA26C
    bool get_fullyCreated();
    // protected System.Boolean get_disposed()
    // Offset: 0x55DA27C
    bool get_disposed();
    // private System.Void set_disposed(System.Boolean value)
    // Offset: 0x55DA284
    void set_disposed(bool value);
    // public System.Void Dispose()
    // Offset: 0x55DA290
    void Dispose();
    // protected System.Void Dispose(System.Boolean disposing)
    // Offset: 0x55DA2FC
    void Dispose(bool disposing);
    // public UnityEngine.UIElements.UIR.MeshHandle Allocate(System.UInt32 vertexCount, System.UInt32 indexCount, out Unity.Collections.NativeSlice`1<UnityEngine.UIElements.Vertex> vertexData, out Unity.Collections.NativeSlice`1<System.UInt16> indexData, out System.UInt16 indexOffset)
    // Offset: 0x55DA85C
    ::UnityEngine::UIElements::UIR::MeshHandle* Allocate(uint vertexCount, uint indexCount, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>> vertexData, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>> indexData, ByRef<uint16_t> indexOffset);
    // public System.Void Update(UnityEngine.UIElements.UIR.MeshHandle mesh, System.UInt32 vertexCount, out Unity.Collections.NativeSlice`1<UnityEngine.UIElements.Vertex> vertexData)
    // Offset: 0x55DAFAC
    void Update(::UnityEngine::UIElements::UIR::MeshHandle* mesh, uint vertexCount, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>> vertexData);
    // public System.Void Update(UnityEngine.UIElements.UIR.MeshHandle mesh, System.UInt32 vertexCount, System.UInt32 indexCount, out Unity.Collections.NativeSlice`1<UnityEngine.UIElements.Vertex> vertexData, out Unity.Collections.NativeSlice`1<System.UInt16> indexData, out System.UInt16 indexOffset)
    // Offset: 0x55DB8E0
    void Update(::UnityEngine::UIElements::UIR::MeshHandle* mesh, uint vertexCount, uint indexCount, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>> vertexData, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>> indexData, ByRef<uint16_t> indexOffset);
    // private System.Void UpdateCopyBackIndices(UnityEngine.UIElements.UIR.MeshHandle mesh, System.Boolean copyBackIndices)
    // Offset: 0x55DBA78
    void UpdateCopyBackIndices(::UnityEngine::UIElements::UIR::MeshHandle* mesh, bool copyBackIndices);
    // System.Collections.Generic.List`1<UnityEngine.UIElements.UIR.UIRenderDevice/AllocToUpdate> ActiveUpdatesForMeshHandle(UnityEngine.UIElements.UIR.MeshHandle mesh)
    // Offset: 0x55DBB7C
    ::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate>* ActiveUpdatesForMeshHandle(::UnityEngine::UIElements::UIR::MeshHandle* mesh);
    // private System.Boolean TryAllocFromPage(UnityEngine.UIElements.UIR.Page page, System.UInt32 vertexCount, System.UInt32 indexCount, ref UnityEngine.UIElements.UIR.Alloc va, ref UnityEngine.UIElements.UIR.Alloc ia, System.Boolean shortLived)
    // Offset: 0x55DBBF0
    bool TryAllocFromPage(::UnityEngine::UIElements::UIR::Page* page, uint vertexCount, uint indexCount, ByRef<::UnityEngine::UIElements::UIR::Alloc> va, ByRef<::UnityEngine::UIElements::UIR::Alloc> ia, bool shortLived);
    // private System.Void Allocate(UnityEngine.UIElements.UIR.MeshHandle meshHandle, System.UInt32 vertexCount, System.UInt32 indexCount, out Unity.Collections.NativeSlice`1<UnityEngine.UIElements.Vertex> vertexData, out Unity.Collections.NativeSlice`1<System.UInt16> indexData, System.Boolean shortLived)
    // Offset: 0x55DA91C
    void Allocate(::UnityEngine::UIElements::UIR::MeshHandle* meshHandle, uint vertexCount, uint indexCount, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>> vertexData, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>> indexData, bool shortLived);
    // private System.Void UpdateAfterGPUUsedData(UnityEngine.UIElements.UIR.MeshHandle mesh, System.UInt32 vertexCount, System.UInt32 indexCount, out Unity.Collections.NativeSlice`1<UnityEngine.UIElements.Vertex> vertexData, out Unity.Collections.NativeSlice`1<System.UInt16> indexData, out System.UInt16 indexOffset, out UnityEngine.UIElements.UIR.UIRenderDevice/AllocToUpdate allocToUpdate, System.Boolean copyBackIndices)
    // Offset: 0x55DB174
    void UpdateAfterGPUUsedData(::UnityEngine::UIElements::UIR::MeshHandle* mesh, uint vertexCount, uint indexCount, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>> vertexData, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>> indexData, ByRef<uint16_t> indexOffset, ByRef<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate> allocToUpdate, bool copyBackIndices);
    // public System.Void Free(UnityEngine.UIElements.UIR.MeshHandle mesh)
    // Offset: 0x55DC068
    void Free(::UnityEngine::UIElements::UIR::MeshHandle* mesh);
    // public System.Void OnFrameRenderingBegin()
    // Offset: 0x55DC8C0
    void OnFrameRenderingBegin();
    // static Unity.Collections.NativeSlice`1<T> PtrToSlice(System.Void* p, System.Int32 count)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static ::Unity::Collections::NativeSlice_1<T> PtrToSlice(void* p, int count) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::UIRenderDevice::PtrToSlice");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("UnityEngine.UIElements.UIR", "UIRenderDevice", "PtrToSlice", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(p), ::il2cpp_utils::ExtractType(count)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::Unity::Collections::NativeSlice_1<T>, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, p, count);
    }
    // private System.Void ApplyDrawCommandState(UnityEngine.UIElements.UIR.RenderChainCommand cmd, System.Int32 textureSlot, UnityEngine.Material newMat, System.Boolean newMatDiffers, ref UnityEngine.UIElements.UIR.UIRenderDevice/EvaluationState st)
    // Offset: 0x55DD378
    void ApplyDrawCommandState(::UnityEngine::UIElements::UIR::RenderChainCommand* cmd, int textureSlot, ::UnityEngine::Material* newMat, bool newMatDiffers, ByRef<::UnityEngine::UIElements::UIR::UIRenderDevice::EvaluationState> st);
    // private System.Void ApplyBatchState(ref UnityEngine.UIElements.UIR.UIRenderDevice/EvaluationState st, System.Boolean allowMaterialChange)
    // Offset: 0x55DD524
    void ApplyBatchState(ByRef<::UnityEngine::UIElements::UIR::UIRenderDevice::EvaluationState> st, bool allowMaterialChange);
    // public System.Void EvaluateChain(UnityEngine.UIElements.UIR.RenderChainCommand head, UnityEngine.Material initialMat, UnityEngine.Material defaultMat, UnityEngine.Texture gradientSettings, UnityEngine.Texture shaderInfo, System.Single pixelsPerPoint, Unity.Collections.NativeSlice`1<UnityEngine.UIElements.UIR.Transform3x4> transforms, Unity.Collections.NativeSlice`1<UnityEngine.Vector4> clipRects, UnityEngine.MaterialPropertyBlock stateMatProps, System.Boolean allowMaterialChange, ref System.Exception immediateException)
    // Offset: 0x55DD6B4
    void EvaluateChain(::UnityEngine::UIElements::UIR::RenderChainCommand* head, ::UnityEngine::Material* initialMat, ::UnityEngine::Material* defaultMat, ::UnityEngine::Texture* gradientSettings, ::UnityEngine::Texture* shaderInfo, float pixelsPerPoint, ::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::UIR::Transform3x4> transforms, ::Unity::Collections::NativeSlice_1<::UnityEngine::Vector4> clipRects, ::UnityEngine::MaterialPropertyBlock* stateMatProps, bool allowMaterialChange, ByRef<::System::Exception*> immediateException);
    // private System.Void UpdateFenceValue()
    // Offset: 0x55DF160
    void UpdateFenceValue();
    // private System.Void KickRanges(UnityEngine.UIElements.UIR.DrawBufferRange* ranges, ref System.Int32 rangesReady, ref System.Int32 rangesStart, System.Int32 rangesCount, UnityEngine.UIElements.UIR.Page curPage)
    // Offset: 0x55DE438
    void KickRanges(::UnityEngine::UIElements::UIR::DrawBufferRange* ranges, ByRef<int> rangesReady, ByRef<int> rangesStart, int rangesCount, ::UnityEngine::UIElements::UIR::Page* curPage);
    // private System.Void DrawRanges(UnityEngine.UIElements.UIR.Utility/GPUBuffer`1<I> ib, UnityEngine.UIElements.UIR.Utility/GPUBuffer`1<T> vb, Unity.Collections.NativeSlice`1<UnityEngine.UIElements.UIR.DrawBufferRange> ranges)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class I, class T>
    void DrawRanges(::UnityEngine::UIElements::UIR::Utility::GPUBuffer_1<I>* ib, ::UnityEngine::UIElements::UIR::Utility::GPUBuffer_1<T>* vb, ::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::UIR::DrawBufferRange> ranges) {
      static_assert(std::is_convertible_v<I, ::System::ValueType*>);
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::UIElements::UIR::UIRenderDevice::DrawRanges");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "DrawRanges", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<I>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(ib), ::il2cpp_utils::ExtractType(vb), ::il2cpp_utils::ExtractType(ranges)})));
      static auto* ___generic__method = THROW_UNLESS((::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<I>::get(), ::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method, ib, vb, ranges);
    }
    // private System.Void WaitOnCpuFence(System.UInt32 fence)
    // Offset: 0x55DF228
    void WaitOnCpuFence(uint fence);
    // public System.Void AdvanceFrame()
    // Offset: 0x55DC964
    void AdvanceFrame();
    // private System.Void PruneUnusedPages()
    // Offset: 0x55DF2B0
    void PruneUnusedPages();
    // static System.Void PrepareForGfxDeviceRecreate()
    // Offset: 0x55DF44C
    static void PrepareForGfxDeviceRecreate();
    // static System.Void WrapUpGfxDeviceRecreate()
    // Offset: 0x55DF5F4
    static void WrapUpGfxDeviceRecreate();
    // static System.Void FlushAllPendingDeviceDisposes()
    // Offset: 0x55DF654
    static void FlushAllPendingDeviceDisposes();
    // UnityEngine.UIElements.UIR.UIRenderDevice/DrawStatistics GatherDrawStatistics()
    // Offset: 0x55DF6CC
    ::UnityEngine::UIElements::UIR::UIRenderDevice::DrawStatistics GatherDrawStatistics();
    // static private System.Void ProcessDeviceFreeQueue()
    // Offset: 0x55DA4A0
    static void ProcessDeviceFreeQueue();
    // static private System.Void OnEngineUpdateGlobal()
    // Offset: 0x55DF6E4
    static void OnEngineUpdateGlobal();
    // static private System.Void OnFlushPendingResources()
    // Offset: 0x55DF730
    static void OnFlushPendingResources();
  }; // UnityEngine.UIElements.UIR.UIRenderDevice
  #pragma pack(pop)
  static check_size<sizeof(UIRenderDevice), 173 + sizeof(bool)> __UnityEngine_UIElements_UIR_UIRenderDeviceSizeCheck;
  static_assert(sizeof(UIRenderDevice) == 0xAE);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::UIR::UIRenderDevice::DrawStatistics, "UnityEngine.UIElements.UIR", "UIRenderDevice/DrawStatistics");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::UIR::UIRenderDevice::DeviceToFree, "UnityEngine.UIElements.UIR", "UIRenderDevice/DeviceToFree");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToFree, "UnityEngine.UIElements.UIR", "UIRenderDevice/AllocToFree");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate, "UnityEngine.UIElements.UIR", "UIRenderDevice/AllocToUpdate");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_maxVerticesPerPage
// Il2CppName: get_maxVerticesPerPage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<uint (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_maxVerticesPerPage)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_maxVerticesPerPage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_breakBatches
// Il2CppName: get_breakBatches
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_breakBatches)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_breakBatches", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::set_breakBatches
// Il2CppName: set_breakBatches
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::set_breakBatches)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "set_breakBatches", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_defaultShaderInfoTexFloat
// Il2CppName: get_defaultShaderInfoTexFloat
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Texture2D* (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_defaultShaderInfoTexFloat)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_defaultShaderInfoTexFloat", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_defaultShaderInfoTexARGB8
// Il2CppName: get_defaultShaderInfoTexARGB8
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Texture2D* (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_defaultShaderInfoTexARGB8)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_defaultShaderInfoTexARGB8", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_vertexTexturingIsAvailable
// Il2CppName: get_vertexTexturingIsAvailable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_vertexTexturingIsAvailable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_vertexTexturingIsAvailable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_shaderModelIs35
// Il2CppName: get_shaderModelIs35
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_shaderModelIs35)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_shaderModelIs35", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::InitVertexDeclaration
// Il2CppName: InitVertexDeclaration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::InitVertexDeclaration)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "InitVertexDeclaration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::CompleteCreation
// Il2CppName: CompleteCreation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::CompleteCreation)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "CompleteCreation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_fullyCreated
// Il2CppName: get_fullyCreated
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_fullyCreated)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_fullyCreated", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::get_disposed
// Il2CppName: get_disposed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::get_disposed)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "get_disposed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::set_disposed
// Il2CppName: set_disposed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::set_disposed)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "set_disposed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::Dispose
// Il2CppName: Dispose
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::Dispose)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "Dispose", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::Dispose
// Il2CppName: Dispose
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::Dispose)> {
  static const MethodInfo* get() {
    static auto* disposing = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "Dispose", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{disposing});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::Allocate
// Il2CppName: Allocate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::UIElements::UIR::MeshHandle* (UnityEngine::UIElements::UIR::UIRenderDevice::*)(uint, uint, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>>, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>>, ByRef<uint16_t>)>(&UnityEngine::UIElements::UIR::UIRenderDevice::Allocate)> {
  static const MethodInfo* get() {
    static auto* vertexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* indexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* vertexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "Vertex")})->this_arg;
    static auto* indexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "UInt16")})->this_arg;
    static auto* indexOffset = &::il2cpp_utils::GetClassFromName("System", "UInt16")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "Allocate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{vertexCount, indexCount, vertexData, indexData, indexOffset});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::MeshHandle*, uint, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>>)>(&UnityEngine::UIElements::UIR::UIRenderDevice::Update)> {
  static const MethodInfo* get() {
    static auto* mesh = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "MeshHandle")->byval_arg;
    static auto* vertexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* vertexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "Vertex")})->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mesh, vertexCount, vertexData});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::MeshHandle*, uint, uint, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>>, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>>, ByRef<uint16_t>)>(&UnityEngine::UIElements::UIR::UIRenderDevice::Update)> {
  static const MethodInfo* get() {
    static auto* mesh = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "MeshHandle")->byval_arg;
    static auto* vertexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* indexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* vertexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "Vertex")})->this_arg;
    static auto* indexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "UInt16")})->this_arg;
    static auto* indexOffset = &::il2cpp_utils::GetClassFromName("System", "UInt16")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mesh, vertexCount, indexCount, vertexData, indexData, indexOffset});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::UpdateCopyBackIndices
// Il2CppName: UpdateCopyBackIndices
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::MeshHandle*, bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::UpdateCopyBackIndices)> {
  static const MethodInfo* get() {
    static auto* mesh = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "MeshHandle")->byval_arg;
    static auto* copyBackIndices = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "UpdateCopyBackIndices", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mesh, copyBackIndices});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::ActiveUpdatesForMeshHandle
// Il2CppName: ActiveUpdatesForMeshHandle
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate>* (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::MeshHandle*)>(&UnityEngine::UIElements::UIR::UIRenderDevice::ActiveUpdatesForMeshHandle)> {
  static const MethodInfo* get() {
    static auto* mesh = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "MeshHandle")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "ActiveUpdatesForMeshHandle", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mesh});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::TryAllocFromPage
// Il2CppName: TryAllocFromPage
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::Page*, uint, uint, ByRef<::UnityEngine::UIElements::UIR::Alloc>, ByRef<::UnityEngine::UIElements::UIR::Alloc>, bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::TryAllocFromPage)> {
  static const MethodInfo* get() {
    static auto* page = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "Page")->byval_arg;
    static auto* vertexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* indexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* va = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "Alloc")->this_arg;
    static auto* ia = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "Alloc")->this_arg;
    static auto* shortLived = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "TryAllocFromPage", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{page, vertexCount, indexCount, va, ia, shortLived});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::Allocate
// Il2CppName: Allocate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::MeshHandle*, uint, uint, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>>, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>>, bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::Allocate)> {
  static const MethodInfo* get() {
    static auto* meshHandle = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "MeshHandle")->byval_arg;
    static auto* vertexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* indexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* vertexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "Vertex")})->this_arg;
    static auto* indexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "UInt16")})->this_arg;
    static auto* shortLived = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "Allocate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{meshHandle, vertexCount, indexCount, vertexData, indexData, shortLived});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::UpdateAfterGPUUsedData
// Il2CppName: UpdateAfterGPUUsedData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::MeshHandle*, uint, uint, ByRef<::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::Vertex>>, ByRef<::Unity::Collections::NativeSlice_1<uint16_t>>, ByRef<uint16_t>, ByRef<::UnityEngine::UIElements::UIR::UIRenderDevice::AllocToUpdate>, bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::UpdateAfterGPUUsedData)> {
  static const MethodInfo* get() {
    static auto* mesh = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "MeshHandle")->byval_arg;
    static auto* vertexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* indexCount = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* vertexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine.UIElements", "Vertex")})->this_arg;
    static auto* indexData = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "UInt16")})->this_arg;
    static auto* indexOffset = &::il2cpp_utils::GetClassFromName("System", "UInt16")->this_arg;
    static auto* allocToUpdate = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "UIRenderDevice/AllocToUpdate")->this_arg;
    static auto* copyBackIndices = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "UpdateAfterGPUUsedData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mesh, vertexCount, indexCount, vertexData, indexData, indexOffset, allocToUpdate, copyBackIndices});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::Free
// Il2CppName: Free
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::MeshHandle*)>(&UnityEngine::UIElements::UIR::UIRenderDevice::Free)> {
  static const MethodInfo* get() {
    static auto* mesh = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "MeshHandle")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "Free", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{mesh});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::OnFrameRenderingBegin
// Il2CppName: OnFrameRenderingBegin
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::OnFrameRenderingBegin)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "OnFrameRenderingBegin", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::PtrToSlice
// Il2CppName: PtrToSlice
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::ApplyDrawCommandState
// Il2CppName: ApplyDrawCommandState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::RenderChainCommand*, int, ::UnityEngine::Material*, bool, ByRef<::UnityEngine::UIElements::UIR::UIRenderDevice::EvaluationState>)>(&UnityEngine::UIElements::UIR::UIRenderDevice::ApplyDrawCommandState)> {
  static const MethodInfo* get() {
    static auto* cmd = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "RenderChainCommand")->byval_arg;
    static auto* textureSlot = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* newMat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* newMatDiffers = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* st = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "UIRenderDevice/EvaluationState")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "ApplyDrawCommandState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cmd, textureSlot, newMat, newMatDiffers, st});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::ApplyBatchState
// Il2CppName: ApplyBatchState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(ByRef<::UnityEngine::UIElements::UIR::UIRenderDevice::EvaluationState>, bool)>(&UnityEngine::UIElements::UIR::UIRenderDevice::ApplyBatchState)> {
  static const MethodInfo* get() {
    static auto* st = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "UIRenderDevice/EvaluationState")->this_arg;
    static auto* allowMaterialChange = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "ApplyBatchState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{st, allowMaterialChange});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::EvaluateChain
// Il2CppName: EvaluateChain
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::RenderChainCommand*, ::UnityEngine::Material*, ::UnityEngine::Material*, ::UnityEngine::Texture*, ::UnityEngine::Texture*, float, ::Unity::Collections::NativeSlice_1<::UnityEngine::UIElements::UIR::Transform3x4>, ::Unity::Collections::NativeSlice_1<::UnityEngine::Vector4>, ::UnityEngine::MaterialPropertyBlock*, bool, ByRef<::System::Exception*>)>(&UnityEngine::UIElements::UIR::UIRenderDevice::EvaluateChain)> {
  static const MethodInfo* get() {
    static auto* head = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "RenderChainCommand")->byval_arg;
    static auto* initialMat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* defaultMat = &::il2cpp_utils::GetClassFromName("UnityEngine", "Material")->byval_arg;
    static auto* gradientSettings = &::il2cpp_utils::GetClassFromName("UnityEngine", "Texture")->byval_arg;
    static auto* shaderInfo = &::il2cpp_utils::GetClassFromName("UnityEngine", "Texture")->byval_arg;
    static auto* pixelsPerPoint = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* transforms = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "Transform3x4")})->byval_arg;
    static auto* clipRects = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("Unity.Collections", "NativeSlice`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "Vector4")})->byval_arg;
    static auto* stateMatProps = &::il2cpp_utils::GetClassFromName("UnityEngine", "MaterialPropertyBlock")->byval_arg;
    static auto* allowMaterialChange = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* immediateException = &::il2cpp_utils::GetClassFromName("System", "Exception")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "EvaluateChain", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{head, initialMat, defaultMat, gradientSettings, shaderInfo, pixelsPerPoint, transforms, clipRects, stateMatProps, allowMaterialChange, immediateException});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::UpdateFenceValue
// Il2CppName: UpdateFenceValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::UpdateFenceValue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "UpdateFenceValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::KickRanges
// Il2CppName: KickRanges
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(::UnityEngine::UIElements::UIR::DrawBufferRange*, ByRef<int>, ByRef<int>, int, ::UnityEngine::UIElements::UIR::Page*)>(&UnityEngine::UIElements::UIR::UIRenderDevice::KickRanges)> {
  static const MethodInfo* get() {
    static auto* ranges = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "DrawBufferRange"))->byval_arg;
    static auto* rangesReady = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* rangesStart = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* rangesCount = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* curPage = &::il2cpp_utils::GetClassFromName("UnityEngine.UIElements.UIR", "Page")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "KickRanges", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ranges, rangesReady, rangesStart, rangesCount, curPage});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::DrawRanges
// Il2CppName: DrawRanges
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::WaitOnCpuFence
// Il2CppName: WaitOnCpuFence
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)(uint)>(&UnityEngine::UIElements::UIR::UIRenderDevice::WaitOnCpuFence)> {
  static const MethodInfo* get() {
    static auto* fence = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "WaitOnCpuFence", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{fence});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::AdvanceFrame
// Il2CppName: AdvanceFrame
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::AdvanceFrame)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "AdvanceFrame", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::PruneUnusedPages
// Il2CppName: PruneUnusedPages
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::PruneUnusedPages)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "PruneUnusedPages", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::PrepareForGfxDeviceRecreate
// Il2CppName: PrepareForGfxDeviceRecreate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::PrepareForGfxDeviceRecreate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "PrepareForGfxDeviceRecreate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::WrapUpGfxDeviceRecreate
// Il2CppName: WrapUpGfxDeviceRecreate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::WrapUpGfxDeviceRecreate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "WrapUpGfxDeviceRecreate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::FlushAllPendingDeviceDisposes
// Il2CppName: FlushAllPendingDeviceDisposes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::FlushAllPendingDeviceDisposes)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "FlushAllPendingDeviceDisposes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::GatherDrawStatistics
// Il2CppName: GatherDrawStatistics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::UIElements::UIR::UIRenderDevice::DrawStatistics (UnityEngine::UIElements::UIR::UIRenderDevice::*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::GatherDrawStatistics)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "GatherDrawStatistics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::ProcessDeviceFreeQueue
// Il2CppName: ProcessDeviceFreeQueue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::ProcessDeviceFreeQueue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "ProcessDeviceFreeQueue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::OnEngineUpdateGlobal
// Il2CppName: OnEngineUpdateGlobal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::OnEngineUpdateGlobal)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "OnEngineUpdateGlobal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: UnityEngine::UIElements::UIR::UIRenderDevice::OnFlushPendingResources
// Il2CppName: OnFlushPendingResources
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::UIElements::UIR::UIRenderDevice::OnFlushPendingResources)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::UIElements::UIR::UIRenderDevice*), "OnFlushPendingResources", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
