// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
  // Forward declaring type: Stack`1<T>
  template<typename T>
  class Stack_1;
}
// Completed forward declares
// Type namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: ExpressionEvaluator
  class ExpressionEvaluator;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::UnityEngine::ExpressionEvaluator);
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ExpressionEvaluator*, "UnityEngine", "ExpressionEvaluator");
// Type namespace: UnityEngine
namespace UnityEngine {
  // Size: 0x10
  #pragma pack(push, 1)
  // Autogenerated type: UnityEngine.ExpressionEvaluator
  // [TokenAttribute] Offset: FFFFFFFF
  // [MovedFromAttribute] Offset: FFFFFFFF
  class ExpressionEvaluator : public ::Il2CppObject {
    public:
    // Nested type: ::UnityEngine::ExpressionEvaluator::Expression
    class Expression;
    // Nested type: ::UnityEngine::ExpressionEvaluator::PcgRandom
    struct PcgRandom;
    // Nested type: ::UnityEngine::ExpressionEvaluator::Op
    struct Op;
    // Nested type: ::UnityEngine::ExpressionEvaluator::Associativity
    struct Associativity;
    // Nested type: ::UnityEngine::ExpressionEvaluator::Operator
    class Operator;
    // Nested type: ::UnityEngine::ExpressionEvaluator::$$c
    class $$c;
    // Size: 0x10
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: UnityEngine.ExpressionEvaluator/PcgRandom
    // [TokenAttribute] Offset: FFFFFFFF
    struct PcgRandom/*, public ::System::ValueType*/ {
      public:
      public:
      // private readonly System.UInt64 increment
      // Size: 0x8
      // Offset: 0x0
      uint64_t increment;
      // Field size check
      static_assert(sizeof(uint64_t) == 0x8);
      // private System.UInt64 state
      // Size: 0x8
      // Offset: 0x8
      uint64_t state;
      // Field size check
      static_assert(sizeof(uint64_t) == 0x8);
      public:
      // Creating value type constructor for type: PcgRandom
      constexpr PcgRandom(uint64_t increment_ = {}, uint64_t state_ = {}) noexcept : increment{increment_}, state{state_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: private readonly System.UInt64 increment
      [[deprecated("Use field access instead!")]] uint64_t& dyn_increment();
      // Get instance field reference: private System.UInt64 state
      [[deprecated("Use field access instead!")]] uint64_t& dyn_state();
      // public System.Void .ctor(System.UInt64 state, System.UInt64 sequence)
      // Offset: 0x5484C34
      // ABORTED: conflicts with another method.  PcgRandom(uint64_t state, uint64_t sequence);
      // public System.UInt32 GetUInt()
      // Offset: 0x5484688
      uint GetUInt();
      // static private System.UInt32 RotateRight(System.UInt32 v, System.Int32 rot)
      // Offset: 0x5484D60
      static uint RotateRight(uint v, int rot);
      // static private System.UInt32 XshRr(System.UInt64 s)
      // Offset: 0x5484D48
      static uint XshRr(uint64_t s);
      // private System.Void Step()
      // Offset: 0x5484D28
      void Step();
    }; // UnityEngine.ExpressionEvaluator/PcgRandom
    #pragma pack(pop)
    static check_size<sizeof(ExpressionEvaluator::PcgRandom), 8 + sizeof(uint64_t)> __UnityEngine_ExpressionEvaluator_PcgRandomSizeCheck;
    static_assert(sizeof(ExpressionEvaluator::PcgRandom) == 0x10);
    // Get static field: static private UnityEngine.ExpressionEvaluator/PcgRandom s_Random
    static ::UnityEngine::ExpressionEvaluator::PcgRandom _get_s_Random();
    // Set static field: static private UnityEngine.ExpressionEvaluator/PcgRandom s_Random
    static void _set_s_Random(::UnityEngine::ExpressionEvaluator::PcgRandom value);
    // Get static field: static private System.Collections.Generic.Dictionary`2<System.String,UnityEngine.ExpressionEvaluator/Operator> s_Operators
    static ::System::Collections::Generic::Dictionary_2<::StringW, ::UnityEngine::ExpressionEvaluator::Operator*>* _get_s_Operators();
    // Set static field: static private System.Collections.Generic.Dictionary`2<System.String,UnityEngine.ExpressionEvaluator/Operator> s_Operators
    static void _set_s_Operators(::System::Collections::Generic::Dictionary_2<::StringW, ::UnityEngine::ExpressionEvaluator::Operator*>* value);
    // static System.Boolean Evaluate(System.String expression, out T value, out UnityEngine.ExpressionEvaluator/Expression delayed)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static bool Evaluate(::StringW expression, ByRef<T> value, ByRef<::UnityEngine::ExpressionEvaluator::Expression*> delayed) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::ExpressionEvaluator::Evaluate");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("UnityEngine", "ExpressionEvaluator", "Evaluate", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(expression), ::il2cpp_utils::ExtractIndependentType<T&>(), ::il2cpp_utils::ExtractIndependentType<::UnityEngine::ExpressionEvaluator::Expression*&>()})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, expression, byref(value), byref(delayed));
    }
    // static private System.Boolean EvaluateTokens(System.String[] tokens, ref T value, System.Int32 index, System.Int32 count)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static bool EvaluateTokens(::ArrayW<::StringW> tokens, ByRef<T> value, int index, int count) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::ExpressionEvaluator::EvaluateTokens");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("UnityEngine", "ExpressionEvaluator", "EvaluateTokens", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(tokens), ::il2cpp_utils::ExtractType(value), ::il2cpp_utils::ExtractType(index), ::il2cpp_utils::ExtractType(count)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, tokens, byref(value), index, count);
    }
    // static private System.Boolean EvaluateDouble(System.String[] tokens, ref System.Double value, System.Int32 index, System.Int32 count)
    // Offset: 0x5482F60
    static bool EvaluateDouble(::ArrayW<::StringW> tokens, ByRef<double> value, int index, int count);
    // static private System.String[] InfixToRPN(System.String[] tokens)
    // Offset: 0x54839B8
    static ::ArrayW<::StringW> InfixToRPN(::ArrayW<::StringW> tokens);
    // static private System.Boolean NeedToPop(System.Collections.Generic.Stack`1<System.String> operatorStack, UnityEngine.ExpressionEvaluator/Operator newOperator)
    // Offset: 0x5483E24
    static bool NeedToPop(::System::Collections::Generic::Stack_1<::StringW>* operatorStack, ::UnityEngine::ExpressionEvaluator::Operator* newOperator);
    // static private System.String[] ExpressionToTokens(System.String expression, out System.Boolean hasVariables)
    // Offset: 0x5483F0C
    static ::ArrayW<::StringW> ExpressionToTokens(::StringW expression, ByRef<bool> hasVariables);
    // static private System.Boolean IsCommand(System.String token)
    // Offset: 0x5483550
    static bool IsCommand(::StringW token);
    // static private System.Boolean IsVariable(System.String token)
    // Offset: 0x5483950
    static bool IsVariable(::StringW token);
    // static private System.Boolean IsDelayedFunction(System.String token)
    // Offset: 0x5483DB8
    static bool IsDelayedFunction(::StringW token);
    // static private System.Boolean IsOperator(System.String token)
    // Offset: 0x5483430
    static bool IsOperator(::StringW token);
    // static private UnityEngine.ExpressionEvaluator/Operator TokenToOperator(System.String token)
    // Offset: 0x54834B0
    static ::UnityEngine::ExpressionEvaluator::Operator* TokenToOperator(::StringW token);
    // static private System.String PreFormatExpression(System.String expression)
    // Offset: 0x5484330
    static ::StringW PreFormatExpression(::StringW expression);
    // static private System.String[] FixUnaryOperators(System.String[] tokens)
    // Offset: 0x54844F0
    static ::ArrayW<::StringW> FixUnaryOperators(::ArrayW<::StringW> tokens);
    // static private System.Double EvaluateOp(System.Double[] values, UnityEngine.ExpressionEvaluator/Op op, System.Int32 index, System.Int32 count)
    // Offset: 0x54835FC
    static double EvaluateOp(::ArrayW<double> values, ::UnityEngine::ExpressionEvaluator::Op op, int index, int count);
    // static private System.Boolean TryParse(System.String expression, out T result)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static bool TryParse(::StringW expression, ByRef<T> result) {
      static auto ___internal__logger = ::Logger::get().WithContext("::UnityEngine::ExpressionEvaluator::TryParse");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("UnityEngine", "ExpressionEvaluator", "TryParse", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(expression), ::il2cpp_utils::ExtractIndependentType<T&>()})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, expression, byref(result));
    }
    // static private System.Void .cctor()
    // Offset: 0x54846C0
    static void _cctor();
  }; // UnityEngine.ExpressionEvaluator
  #pragma pack(pop)
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::UnityEngine::ExpressionEvaluator::PcgRandom, "UnityEngine", "ExpressionEvaluator/PcgRandom");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::Evaluate
// Il2CppName: Evaluate
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::EvaluateTokens
// Il2CppName: EvaluateTokens
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::EvaluateDouble
// Il2CppName: EvaluateDouble
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::ArrayW<::StringW>, ByRef<double>, int, int)>(&UnityEngine::ExpressionEvaluator::EvaluateDouble)> {
  static const MethodInfo* get() {
    static auto* tokens = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "String"), 1)->byval_arg;
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Double")->this_arg;
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* count = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "EvaluateDouble", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tokens, value, index, count});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::InfixToRPN
// Il2CppName: InfixToRPN
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::StringW> (*)(::ArrayW<::StringW>)>(&UnityEngine::ExpressionEvaluator::InfixToRPN)> {
  static const MethodInfo* get() {
    static auto* tokens = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "String"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "InfixToRPN", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tokens});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::NeedToPop
// Il2CppName: NeedToPop
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Collections::Generic::Stack_1<::StringW>*, ::UnityEngine::ExpressionEvaluator::Operator*)>(&UnityEngine::ExpressionEvaluator::NeedToPop)> {
  static const MethodInfo* get() {
    static auto* operatorStack = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "Stack`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "String")})->byval_arg;
    static auto* newOperator = &::il2cpp_utils::GetClassFromName("UnityEngine", "ExpressionEvaluator/Operator")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "NeedToPop", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{operatorStack, newOperator});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::ExpressionToTokens
// Il2CppName: ExpressionToTokens
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::StringW> (*)(::StringW, ByRef<bool>)>(&UnityEngine::ExpressionEvaluator::ExpressionToTokens)> {
  static const MethodInfo* get() {
    static auto* expression = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* hasVariables = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "ExpressionToTokens", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expression, hasVariables});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::IsCommand
// Il2CppName: IsCommand
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&UnityEngine::ExpressionEvaluator::IsCommand)> {
  static const MethodInfo* get() {
    static auto* token = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "IsCommand", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{token});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::IsVariable
// Il2CppName: IsVariable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&UnityEngine::ExpressionEvaluator::IsVariable)> {
  static const MethodInfo* get() {
    static auto* token = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "IsVariable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{token});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::IsDelayedFunction
// Il2CppName: IsDelayedFunction
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&UnityEngine::ExpressionEvaluator::IsDelayedFunction)> {
  static const MethodInfo* get() {
    static auto* token = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "IsDelayedFunction", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{token});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::IsOperator
// Il2CppName: IsOperator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&UnityEngine::ExpressionEvaluator::IsOperator)> {
  static const MethodInfo* get() {
    static auto* token = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "IsOperator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{token});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::TokenToOperator
// Il2CppName: TokenToOperator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::ExpressionEvaluator::Operator* (*)(::StringW)>(&UnityEngine::ExpressionEvaluator::TokenToOperator)> {
  static const MethodInfo* get() {
    static auto* token = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "TokenToOperator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{token});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::PreFormatExpression
// Il2CppName: PreFormatExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)(::StringW)>(&UnityEngine::ExpressionEvaluator::PreFormatExpression)> {
  static const MethodInfo* get() {
    static auto* expression = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "PreFormatExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expression});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::FixUnaryOperators
// Il2CppName: FixUnaryOperators
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::StringW> (*)(::ArrayW<::StringW>)>(&UnityEngine::ExpressionEvaluator::FixUnaryOperators)> {
  static const MethodInfo* get() {
    static auto* tokens = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "String"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "FixUnaryOperators", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tokens});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::EvaluateOp
// Il2CppName: EvaluateOp
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<double (*)(::ArrayW<double>, ::UnityEngine::ExpressionEvaluator::Op, int, int)>(&UnityEngine::ExpressionEvaluator::EvaluateOp)> {
  static const MethodInfo* get() {
    static auto* values = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Double"), 1)->byval_arg;
    static auto* op = &::il2cpp_utils::GetClassFromName("UnityEngine", "ExpressionEvaluator/Op")->byval_arg;
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* count = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), "EvaluateOp", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{values, op, index, count});
  }
};
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::TryParse
// Il2CppName: TryParse
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: UnityEngine::ExpressionEvaluator::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&UnityEngine::ExpressionEvaluator::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(UnityEngine::ExpressionEvaluator*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
