// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Cinemachine.CinemachineImpulseManager/EnvelopeDefinition
#include "Cinemachine/CinemachineImpulseManager_EnvelopeDefinition.hpp"
// Including type: Cinemachine.CinemachineImpulseManager/ImpulseEvent/DirectionMode
#include "Cinemachine/CinemachineImpulseManager_ImpulseEvent.hpp"
// Including type: Cinemachine.CinemachineImpulseManager/ImpulseEvent/DissipationMode
// Already included the same include: Cinemachine/CinemachineImpulseManager_ImpulseEvent.hpp
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: AnimationCurve
  class AnimationCurve;
  // Forward declaring type: Vector3
  struct Vector3;
}
// Forward declaring namespace: Cinemachine
namespace Cinemachine {
  // Forward declaring type: SignalSourceAsset
  class SignalSourceAsset;
  // Skipping declaration: ImpulseShapes because it is already included!
}
// Completed forward declares
// Type namespace: Cinemachine
namespace Cinemachine {
  // Forward declaring type: CinemachineImpulseDefinition
  class CinemachineImpulseDefinition;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Cinemachine::CinemachineImpulseDefinition);
DEFINE_IL2CPP_ARG_TYPE(::Cinemachine::CinemachineImpulseDefinition*, "Cinemachine", "CinemachineImpulseDefinition");
// Type namespace: Cinemachine
namespace Cinemachine {
  // Size: 0x7C
  #pragma pack(push, 1)
  // Autogenerated type: Cinemachine.CinemachineImpulseDefinition
  // [TokenAttribute] Offset: FFFFFFFF
  // [DocumentationSortingAttribute] Offset: FFFFFFFF
  class CinemachineImpulseDefinition : public ::Il2CppObject {
    public:
    // Nested type: ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes
    struct ImpulseShapes;
    // Nested type: ::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes
    struct ImpulseTypes;
    // Nested type: ::Cinemachine::CinemachineImpulseDefinition::RepeatMode
    struct RepeatMode;
    // Nested type: ::Cinemachine::CinemachineImpulseDefinition::SignalSource
    class SignalSource;
    // Nested type: ::Cinemachine::CinemachineImpulseDefinition::LegacySignalSource
    class LegacySignalSource;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Cinemachine.CinemachineImpulseDefinition/ImpulseShapes
    // [TokenAttribute] Offset: FFFFFFFF
    struct ImpulseShapes/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: ImpulseShapes
      constexpr ImpulseShapes(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Custom
      static constexpr const int Custom = 0;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Custom
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes _get_Custom();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Custom
      static void _set_Custom(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Recoil
      static constexpr const int Recoil = 1;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Recoil
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes _get_Recoil();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Recoil
      static void _set_Recoil(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Bump
      static constexpr const int Bump = 2;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Bump
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes _get_Bump();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Bump
      static void _set_Bump(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Explosion
      static constexpr const int Explosion = 3;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Explosion
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes _get_Explosion();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Explosion
      static void _set_Explosion(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Rumble
      static constexpr const int Rumble = 4;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Rumble
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes _get_Rumble();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes Rumble
      static void _set_Rumble(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Cinemachine.CinemachineImpulseDefinition/ImpulseShapes
    #pragma pack(pop)
    static check_size<sizeof(CinemachineImpulseDefinition::ImpulseShapes), 0 + sizeof(int)> __Cinemachine_CinemachineImpulseDefinition_ImpulseShapesSizeCheck;
    static_assert(sizeof(CinemachineImpulseDefinition::ImpulseShapes) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Cinemachine.CinemachineImpulseDefinition/ImpulseTypes
    // [TokenAttribute] Offset: FFFFFFFF
    struct ImpulseTypes/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: ImpulseTypes
      constexpr ImpulseTypes(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Uniform
      static constexpr const int Uniform = 0;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Uniform
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes _get_Uniform();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Uniform
      static void _set_Uniform(::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Dissipating
      static constexpr const int Dissipating = 1;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Dissipating
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes _get_Dissipating();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Dissipating
      static void _set_Dissipating(::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Propagating
      static constexpr const int Propagating = 2;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Propagating
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes _get_Propagating();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Propagating
      static void _set_Propagating(::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Legacy
      static constexpr const int Legacy = 3;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Legacy
      static ::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes _get_Legacy();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes Legacy
      static void _set_Legacy(::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Cinemachine.CinemachineImpulseDefinition/ImpulseTypes
    #pragma pack(pop)
    static check_size<sizeof(CinemachineImpulseDefinition::ImpulseTypes), 0 + sizeof(int)> __Cinemachine_CinemachineImpulseDefinition_ImpulseTypesSizeCheck;
    static_assert(sizeof(CinemachineImpulseDefinition::ImpulseTypes) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Cinemachine.CinemachineImpulseDefinition/RepeatMode
    // [TokenAttribute] Offset: FFFFFFFF
    struct RepeatMode/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: RepeatMode
      constexpr RepeatMode(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Stretch
      static constexpr const int Stretch = 0;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Stretch
      static ::Cinemachine::CinemachineImpulseDefinition::RepeatMode _get_Stretch();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Stretch
      static void _set_Stretch(::Cinemachine::CinemachineImpulseDefinition::RepeatMode value);
      // static field const value: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Loop
      static constexpr const int Loop = 1;
      // Get static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Loop
      static ::Cinemachine::CinemachineImpulseDefinition::RepeatMode _get_Loop();
      // Set static field: static public Cinemachine.CinemachineImpulseDefinition/RepeatMode Loop
      static void _set_Loop(::Cinemachine::CinemachineImpulseDefinition::RepeatMode value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Cinemachine.CinemachineImpulseDefinition/RepeatMode
    #pragma pack(pop)
    static check_size<sizeof(CinemachineImpulseDefinition::RepeatMode), 0 + sizeof(int)> __Cinemachine_CinemachineImpulseDefinition_RepeatModeSizeCheck;
    static_assert(sizeof(CinemachineImpulseDefinition::RepeatMode) == 0x4);
    public:
    // public System.Int32 m_ImpulseChannel
    // Size: 0x4
    // Offset: 0x10
    int m_ImpulseChannel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes m_ImpulseShape
    // Size: 0x4
    // Offset: 0x14
    ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes m_ImpulseShape;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes) == 0x4);
    // public UnityEngine.AnimationCurve m_CustomImpulseShape
    // Size: 0x8
    // Offset: 0x18
    ::UnityEngine::AnimationCurve* m_CustomImpulseShape;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // public System.Single m_ImpulseDuration
    // Size: 0x4
    // Offset: 0x20
    float m_ImpulseDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes m_ImpulseType
    // Size: 0x4
    // Offset: 0x24
    ::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes m_ImpulseType;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes) == 0x4);
    // public System.Single m_DissipationRate
    // Size: 0x4
    // Offset: 0x28
    float m_DissipationRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: m_DissipationRate and: m_RawSignal
    char __padding5[0x4] = {};
    // public Cinemachine.SignalSourceAsset m_RawSignal
    // Size: 0x8
    // Offset: 0x30
    ::Cinemachine::SignalSourceAsset* m_RawSignal;
    // Field size check
    static_assert(sizeof(::Cinemachine::SignalSourceAsset*) == 0x8);
    // public System.Single m_AmplitudeGain
    // Size: 0x4
    // Offset: 0x38
    float m_AmplitudeGain;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single m_FrequencyGain
    // Size: 0x4
    // Offset: 0x3C
    float m_FrequencyGain;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public Cinemachine.CinemachineImpulseDefinition/RepeatMode m_RepeatMode
    // Size: 0x4
    // Offset: 0x40
    ::Cinemachine::CinemachineImpulseDefinition::RepeatMode m_RepeatMode;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseDefinition::RepeatMode) == 0x4);
    // public System.Boolean m_Randomize
    // Size: 0x1
    // Offset: 0x44
    bool m_Randomize;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: m_Randomize and: m_TimeEnvelope
    char __padding10[0x3] = {};
    // public Cinemachine.CinemachineImpulseManager/EnvelopeDefinition m_TimeEnvelope
    // Size: 0x1E
    // Offset: 0x48
    ::Cinemachine::CinemachineImpulseManager::EnvelopeDefinition m_TimeEnvelope;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseManager::EnvelopeDefinition) == 0x1E);
    // Padding between fields: m_TimeEnvelope and: m_ImpactRadius
    char __padding11[0x2] = {};
    // public System.Single m_ImpactRadius
    // Size: 0x4
    // Offset: 0x68
    float m_ImpactRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DirectionMode m_DirectionMode
    // Size: 0x4
    // Offset: 0x6C
    ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DirectionMode m_DirectionMode;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DirectionMode) == 0x4);
    // public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DissipationMode m_DissipationMode
    // Size: 0x4
    // Offset: 0x70
    ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DissipationMode m_DissipationMode;
    // Field size check
    static_assert(sizeof(::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DissipationMode) == 0x4);
    // public System.Single m_DissipationDistance
    // Size: 0x4
    // Offset: 0x74
    float m_DissipationDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single m_PropagationSpeed
    // Size: 0x4
    // Offset: 0x78
    float m_PropagationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    public:
    // Get static field: static private UnityEngine.AnimationCurve[] sStandardShapes
    static ::ArrayW<::UnityEngine::AnimationCurve*> _get_sStandardShapes();
    // Set static field: static private UnityEngine.AnimationCurve[] sStandardShapes
    static void _set_sStandardShapes(::ArrayW<::UnityEngine::AnimationCurve*> value);
    // Get instance field reference: public System.Int32 m_ImpulseChannel
    [[deprecated("Use field access instead!")]] int& dyn_m_ImpulseChannel();
    // Get instance field reference: public Cinemachine.CinemachineImpulseDefinition/ImpulseShapes m_ImpulseShape
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes& dyn_m_ImpulseShape();
    // Get instance field reference: public UnityEngine.AnimationCurve m_CustomImpulseShape
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn_m_CustomImpulseShape();
    // Get instance field reference: public System.Single m_ImpulseDuration
    [[deprecated("Use field access instead!")]] float& dyn_m_ImpulseDuration();
    // Get instance field reference: public Cinemachine.CinemachineImpulseDefinition/ImpulseTypes m_ImpulseType
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes& dyn_m_ImpulseType();
    // Get instance field reference: public System.Single m_DissipationRate
    [[deprecated("Use field access instead!")]] float& dyn_m_DissipationRate();
    // Get instance field reference: public Cinemachine.SignalSourceAsset m_RawSignal
    [[deprecated("Use field access instead!")]] ::Cinemachine::SignalSourceAsset*& dyn_m_RawSignal();
    // Get instance field reference: public System.Single m_AmplitudeGain
    [[deprecated("Use field access instead!")]] float& dyn_m_AmplitudeGain();
    // Get instance field reference: public System.Single m_FrequencyGain
    [[deprecated("Use field access instead!")]] float& dyn_m_FrequencyGain();
    // Get instance field reference: public Cinemachine.CinemachineImpulseDefinition/RepeatMode m_RepeatMode
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseDefinition::RepeatMode& dyn_m_RepeatMode();
    // Get instance field reference: public System.Boolean m_Randomize
    [[deprecated("Use field access instead!")]] bool& dyn_m_Randomize();
    // Get instance field reference: public Cinemachine.CinemachineImpulseManager/EnvelopeDefinition m_TimeEnvelope
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseManager::EnvelopeDefinition& dyn_m_TimeEnvelope();
    // Get instance field reference: public System.Single m_ImpactRadius
    [[deprecated("Use field access instead!")]] float& dyn_m_ImpactRadius();
    // Get instance field reference: public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DirectionMode m_DirectionMode
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DirectionMode& dyn_m_DirectionMode();
    // Get instance field reference: public Cinemachine.CinemachineImpulseManager/ImpulseEvent/DissipationMode m_DissipationMode
    [[deprecated("Use field access instead!")]] ::Cinemachine::CinemachineImpulseManager::ImpulseEvent::DissipationMode& dyn_m_DissipationMode();
    // Get instance field reference: public System.Single m_DissipationDistance
    [[deprecated("Use field access instead!")]] float& dyn_m_DissipationDistance();
    // Get instance field reference: public System.Single m_PropagationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_m_PropagationSpeed();
    // public System.Void OnValidate()
    // Offset: 0x2AB887C
    void OnValidate();
    // static private System.Void CreateStandardShapes()
    // Offset: 0x2AB8970
    static void CreateStandardShapes();
    // static UnityEngine.AnimationCurve GetStandardCurve(Cinemachine.CinemachineImpulseDefinition/ImpulseShapes shape)
    // Offset: 0x2AB975C
    static ::UnityEngine::AnimationCurve* GetStandardCurve(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes shape);
    // UnityEngine.AnimationCurve get_ImpulseCurve()
    // Offset: 0x2AB97DC
    ::UnityEngine::AnimationCurve* get_ImpulseCurve();
    // public System.Void CreateEvent(UnityEngine.Vector3 position, UnityEngine.Vector3 velocity)
    // Offset: 0x2AB982C
    void CreateEvent(::UnityEngine::Vector3 position, ::UnityEngine::Vector3 velocity);
    // public Cinemachine.CinemachineImpulseManager/ImpulseEvent CreateAndReturnEvent(UnityEngine.Vector3 position, UnityEngine.Vector3 velocity)
    // Offset: 0x2AB9830
    ::Cinemachine::CinemachineImpulseManager::ImpulseEvent* CreateAndReturnEvent(::UnityEngine::Vector3 position, ::UnityEngine::Vector3 velocity);
    // private Cinemachine.CinemachineImpulseManager/ImpulseEvent LegacyCreateAndReturnEvent(UnityEngine.Vector3 position, UnityEngine.Vector3 velocity)
    // Offset: 0x2AB9A48
    ::Cinemachine::CinemachineImpulseManager::ImpulseEvent* LegacyCreateAndReturnEvent(::UnityEngine::Vector3 position, ::UnityEngine::Vector3 velocity);
    // public System.Void .ctor()
    // Offset: 0x2ABA044
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static CinemachineImpulseDefinition* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Cinemachine::CinemachineImpulseDefinition::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<CinemachineImpulseDefinition*, creationType>()));
    }
  }; // Cinemachine.CinemachineImpulseDefinition
  #pragma pack(pop)
  static check_size<sizeof(CinemachineImpulseDefinition), 120 + sizeof(float)> __Cinemachine_CinemachineImpulseDefinitionSizeCheck;
  static_assert(sizeof(CinemachineImpulseDefinition) == 0x7C);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Cinemachine::CinemachineImpulseDefinition::RepeatMode, "Cinemachine", "CinemachineImpulseDefinition/RepeatMode");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Cinemachine::CinemachineImpulseDefinition::ImpulseTypes, "Cinemachine", "CinemachineImpulseDefinition/ImpulseTypes");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes, "Cinemachine", "CinemachineImpulseDefinition/ImpulseShapes");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::OnValidate
// Il2CppName: OnValidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Cinemachine::CinemachineImpulseDefinition::*)()>(&Cinemachine::CinemachineImpulseDefinition::OnValidate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "OnValidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::CreateStandardShapes
// Il2CppName: CreateStandardShapes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Cinemachine::CinemachineImpulseDefinition::CreateStandardShapes)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "CreateStandardShapes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::GetStandardCurve
// Il2CppName: GetStandardCurve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::AnimationCurve* (*)(::Cinemachine::CinemachineImpulseDefinition::ImpulseShapes)>(&Cinemachine::CinemachineImpulseDefinition::GetStandardCurve)> {
  static const MethodInfo* get() {
    static auto* shape = &::il2cpp_utils::GetClassFromName("Cinemachine", "CinemachineImpulseDefinition/ImpulseShapes")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "GetStandardCurve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{shape});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::get_ImpulseCurve
// Il2CppName: get_ImpulseCurve
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::AnimationCurve* (Cinemachine::CinemachineImpulseDefinition::*)()>(&Cinemachine::CinemachineImpulseDefinition::get_ImpulseCurve)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "get_ImpulseCurve", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::CreateEvent
// Il2CppName: CreateEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Cinemachine::CinemachineImpulseDefinition::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&Cinemachine::CinemachineImpulseDefinition::CreateEvent)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* velocity = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "CreateEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position, velocity});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::CreateAndReturnEvent
// Il2CppName: CreateAndReturnEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Cinemachine::CinemachineImpulseManager::ImpulseEvent* (Cinemachine::CinemachineImpulseDefinition::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&Cinemachine::CinemachineImpulseDefinition::CreateAndReturnEvent)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* velocity = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "CreateAndReturnEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position, velocity});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::LegacyCreateAndReturnEvent
// Il2CppName: LegacyCreateAndReturnEvent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Cinemachine::CinemachineImpulseManager::ImpulseEvent* (Cinemachine::CinemachineImpulseDefinition::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&Cinemachine::CinemachineImpulseDefinition::LegacyCreateAndReturnEvent)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* velocity = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Cinemachine::CinemachineImpulseDefinition*), "LegacyCreateAndReturnEvent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position, velocity});
  }
};
// Writing MetadataGetter for method: Cinemachine::CinemachineImpulseDefinition::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
