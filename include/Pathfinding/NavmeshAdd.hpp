// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Pathfinding.NavmeshClipper
#include "Pathfinding/NavmeshClipper.hpp"
// Including type: UnityEngine.Vector2
#include "UnityEngine/Vector2.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: Pathfinding.Int3
#include "Pathfinding/Int3.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Mesh
  class Mesh;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: Rect
  struct Rect;
}
// Forward declaring namespace: Pathfinding::Util
namespace Pathfinding::Util {
  // Forward declaring type: GraphTransform
  class GraphTransform;
}
// Completed forward declares
// Type namespace: Pathfinding
namespace Pathfinding {
  // Forward declaring type: NavmeshAdd
  class NavmeshAdd;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Pathfinding::NavmeshAdd);
DEFINE_IL2CPP_ARG_TYPE(::Pathfinding::NavmeshAdd*, "Pathfinding", "NavmeshAdd");
// Type namespace: Pathfinding
namespace Pathfinding {
  // Size: 0x94
  #pragma pack(push, 1)
  // Autogenerated type: Pathfinding.NavmeshAdd
  // [TokenAttribute] Offset: FFFFFFFF
  // [HelpURLAttribute] Offset: FFFFFFFF
  class NavmeshAdd : public ::Pathfinding::NavmeshClipper {
    public:
    // Nested type: ::Pathfinding::NavmeshAdd::MeshType
    struct MeshType;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Pathfinding.NavmeshAdd/MeshType
    // [TokenAttribute] Offset: FFFFFFFF
    struct MeshType/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: MeshType
      constexpr MeshType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Pathfinding.NavmeshAdd/MeshType Rectangle
      static constexpr const int Rectangle = 0;
      // Get static field: static public Pathfinding.NavmeshAdd/MeshType Rectangle
      static ::Pathfinding::NavmeshAdd::MeshType _get_Rectangle();
      // Set static field: static public Pathfinding.NavmeshAdd/MeshType Rectangle
      static void _set_Rectangle(::Pathfinding::NavmeshAdd::MeshType value);
      // static field const value: static public Pathfinding.NavmeshAdd/MeshType CustomMesh
      static constexpr const int CustomMesh = 1;
      // Get static field: static public Pathfinding.NavmeshAdd/MeshType CustomMesh
      static ::Pathfinding::NavmeshAdd::MeshType _get_CustomMesh();
      // Set static field: static public Pathfinding.NavmeshAdd/MeshType CustomMesh
      static void _set_CustomMesh(::Pathfinding::NavmeshAdd::MeshType value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Pathfinding.NavmeshAdd/MeshType
    #pragma pack(pop)
    static check_size<sizeof(NavmeshAdd::MeshType), 0 + sizeof(int)> __Pathfinding_NavmeshAdd_MeshTypeSizeCheck;
    static_assert(sizeof(NavmeshAdd::MeshType) == 0x4);
    public:
    // public Pathfinding.NavmeshAdd/MeshType type
    // Size: 0x4
    // Offset: 0x2C
    ::Pathfinding::NavmeshAdd::MeshType type;
    // Field size check
    static_assert(sizeof(::Pathfinding::NavmeshAdd::MeshType) == 0x4);
    // public UnityEngine.Mesh mesh
    // Size: 0x8
    // Offset: 0x30
    ::UnityEngine::Mesh* mesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::Mesh*) == 0x8);
    // private UnityEngine.Vector3[] verts
    // Size: 0x8
    // Offset: 0x38
    ::ArrayW<::UnityEngine::Vector3> verts;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private System.Int32[] tris
    // Size: 0x8
    // Offset: 0x40
    ::ArrayW<int> tris;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public UnityEngine.Vector2 rectangleSize
    // Size: 0x8
    // Offset: 0x48
    ::UnityEngine::Vector2 rectangleSize;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // public System.Single meshScale
    // Size: 0x4
    // Offset: 0x50
    float meshScale;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Vector3 center
    // Size: 0xC
    // Offset: 0x54
    ::UnityEngine::Vector3 center;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public System.Boolean useRotationAndScale
    // Size: 0x1
    // Offset: 0x60
    bool useRotationAndScale;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: useRotationAndScale and: updateDistance
    char __padding7[0x3] = {};
    // public System.Single updateDistance
    // Size: 0x4
    // Offset: 0x64
    float updateDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single updateRotationDistance
    // Size: 0x4
    // Offset: 0x68
    float updateRotationDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: updateRotationDistance and: tr
    char __padding9[0x4] = {};
    // protected UnityEngine.Transform tr
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::Transform* tr;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private UnityEngine.Vector3 lastPosition
    // Size: 0xC
    // Offset: 0x78
    ::UnityEngine::Vector3 lastPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion lastRotation
    // Size: 0x10
    // Offset: 0x84
    ::UnityEngine::Quaternion lastRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    public:
    // Get static field: static public readonly UnityEngine.Color GizmoColor
    static ::UnityEngine::Color _get_GizmoColor();
    // Set static field: static public readonly UnityEngine.Color GizmoColor
    static void _set_GizmoColor(::UnityEngine::Color value);
    // Get instance field reference: public Pathfinding.NavmeshAdd/MeshType type
    [[deprecated("Use field access instead!")]] ::Pathfinding::NavmeshAdd::MeshType& dyn_type();
    // Get instance field reference: public UnityEngine.Mesh mesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::Mesh*& dyn_mesh();
    // Get instance field reference: private UnityEngine.Vector3[] verts
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_verts();
    // Get instance field reference: private System.Int32[] tris
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_tris();
    // Get instance field reference: public UnityEngine.Vector2 rectangleSize
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_rectangleSize();
    // Get instance field reference: public System.Single meshScale
    [[deprecated("Use field access instead!")]] float& dyn_meshScale();
    // Get instance field reference: public UnityEngine.Vector3 center
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_center();
    // Get instance field reference: public System.Boolean useRotationAndScale
    [[deprecated("Use field access instead!")]] bool& dyn_useRotationAndScale();
    // Get instance field reference: public System.Single updateDistance
    [[deprecated("Use field access instead!")]] float& dyn_updateDistance();
    // Get instance field reference: public System.Single updateRotationDistance
    [[deprecated("Use field access instead!")]] float& dyn_updateRotationDistance();
    // Get instance field reference: protected UnityEngine.Transform tr
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_tr();
    // Get instance field reference: private UnityEngine.Vector3 lastPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_lastPosition();
    // Get instance field reference: private UnityEngine.Quaternion lastRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_lastRotation();
    // public UnityEngine.Vector3 get_Center()
    // Offset: 0x29F83EC
    ::UnityEngine::Vector3 get_Center();
    // public System.Void RebuildMesh()
    // Offset: 0x29F8464
    void RebuildMesh();
    // public System.Void GetMesh(ref Pathfinding.Int3[] vbuffer, out System.Int32[] tbuffer, Pathfinding.Util.GraphTransform inverseTransform)
    // Offset: 0x29F8950
    void GetMesh(ByRef<::ArrayW<::Pathfinding::Int3>> vbuffer, ByRef<::ArrayW<int>> tbuffer, ::Pathfinding::Util::GraphTransform* inverseTransform);
    // public override System.Boolean RequiresUpdate()
    // Offset: 0x29F81F0
    // Implemented from: Pathfinding.NavmeshClipper
    // Base method: System.Boolean NavmeshClipper::RequiresUpdate()
    bool RequiresUpdate();
    // public override System.Void ForceUpdate()
    // Offset: 0x29F82E8
    // Implemented from: Pathfinding.NavmeshClipper
    // Base method: System.Void NavmeshClipper::ForceUpdate()
    void ForceUpdate();
    // protected override System.Void Awake()
    // Offset: 0x29F82FC
    // Implemented from: Pathfinding.VersionedMonoBehaviour
    // Base method: System.Void VersionedMonoBehaviour::Awake()
    void Awake();
    // override System.Void NotifyUpdated()
    // Offset: 0x29F83A0
    // Implemented from: Pathfinding.NavmeshClipper
    // Base method: System.Void NavmeshClipper::NotifyUpdated()
    void NotifyUpdated();
    // public override UnityEngine.Rect GetBounds(Pathfinding.Util.GraphTransform inverseTransform)
    // Offset: 0x29F8700
    // Implemented from: Pathfinding.NavmeshClipper
    // Base method: UnityEngine.Rect NavmeshClipper::GetBounds(Pathfinding.Util.GraphTransform inverseTransform)
    ::UnityEngine::Rect GetBounds(::Pathfinding::Util::GraphTransform* inverseTransform);
    // public System.Void .ctor()
    // Offset: 0x29F8CC0
    // Implemented from: Pathfinding.NavmeshClipper
    // Base method: System.Void NavmeshClipper::.ctor()
    // Base method: System.Void VersionedMonoBehaviour::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NavmeshAdd* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Pathfinding::NavmeshAdd::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NavmeshAdd*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0x29F8D74
    // Implemented from: Pathfinding.NavmeshClipper
    // Base method: System.Void NavmeshClipper::.cctor()
    static void _cctor();
  }; // Pathfinding.NavmeshAdd
  #pragma pack(pop)
  static check_size<sizeof(NavmeshAdd), 132 + sizeof(::UnityEngine::Quaternion)> __Pathfinding_NavmeshAddSizeCheck;
  static_assert(sizeof(NavmeshAdd) == 0x94);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Pathfinding::NavmeshAdd::MeshType, "Pathfinding", "NavmeshAdd/MeshType");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::get_Center
// Il2CppName: get_Center
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::NavmeshAdd::*)()>(&Pathfinding::NavmeshAdd::get_Center)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "get_Center", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::RebuildMesh
// Il2CppName: RebuildMesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::NavmeshAdd::*)()>(&Pathfinding::NavmeshAdd::RebuildMesh)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "RebuildMesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::GetMesh
// Il2CppName: GetMesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::NavmeshAdd::*)(ByRef<::ArrayW<::Pathfinding::Int3>>, ByRef<::ArrayW<int>>, ::Pathfinding::Util::GraphTransform*)>(&Pathfinding::NavmeshAdd::GetMesh)> {
  static const MethodInfo* get() {
    static auto* vbuffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("Pathfinding", "Int3"), 1)->this_arg;
    static auto* tbuffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Int32"), 1)->this_arg;
    static auto* inverseTransform = &::il2cpp_utils::GetClassFromName("Pathfinding.Util", "GraphTransform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "GetMesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{vbuffer, tbuffer, inverseTransform});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::RequiresUpdate
// Il2CppName: RequiresUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::NavmeshAdd::*)()>(&Pathfinding::NavmeshAdd::RequiresUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "RequiresUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::ForceUpdate
// Il2CppName: ForceUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::NavmeshAdd::*)()>(&Pathfinding::NavmeshAdd::ForceUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "ForceUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::NavmeshAdd::*)()>(&Pathfinding::NavmeshAdd::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::NotifyUpdated
// Il2CppName: NotifyUpdated
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::NavmeshAdd::*)()>(&Pathfinding::NavmeshAdd::NotifyUpdated)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "NotifyUpdated", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::GetBounds
// Il2CppName: GetBounds
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Rect (Pathfinding::NavmeshAdd::*)(::Pathfinding::Util::GraphTransform*)>(&Pathfinding::NavmeshAdd::GetBounds)> {
  static const MethodInfo* get() {
    static auto* inverseTransform = &::il2cpp_utils::GetClassFromName("Pathfinding.Util", "GraphTransform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), "GetBounds", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{inverseTransform});
  }
};
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Pathfinding::NavmeshAdd::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Pathfinding::NavmeshAdd::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::NavmeshAdd*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
