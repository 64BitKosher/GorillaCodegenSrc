// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Pathfinding.Voxels.CompactVoxelSpan
#include "Pathfinding/Voxels/CompactVoxelSpan.hpp"
// Including type: Pathfinding.Voxels.CompactVoxelCell
#include "Pathfinding/Voxels/CompactVoxelCell.hpp"
// Including type: UnityEngine.Vector3
#include "UnityEngine/Vector3.hpp"
// Including type: Pathfinding.Voxels.LinkedVoxelSpan
#include "Pathfinding/Voxels/LinkedVoxelSpan.hpp"
// Including type: System.UInt32
#include "System/UInt32.hpp"
// Including type: System.Int32
#include "System/Int32.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Type namespace: Pathfinding.Voxels
namespace Pathfinding::Voxels {
  // Forward declaring type: VoxelArea
  class VoxelArea;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Pathfinding::Voxels::VoxelArea);
DEFINE_IL2CPP_ARG_TYPE(::Pathfinding::Voxels::VoxelArea*, "Pathfinding.Voxels", "VoxelArea");
// Type namespace: Pathfinding.Voxels
namespace Pathfinding::Voxels {
  // Size: 0x84
  #pragma pack(push, 1)
  // Autogenerated type: Pathfinding.Voxels.VoxelArea
  // [TokenAttribute] Offset: FFFFFFFF
  class VoxelArea : public ::Il2CppObject {
    public:
    public:
    // public readonly System.Int32 width
    // Size: 0x4
    // Offset: 0x10
    int width;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public readonly System.Int32 depth
    // Size: 0x4
    // Offset: 0x14
    int depth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public Pathfinding.Voxels.CompactVoxelSpan[] compactSpans
    // Size: 0x8
    // Offset: 0x18
    ::ArrayW<::Pathfinding::Voxels::CompactVoxelSpan> compactSpans;
    // Field size check
    static_assert(sizeof(::ArrayW<::Pathfinding::Voxels::CompactVoxelSpan>) == 0x8);
    // public Pathfinding.Voxels.CompactVoxelCell[] compactCells
    // Size: 0x8
    // Offset: 0x20
    ::ArrayW<::Pathfinding::Voxels::CompactVoxelCell> compactCells;
    // Field size check
    static_assert(sizeof(::ArrayW<::Pathfinding::Voxels::CompactVoxelCell>) == 0x8);
    // public System.Int32 compactSpanCount
    // Size: 0x4
    // Offset: 0x28
    int compactSpanCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: compactSpanCount and: tmpUShortArr
    char __padding4[0x4] = {};
    // public System.UInt16[] tmpUShortArr
    // Size: 0x8
    // Offset: 0x30
    ::ArrayW<uint16_t> tmpUShortArr;
    // Field size check
    static_assert(sizeof(::ArrayW<uint16_t>) == 0x8);
    // public System.Int32[] areaTypes
    // Size: 0x8
    // Offset: 0x38
    ::ArrayW<int> areaTypes;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.UInt16[] dist
    // Size: 0x8
    // Offset: 0x40
    ::ArrayW<uint16_t> dist;
    // Field size check
    static_assert(sizeof(::ArrayW<uint16_t>) == 0x8);
    // public System.UInt16 maxDistance
    // Size: 0x2
    // Offset: 0x48
    uint16_t maxDistance;
    // Field size check
    static_assert(sizeof(uint16_t) == 0x2);
    // Padding between fields: maxDistance and: maxRegions
    char __padding8[0x2] = {};
    // public System.Int32 maxRegions
    // Size: 0x4
    // Offset: 0x4C
    int maxRegions;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Int32[] DirectionX
    // Size: 0x8
    // Offset: 0x50
    ::ArrayW<int> DirectionX;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public System.Int32[] DirectionZ
    // Size: 0x8
    // Offset: 0x58
    ::ArrayW<int> DirectionZ;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // public UnityEngine.Vector3[] VectorDirection
    // Size: 0x8
    // Offset: 0x60
    ::ArrayW<::UnityEngine::Vector3> VectorDirection;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private System.Int32 linkedSpanCount
    // Size: 0x4
    // Offset: 0x68
    int linkedSpanCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: linkedSpanCount and: linkedSpans
    char __padding13[0x4] = {};
    // public Pathfinding.Voxels.LinkedVoxelSpan[] linkedSpans
    // Size: 0x8
    // Offset: 0x70
    ::ArrayW<::Pathfinding::Voxels::LinkedVoxelSpan> linkedSpans;
    // Field size check
    static_assert(sizeof(::ArrayW<::Pathfinding::Voxels::LinkedVoxelSpan>) == 0x8);
    // private System.Int32[] removedStack
    // Size: 0x8
    // Offset: 0x78
    ::ArrayW<int> removedStack;
    // Field size check
    static_assert(sizeof(::ArrayW<int>) == 0x8);
    // private System.Int32 removedStackCount
    // Size: 0x4
    // Offset: 0x80
    int removedStackCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // static field const value: static public System.UInt32 MaxHeight
    static constexpr const uint MaxHeight = 65536u;
    // Get static field: static public System.UInt32 MaxHeight
    static uint _get_MaxHeight();
    // Set static field: static public System.UInt32 MaxHeight
    static void _set_MaxHeight(uint value);
    // static field const value: static public System.Int32 MaxHeightInt
    static constexpr const int MaxHeightInt = 65536;
    // Get static field: static public System.Int32 MaxHeightInt
    static int _get_MaxHeightInt();
    // Set static field: static public System.Int32 MaxHeightInt
    static void _set_MaxHeightInt(int value);
    // static field const value: static public System.UInt32 InvalidSpanValue
    static constexpr const uint InvalidSpanValue = 4294967295u;
    // Get static field: static public System.UInt32 InvalidSpanValue
    static uint _get_InvalidSpanValue();
    // Set static field: static public System.UInt32 InvalidSpanValue
    static void _set_InvalidSpanValue(uint value);
    // static field const value: static public System.Single AvgSpanLayerCountEstimate
    static constexpr const float AvgSpanLayerCountEstimate = 8;
    // Get static field: static public System.Single AvgSpanLayerCountEstimate
    static float _get_AvgSpanLayerCountEstimate();
    // Set static field: static public System.Single AvgSpanLayerCountEstimate
    static void _set_AvgSpanLayerCountEstimate(float value);
    // Get instance field reference: public readonly System.Int32 width
    [[deprecated("Use field access instead!")]] int& dyn_width();
    // Get instance field reference: public readonly System.Int32 depth
    [[deprecated("Use field access instead!")]] int& dyn_depth();
    // Get instance field reference: public Pathfinding.Voxels.CompactVoxelSpan[] compactSpans
    [[deprecated("Use field access instead!")]] ::ArrayW<::Pathfinding::Voxels::CompactVoxelSpan>& dyn_compactSpans();
    // Get instance field reference: public Pathfinding.Voxels.CompactVoxelCell[] compactCells
    [[deprecated("Use field access instead!")]] ::ArrayW<::Pathfinding::Voxels::CompactVoxelCell>& dyn_compactCells();
    // Get instance field reference: public System.Int32 compactSpanCount
    [[deprecated("Use field access instead!")]] int& dyn_compactSpanCount();
    // Get instance field reference: public System.UInt16[] tmpUShortArr
    [[deprecated("Use field access instead!")]] ::ArrayW<uint16_t>& dyn_tmpUShortArr();
    // Get instance field reference: public System.Int32[] areaTypes
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_areaTypes();
    // Get instance field reference: public System.UInt16[] dist
    [[deprecated("Use field access instead!")]] ::ArrayW<uint16_t>& dyn_dist();
    // Get instance field reference: public System.UInt16 maxDistance
    [[deprecated("Use field access instead!")]] uint16_t& dyn_maxDistance();
    // Get instance field reference: public System.Int32 maxRegions
    [[deprecated("Use field access instead!")]] int& dyn_maxRegions();
    // Get instance field reference: public System.Int32[] DirectionX
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_DirectionX();
    // Get instance field reference: public System.Int32[] DirectionZ
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_DirectionZ();
    // Get instance field reference: public UnityEngine.Vector3[] VectorDirection
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_VectorDirection();
    // Get instance field reference: private System.Int32 linkedSpanCount
    [[deprecated("Use field access instead!")]] int& dyn_linkedSpanCount();
    // Get instance field reference: public Pathfinding.Voxels.LinkedVoxelSpan[] linkedSpans
    [[deprecated("Use field access instead!")]] ::ArrayW<::Pathfinding::Voxels::LinkedVoxelSpan>& dyn_linkedSpans();
    // Get instance field reference: private System.Int32[] removedStack
    [[deprecated("Use field access instead!")]] ::ArrayW<int>& dyn_removedStack();
    // Get instance field reference: private System.Int32 removedStackCount
    [[deprecated("Use field access instead!")]] int& dyn_removedStackCount();
    // public System.Void Reset()
    // Offset: 0x2A10104
    void Reset();
    // private System.Void ResetLinkedVoxelSpans()
    // Offset: 0x2A10160
    void ResetLinkedVoxelSpans();
    // public System.Void .ctor(System.Int32 width, System.Int32 depth)
    // Offset: 0x2A103F4
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static VoxelArea* New_ctor(int width, int depth) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Pathfinding::Voxels::VoxelArea::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<VoxelArea*, creationType>(width, depth)));
    }
    // public System.Int32 GetSpanCountAll()
    // Offset: 0x2A106DC
    int GetSpanCountAll();
    // public System.Int32 GetSpanCount()
    // Offset: 0x2A10760
    int GetSpanCount();
    // private System.Void PushToSpanRemovedStack(System.Int32 index)
    // Offset: 0x2A107E8
    void PushToSpanRemovedStack(int index);
    // public System.Void AddLinkedSpan(System.Int32 index, System.UInt32 bottom, System.UInt32 top, System.Int32 area, System.Int32 voxelWalkableClimb)
    // Offset: 0x2A108C4
    void AddLinkedSpan(int index, uint bottom, uint top, int area, int voxelWalkableClimb);
  }; // Pathfinding.Voxels.VoxelArea
  #pragma pack(pop)
  static check_size<sizeof(VoxelArea), 128 + sizeof(int)> __Pathfinding_Voxels_VoxelAreaSizeCheck;
  static_assert(sizeof(VoxelArea) == 0x84);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Pathfinding::Voxels::VoxelArea::Reset
// Il2CppName: Reset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::Voxels::VoxelArea::*)()>(&Pathfinding::Voxels::VoxelArea::Reset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::Voxels::VoxelArea*), "Reset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::Voxels::VoxelArea::ResetLinkedVoxelSpans
// Il2CppName: ResetLinkedVoxelSpans
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::Voxels::VoxelArea::*)()>(&Pathfinding::Voxels::VoxelArea::ResetLinkedVoxelSpans)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::Voxels::VoxelArea*), "ResetLinkedVoxelSpans", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::Voxels::VoxelArea::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Pathfinding::Voxels::VoxelArea::GetSpanCountAll
// Il2CppName: GetSpanCountAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Pathfinding::Voxels::VoxelArea::*)()>(&Pathfinding::Voxels::VoxelArea::GetSpanCountAll)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::Voxels::VoxelArea*), "GetSpanCountAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::Voxels::VoxelArea::GetSpanCount
// Il2CppName: GetSpanCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Pathfinding::Voxels::VoxelArea::*)()>(&Pathfinding::Voxels::VoxelArea::GetSpanCount)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::Voxels::VoxelArea*), "GetSpanCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::Voxels::VoxelArea::PushToSpanRemovedStack
// Il2CppName: PushToSpanRemovedStack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::Voxels::VoxelArea::*)(int)>(&Pathfinding::Voxels::VoxelArea::PushToSpanRemovedStack)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::Voxels::VoxelArea*), "PushToSpanRemovedStack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: Pathfinding::Voxels::VoxelArea::AddLinkedSpan
// Il2CppName: AddLinkedSpan
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::Voxels::VoxelArea::*)(int, uint, uint, int, int)>(&Pathfinding::Voxels::VoxelArea::AddLinkedSpan)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* bottom = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* top = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* area = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* voxelWalkableClimb = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::Voxels::VoxelArea*), "AddLinkedSpan", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index, bottom, top, area, voxelWalkableClimb});
  }
};
