// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Pathfinding.VersionedMonoBehaviour
#include "Pathfinding/VersionedMonoBehaviour.hpp"
// Including type: Pathfinding.IAstarAI
#include "Pathfinding/IAstarAI.hpp"
// Including type: Pathfinding.OrientationMode
#include "Pathfinding/OrientationMode.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Pathfinding
namespace Pathfinding {
  // Forward declaring type: AutoRepathPolicy
  class AutoRepathPolicy;
  // Forward declaring type: Seeker
  class Seeker;
  // Forward declaring type: ABPath
  class ABPath;
  // Forward declaring type: Path
  class Path;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Action
  class Action;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
}
// Forward declaring namespace: Pathfinding::Util
namespace Pathfinding::Util {
  // Forward declaring type: PathInterpolator
  class PathInterpolator;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Completed forward declares
// Type namespace: Pathfinding
namespace Pathfinding {
  // Forward declaring type: AILerp
  class AILerp;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Pathfinding::AILerp);
DEFINE_IL2CPP_ARG_TYPE(::Pathfinding::AILerp*, "Pathfinding", "AILerp");
// Type namespace: Pathfinding
namespace Pathfinding {
  // Size: 0xED
  #pragma pack(push, 1)
  // Autogenerated type: Pathfinding.AILerp
  // [TokenAttribute] Offset: FFFFFFFF
  // [HelpURLAttribute] Offset: FFFFFFFF
  // [AddComponentMenu] Offset: FFFFFFFF
  // [RequireComponent] Offset: FFFFFFFF
  class AILerp : public ::Pathfinding::VersionedMonoBehaviour/*, public ::Pathfinding::IAstarAI*/ {
    public:
    // Writing base type padding for base size: 0x24 to desired offset: 0x28
    char ___base_padding[0x4] = {};
    public:
    // public Pathfinding.AutoRepathPolicy autoRepath
    // Size: 0x8
    // Offset: 0x28
    ::Pathfinding::AutoRepathPolicy* autoRepath;
    // Field size check
    static_assert(sizeof(::Pathfinding::AutoRepathPolicy*) == 0x8);
    // public System.Boolean canMove
    // Size: 0x1
    // Offset: 0x30
    bool canMove;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: canMove and: speed
    char __padding1[0x3] = {};
    // public System.Single speed
    // Size: 0x4
    // Offset: 0x34
    float speed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public Pathfinding.OrientationMode orientation
    // Size: 0x4
    // Offset: 0x38
    ::Pathfinding::OrientationMode orientation;
    // Field size check
    static_assert(sizeof(::Pathfinding::OrientationMode) == 0x4);
    // public System.Boolean enableRotation
    // Size: 0x1
    // Offset: 0x3C
    bool enableRotation;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: enableRotation and: rotationSpeed
    char __padding4[0x3] = {};
    // public System.Single rotationSpeed
    // Size: 0x4
    // Offset: 0x40
    float rotationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Boolean interpolatePathSwitches
    // Size: 0x1
    // Offset: 0x44
    bool interpolatePathSwitches;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: interpolatePathSwitches and: switchPathInterpolationSpeed
    char __padding6[0x3] = {};
    // public System.Single switchPathInterpolationSpeed
    // Size: 0x4
    // Offset: 0x48
    float switchPathInterpolationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean <reachedEndOfPath>k__BackingField
    // Size: 0x1
    // Offset: 0x4C
    bool reachedEndOfPath;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: reachedEndOfPath and: destination
    char __padding8[0x3] = {};
    // private UnityEngine.Vector3 <destination>k__BackingField
    // Size: 0xC
    // Offset: 0x50
    ::UnityEngine::Vector3 destination;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public System.Boolean updatePosition
    // Size: 0x1
    // Offset: 0x5C
    bool updatePosition;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean updateRotation
    // Size: 0x1
    // Offset: 0x5D
    bool updateRotation;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean <isStopped>k__BackingField
    // Size: 0x1
    // Offset: 0x5E
    bool isStopped;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isStopped and: onSearchPath
    char __padding12[0x1] = {};
    // private System.Action <onSearchPath>k__BackingField
    // Size: 0x8
    // Offset: 0x60
    ::System::Action* onSearchPath;
    // Field size check
    static_assert(sizeof(::System::Action*) == 0x8);
    // protected Pathfinding.Seeker seeker
    // Size: 0x8
    // Offset: 0x68
    ::Pathfinding::Seeker* seeker;
    // Field size check
    static_assert(sizeof(::Pathfinding::Seeker*) == 0x8);
    // protected UnityEngine.Transform tr
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::Transform* tr;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // protected Pathfinding.ABPath path
    // Size: 0x8
    // Offset: 0x78
    ::Pathfinding::ABPath* path;
    // Field size check
    static_assert(sizeof(::Pathfinding::ABPath*) == 0x8);
    // protected System.Boolean canSearchAgain
    // Size: 0x1
    // Offset: 0x80
    bool canSearchAgain;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: canSearchAgain and: previousMovementOrigin
    char __padding17[0x3] = {};
    // protected UnityEngine.Vector3 previousMovementOrigin
    // Size: 0xC
    // Offset: 0x84
    ::UnityEngine::Vector3 previousMovementOrigin;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // protected UnityEngine.Vector3 previousMovementDirection
    // Size: 0xC
    // Offset: 0x90
    ::UnityEngine::Vector3 previousMovementDirection;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // protected System.Single pathSwitchInterpolationTime
    // Size: 0x4
    // Offset: 0x9C
    float pathSwitchInterpolationTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // protected Pathfinding.Util.PathInterpolator interpolator
    // Size: 0x8
    // Offset: 0xA0
    ::Pathfinding::Util::PathInterpolator* interpolator;
    // Field size check
    static_assert(sizeof(::Pathfinding::Util::PathInterpolator*) == 0x8);
    // private System.Boolean startHasRun
    // Size: 0x1
    // Offset: 0xA8
    bool startHasRun;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: startHasRun and: previousPosition1
    char __padding22[0x3] = {};
    // private UnityEngine.Vector3 previousPosition1
    // Size: 0xC
    // Offset: 0xAC
    ::UnityEngine::Vector3 previousPosition1;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 previousPosition2
    // Size: 0xC
    // Offset: 0xB8
    ::UnityEngine::Vector3 previousPosition2;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 simulatedPosition
    // Size: 0xC
    // Offset: 0xC4
    ::UnityEngine::Vector3 simulatedPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion simulatedRotation
    // Size: 0x10
    // Offset: 0xD0
    ::UnityEngine::Quaternion simulatedRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Transform targetCompatibility
    // Size: 0x8
    // Offset: 0xE0
    ::UnityEngine::Transform* targetCompatibility;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Single repathRateCompatibility
    // Size: 0x4
    // Offset: 0xE8
    float repathRateCompatibility;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean canSearchCompability
    // Size: 0x1
    // Offset: 0xEC
    bool canSearchCompability;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator ::Pathfinding::IAstarAI
    operator ::Pathfinding::IAstarAI() noexcept {
      return *reinterpret_cast<::Pathfinding::IAstarAI*>(this);
    }
    // Get instance field reference: public Pathfinding.AutoRepathPolicy autoRepath
    [[deprecated("Use field access instead!")]] ::Pathfinding::AutoRepathPolicy*& dyn_autoRepath();
    // Get instance field reference: public System.Boolean canMove
    [[deprecated("Use field access instead!")]] bool& dyn_canMove();
    // Get instance field reference: public System.Single speed
    [[deprecated("Use field access instead!")]] float& dyn_speed();
    // Get instance field reference: public Pathfinding.OrientationMode orientation
    [[deprecated("Use field access instead!")]] ::Pathfinding::OrientationMode& dyn_orientation();
    // Get instance field reference: public System.Boolean enableRotation
    [[deprecated("Use field access instead!")]] bool& dyn_enableRotation();
    // Get instance field reference: public System.Single rotationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_rotationSpeed();
    // Get instance field reference: public System.Boolean interpolatePathSwitches
    [[deprecated("Use field access instead!")]] bool& dyn_interpolatePathSwitches();
    // Get instance field reference: public System.Single switchPathInterpolationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_switchPathInterpolationSpeed();
    // Get instance field reference: private System.Boolean <reachedEndOfPath>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$reachedEndOfPath$k__BackingField();
    // Get instance field reference: private UnityEngine.Vector3 <destination>k__BackingField
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_$destination$k__BackingField();
    // Get instance field reference: public System.Boolean updatePosition
    [[deprecated("Use field access instead!")]] bool& dyn_updatePosition();
    // Get instance field reference: public System.Boolean updateRotation
    [[deprecated("Use field access instead!")]] bool& dyn_updateRotation();
    // Get instance field reference: private System.Boolean <isStopped>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$isStopped$k__BackingField();
    // Get instance field reference: private System.Action <onSearchPath>k__BackingField
    [[deprecated("Use field access instead!")]] ::System::Action*& dyn_$onSearchPath$k__BackingField();
    // Get instance field reference: protected Pathfinding.Seeker seeker
    [[deprecated("Use field access instead!")]] ::Pathfinding::Seeker*& dyn_seeker();
    // Get instance field reference: protected UnityEngine.Transform tr
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_tr();
    // Get instance field reference: protected Pathfinding.ABPath path
    [[deprecated("Use field access instead!")]] ::Pathfinding::ABPath*& dyn_path();
    // Get instance field reference: protected System.Boolean canSearchAgain
    [[deprecated("Use field access instead!")]] bool& dyn_canSearchAgain();
    // Get instance field reference: protected UnityEngine.Vector3 previousMovementOrigin
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousMovementOrigin();
    // Get instance field reference: protected UnityEngine.Vector3 previousMovementDirection
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousMovementDirection();
    // Get instance field reference: protected System.Single pathSwitchInterpolationTime
    [[deprecated("Use field access instead!")]] float& dyn_pathSwitchInterpolationTime();
    // Get instance field reference: protected Pathfinding.Util.PathInterpolator interpolator
    [[deprecated("Use field access instead!")]] ::Pathfinding::Util::PathInterpolator*& dyn_interpolator();
    // Get instance field reference: private System.Boolean startHasRun
    [[deprecated("Use field access instead!")]] bool& dyn_startHasRun();
    // Get instance field reference: private UnityEngine.Vector3 previousPosition1
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousPosition1();
    // Get instance field reference: private UnityEngine.Vector3 previousPosition2
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousPosition2();
    // Get instance field reference: private UnityEngine.Vector3 simulatedPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_simulatedPosition();
    // Get instance field reference: private UnityEngine.Quaternion simulatedRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_simulatedRotation();
    // Get instance field reference: private UnityEngine.Transform targetCompatibility
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_targetCompatibility();
    // Get instance field reference: private System.Single repathRateCompatibility
    [[deprecated("Use field access instead!")]] float& dyn_repathRateCompatibility();
    // Get instance field reference: private System.Boolean canSearchCompability
    [[deprecated("Use field access instead!")]] bool& dyn_canSearchCompability();
    // public System.Single get_repathRate()
    // Offset: 0x298BB54
    float get_repathRate();
    // public System.Void set_repathRate(System.Single value)
    // Offset: 0x298BB70
    void set_repathRate(float value);
    // public System.Boolean get_canSearch()
    // Offset: 0x298BB8C
    bool get_canSearch();
    // public System.Void set_canSearch(System.Boolean value)
    // Offset: 0x298BBB0
    void set_canSearch(bool value);
    // public System.Boolean get_rotationIn2D()
    // Offset: 0x298BBD0
    bool get_rotationIn2D();
    // public System.Void set_rotationIn2D(System.Boolean value)
    // Offset: 0x298BBE0
    void set_rotationIn2D(bool value);
    // public System.Boolean get_reachedEndOfPath()
    // Offset: 0x298BBFC
    bool get_reachedEndOfPath();
    // private System.Void set_reachedEndOfPath(System.Boolean value)
    // Offset: 0x298BC04
    void set_reachedEndOfPath(bool value);
    // public System.Boolean get_reachedDestination()
    // Offset: 0x298BC10
    bool get_reachedDestination();
    // public UnityEngine.Vector3 get_destination()
    // Offset: 0x298BD34
    ::UnityEngine::Vector3 get_destination();
    // public System.Void set_destination(UnityEngine.Vector3 value)
    // Offset: 0x298BD40
    void set_destination(::UnityEngine::Vector3 value);
    // public UnityEngine.Transform get_target()
    // Offset: 0x298BD4C
    ::UnityEngine::Transform* get_target();
    // public System.Void set_target(UnityEngine.Transform value)
    // Offset: 0x298BDF4
    void set_target(::UnityEngine::Transform* value);
    // public UnityEngine.Vector3 get_position()
    // Offset: 0x298BF34
    ::UnityEngine::Vector3 get_position();
    // public UnityEngine.Quaternion get_rotation()
    // Offset: 0x298BF68
    ::UnityEngine::Quaternion get_rotation();
    // public System.Void set_rotation(UnityEngine.Quaternion value)
    // Offset: 0x298BF9C
    void set_rotation(::UnityEngine::Quaternion value);
    // private System.Void Pathfinding.IAstarAI.Move(UnityEngine.Vector3 deltaPosition)
    // Offset: 0x298BFD0
    void Pathfinding_IAstarAI_Move(::UnityEngine::Vector3 deltaPosition);
    // private System.Single Pathfinding.IAstarAI.get_radius()
    // Offset: 0x298BFD4
    float Pathfinding_IAstarAI_get_radius();
    // private System.Void Pathfinding.IAstarAI.set_radius(System.Single value)
    // Offset: 0x298BFDC
    void Pathfinding_IAstarAI_set_radius(float value);
    // private System.Single Pathfinding.IAstarAI.get_height()
    // Offset: 0x298BFE0
    float Pathfinding_IAstarAI_get_height();
    // private System.Void Pathfinding.IAstarAI.set_height(System.Single value)
    // Offset: 0x298BFE8
    void Pathfinding_IAstarAI_set_height(float value);
    // private System.Single Pathfinding.IAstarAI.get_maxSpeed()
    // Offset: 0x298BFEC
    float Pathfinding_IAstarAI_get_maxSpeed();
    // private System.Void Pathfinding.IAstarAI.set_maxSpeed(System.Single value)
    // Offset: 0x298BFF4
    void Pathfinding_IAstarAI_set_maxSpeed(float value);
    // private System.Boolean Pathfinding.IAstarAI.get_canSearch()
    // Offset: 0x298BFFC
    bool Pathfinding_IAstarAI_get_canSearch();
    // private System.Void Pathfinding.IAstarAI.set_canSearch(System.Boolean value)
    // Offset: 0x298C020
    void Pathfinding_IAstarAI_set_canSearch(bool value);
    // private System.Boolean Pathfinding.IAstarAI.get_canMove()
    // Offset: 0x298C040
    bool Pathfinding_IAstarAI_get_canMove();
    // private System.Void Pathfinding.IAstarAI.set_canMove(System.Boolean value)
    // Offset: 0x298C048
    void Pathfinding_IAstarAI_set_canMove(bool value);
    // public UnityEngine.Vector3 get_velocity()
    // Offset: 0x298C054
    ::UnityEngine::Vector3 get_velocity();
    // private UnityEngine.Vector3 Pathfinding.IAstarAI.get_desiredVelocity()
    // Offset: 0x298C0F4
    ::UnityEngine::Vector3 Pathfinding_IAstarAI_get_desiredVelocity();
    // private UnityEngine.Vector3 Pathfinding.IAstarAI.get_steeringTarget()
    // Offset: 0x298C18C
    ::UnityEngine::Vector3 Pathfinding_IAstarAI_get_steeringTarget();
    // public System.Single get_remainingDistance()
    // Offset: 0x298BD0C
    float get_remainingDistance();
    // public System.Void set_remainingDistance(System.Single value)
    // Offset: 0x298C20C
    void set_remainingDistance(float value);
    // public System.Boolean get_hasPath()
    // Offset: 0x298C230
    bool get_hasPath();
    // public System.Boolean get_pathPending()
    // Offset: 0x298C24C
    bool get_pathPending();
    // public System.Boolean get_isStopped()
    // Offset: 0x298C25C
    bool get_isStopped();
    // public System.Void set_isStopped(System.Boolean value)
    // Offset: 0x298C264
    void set_isStopped(bool value);
    // public System.Action get_onSearchPath()
    // Offset: 0x298C270
    ::System::Action* get_onSearchPath();
    // public System.Void set_onSearchPath(System.Action value)
    // Offset: 0x298C278
    void set_onSearchPath(::System::Action* value);
    // protected System.Void Start()
    // Offset: 0x298C468
    void Start();
    // protected System.Void OnEnable()
    // Offset: 0x298C4E4
    void OnEnable();
    // private System.Void Init()
    // Offset: 0x298C474
    void Init();
    // public System.Void OnDisable()
    // Offset: 0x298C668
    void OnDisable();
    // public System.Void GetRemainingPath(System.Collections.Generic.List`1<UnityEngine.Vector3> buffer, out System.Boolean stale)
    // Offset: 0x298C740
    void GetRemainingPath(::System::Collections::Generic::List_1<::UnityEngine::Vector3>* buffer, ByRef<bool> stale);
    // public System.Void Teleport(UnityEngine.Vector3 position, System.Boolean clearPath)
    // Offset: 0x298C5B0
    void Teleport(::UnityEngine::Vector3 position, bool clearPath);
    // protected System.Boolean get_shouldRecalculatePath()
    // Offset: 0x298C87C
    bool get_shouldRecalculatePath();
    // public System.Void ForceSearchPath()
    // Offset: 0x298C8D4
    void ForceSearchPath();
    // public System.Void SearchPath()
    // Offset: 0x298C8E4
    void SearchPath();
    // public System.Void OnTargetReached()
    // Offset: 0x298CBD8
    void OnTargetReached();
    // protected System.Void OnPathComplete(Pathfinding.Path _p)
    // Offset: 0x298CBDC
    void OnPathComplete(::Pathfinding::Path* _p);
    // protected System.Void ClearPath()
    // Offset: 0x298CE88
    void ClearPath();
    // public System.Void SetPath(Pathfinding.Path path, System.Boolean updateDestinationFromPath)
    // Offset: 0x298C9EC
    void SetPath(::Pathfinding::Path* path, bool updateDestinationFromPath);
    // protected System.Void ConfigurePathSwitchInterpolation()
    // Offset: 0x298CF4C
    void ConfigurePathSwitchInterpolation();
    // public UnityEngine.Vector3 GetFeetPosition()
    // Offset: 0x298D134
    ::UnityEngine::Vector3 GetFeetPosition();
    // protected System.Void ConfigureNewPath()
    // Offset: 0x298D138
    void ConfigureNewPath();
    // protected System.Void Update()
    // Offset: 0x298D418
    void Update();
    // public System.Void MovementUpdate(System.Single deltaTime, out UnityEngine.Vector3 nextPosition, out UnityEngine.Quaternion nextRotation)
    // Offset: 0x298D49C
    void MovementUpdate(float deltaTime, ByRef<::UnityEngine::Vector3> nextPosition, ByRef<::UnityEngine::Quaternion> nextRotation);
    // public System.Void FinalizeMovement(UnityEngine.Vector3 nextPosition, UnityEngine.Quaternion nextRotation)
    // Offset: 0x298D57C
    void FinalizeMovement(::UnityEngine::Vector3 nextPosition, ::UnityEngine::Quaternion nextRotation);
    // private UnityEngine.Quaternion SimulateRotationTowards(UnityEngine.Vector3 direction, System.Single deltaTime)
    // Offset: 0x298D624
    ::UnityEngine::Quaternion SimulateRotationTowards(::UnityEngine::Vector3 direction, float deltaTime);
    // protected UnityEngine.Vector3 CalculateNextPosition(out UnityEngine.Vector3 direction, System.Single deltaTime)
    // Offset: 0x298D840
    ::UnityEngine::Vector3 CalculateNextPosition(ByRef<::UnityEngine::Vector3> direction, float deltaTime);
    // public System.Void OnDrawGizmos()
    // Offset: 0x298DB48
    void OnDrawGizmos();
    // private UnityEngine.Vector3 <Awake>b__91_0()
    // Offset: 0x298DB98
    ::UnityEngine::Vector3 $Awake$b__91_0();
    // protected System.Void .ctor()
    // Offset: 0x298C280
    // Implemented from: Pathfinding.VersionedMonoBehaviour
    // Base method: System.Void VersionedMonoBehaviour::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static AILerp* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Pathfinding::AILerp::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<AILerp*, creationType>()));
    }
    // protected override System.Void Awake()
    // Offset: 0x298C37C
    // Implemented from: Pathfinding.VersionedMonoBehaviour
    // Base method: System.Void VersionedMonoBehaviour::Awake()
    void Awake();
    // protected override System.Int32 OnUpgradeSerializedData(System.Int32 version, System.Boolean unityThread)
    // Offset: 0x298DA98
    // Implemented from: Pathfinding.VersionedMonoBehaviour
    // Base method: System.Int32 VersionedMonoBehaviour::OnUpgradeSerializedData(System.Int32 version, System.Boolean unityThread)
    int OnUpgradeSerializedData(int version, bool unityThread);
  }; // Pathfinding.AILerp
  #pragma pack(pop)
  static check_size<sizeof(AILerp), 236 + sizeof(bool)> __Pathfinding_AILerpSizeCheck;
  static_assert(sizeof(AILerp) == 0xED);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Pathfinding::AILerp::get_repathRate
// Il2CppName: get_repathRate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_repathRate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_repathRate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_repathRate
// Il2CppName: set_repathRate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(float)>(&Pathfinding::AILerp::set_repathRate)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_repathRate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_canSearch
// Il2CppName: get_canSearch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_canSearch)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_canSearch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_canSearch
// Il2CppName: set_canSearch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(bool)>(&Pathfinding::AILerp::set_canSearch)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_canSearch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_rotationIn2D
// Il2CppName: get_rotationIn2D
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_rotationIn2D)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_rotationIn2D", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_rotationIn2D
// Il2CppName: set_rotationIn2D
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(bool)>(&Pathfinding::AILerp::set_rotationIn2D)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_rotationIn2D", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_reachedEndOfPath
// Il2CppName: get_reachedEndOfPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_reachedEndOfPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_reachedEndOfPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_reachedEndOfPath
// Il2CppName: set_reachedEndOfPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(bool)>(&Pathfinding::AILerp::set_reachedEndOfPath)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_reachedEndOfPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_reachedDestination
// Il2CppName: get_reachedDestination
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_reachedDestination)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_reachedDestination", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_destination
// Il2CppName: get_destination
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_destination)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_destination", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_destination
// Il2CppName: set_destination
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::UnityEngine::Vector3)>(&Pathfinding::AILerp::set_destination)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_destination", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_target
// Il2CppName: get_target
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Transform* (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_target)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_target", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_target
// Il2CppName: set_target
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::UnityEngine::Transform*)>(&Pathfinding::AILerp::set_target)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_target", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_position
// Il2CppName: get_position
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_position)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_position", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_rotation
// Il2CppName: get_rotation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Quaternion (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_rotation)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_rotation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_rotation
// Il2CppName: set_rotation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::UnityEngine::Quaternion)>(&Pathfinding::AILerp::set_rotation)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_rotation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_Move
// Il2CppName: Pathfinding.IAstarAI.Move
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::UnityEngine::Vector3)>(&Pathfinding::AILerp::Pathfinding_IAstarAI_Move)> {
  static const MethodInfo* get() {
    static auto* deltaPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.Move", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{deltaPosition});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_get_radius
// Il2CppName: Pathfinding.IAstarAI.get_radius
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Pathfinding_IAstarAI_get_radius)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.get_radius", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_set_radius
// Il2CppName: Pathfinding.IAstarAI.set_radius
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(float)>(&Pathfinding::AILerp::Pathfinding_IAstarAI_set_radius)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.set_radius", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_get_height
// Il2CppName: Pathfinding.IAstarAI.get_height
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Pathfinding_IAstarAI_get_height)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.get_height", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_set_height
// Il2CppName: Pathfinding.IAstarAI.set_height
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(float)>(&Pathfinding::AILerp::Pathfinding_IAstarAI_set_height)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.set_height", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_get_maxSpeed
// Il2CppName: Pathfinding.IAstarAI.get_maxSpeed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Pathfinding_IAstarAI_get_maxSpeed)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.get_maxSpeed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_set_maxSpeed
// Il2CppName: Pathfinding.IAstarAI.set_maxSpeed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(float)>(&Pathfinding::AILerp::Pathfinding_IAstarAI_set_maxSpeed)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.set_maxSpeed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_get_canSearch
// Il2CppName: Pathfinding.IAstarAI.get_canSearch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Pathfinding_IAstarAI_get_canSearch)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.get_canSearch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_set_canSearch
// Il2CppName: Pathfinding.IAstarAI.set_canSearch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(bool)>(&Pathfinding::AILerp::Pathfinding_IAstarAI_set_canSearch)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.set_canSearch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_get_canMove
// Il2CppName: Pathfinding.IAstarAI.get_canMove
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Pathfinding_IAstarAI_get_canMove)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.get_canMove", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_set_canMove
// Il2CppName: Pathfinding.IAstarAI.set_canMove
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(bool)>(&Pathfinding::AILerp::Pathfinding_IAstarAI_set_canMove)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.set_canMove", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_velocity
// Il2CppName: get_velocity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_velocity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_velocity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_get_desiredVelocity
// Il2CppName: Pathfinding.IAstarAI.get_desiredVelocity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Pathfinding_IAstarAI_get_desiredVelocity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.get_desiredVelocity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Pathfinding_IAstarAI_get_steeringTarget
// Il2CppName: Pathfinding.IAstarAI.get_steeringTarget
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Pathfinding_IAstarAI_get_steeringTarget)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Pathfinding.IAstarAI.get_steeringTarget", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_remainingDistance
// Il2CppName: get_remainingDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_remainingDistance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_remainingDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_remainingDistance
// Il2CppName: set_remainingDistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(float)>(&Pathfinding::AILerp::set_remainingDistance)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_remainingDistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_hasPath
// Il2CppName: get_hasPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_hasPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_hasPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_pathPending
// Il2CppName: get_pathPending
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_pathPending)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_pathPending", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_isStopped
// Il2CppName: get_isStopped
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_isStopped)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_isStopped", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_isStopped
// Il2CppName: set_isStopped
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(bool)>(&Pathfinding::AILerp::set_isStopped)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_isStopped", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_onSearchPath
// Il2CppName: get_onSearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Action* (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_onSearchPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_onSearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::set_onSearchPath
// Il2CppName: set_onSearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::System::Action*)>(&Pathfinding::AILerp::set_onSearchPath)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "set_onSearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Init
// Il2CppName: Init
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Init)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Init", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::GetRemainingPath
// Il2CppName: GetRemainingPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::System::Collections::Generic::List_1<::UnityEngine::Vector3>*, ByRef<bool>)>(&Pathfinding::AILerp::GetRemainingPath)> {
  static const MethodInfo* get() {
    static auto* buffer = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")})->byval_arg;
    static auto* stale = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "GetRemainingPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{buffer, stale});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Teleport
// Il2CppName: Teleport
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::UnityEngine::Vector3, bool)>(&Pathfinding::AILerp::Teleport)> {
  static const MethodInfo* get() {
    static auto* position = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* clearPath = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Teleport", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{position, clearPath});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::get_shouldRecalculatePath
// Il2CppName: get_shouldRecalculatePath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::get_shouldRecalculatePath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "get_shouldRecalculatePath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::ForceSearchPath
// Il2CppName: ForceSearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::ForceSearchPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "ForceSearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::SearchPath
// Il2CppName: SearchPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::SearchPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "SearchPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::OnTargetReached
// Il2CppName: OnTargetReached
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::OnTargetReached)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "OnTargetReached", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::OnPathComplete
// Il2CppName: OnPathComplete
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::Pathfinding::Path*)>(&Pathfinding::AILerp::OnPathComplete)> {
  static const MethodInfo* get() {
    static auto* _p = &::il2cpp_utils::GetClassFromName("Pathfinding", "Path")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "OnPathComplete", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{_p});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::ClearPath
// Il2CppName: ClearPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::ClearPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "ClearPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::SetPath
// Il2CppName: SetPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::Pathfinding::Path*, bool)>(&Pathfinding::AILerp::SetPath)> {
  static const MethodInfo* get() {
    static auto* path = &::il2cpp_utils::GetClassFromName("Pathfinding", "Path")->byval_arg;
    static auto* updateDestinationFromPath = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "SetPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path, updateDestinationFromPath});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::ConfigurePathSwitchInterpolation
// Il2CppName: ConfigurePathSwitchInterpolation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::ConfigurePathSwitchInterpolation)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "ConfigurePathSwitchInterpolation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::GetFeetPosition
// Il2CppName: GetFeetPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::GetFeetPosition)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "GetFeetPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::ConfigureNewPath
// Il2CppName: ConfigureNewPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::ConfigureNewPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "ConfigureNewPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::MovementUpdate
// Il2CppName: MovementUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(float, ByRef<::UnityEngine::Vector3>, ByRef<::UnityEngine::Quaternion>)>(&Pathfinding::AILerp::MovementUpdate)> {
  static const MethodInfo* get() {
    static auto* deltaTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* nextPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* nextRotation = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "MovementUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{deltaTime, nextPosition, nextRotation});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::FinalizeMovement
// Il2CppName: FinalizeMovement
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)(::UnityEngine::Vector3, ::UnityEngine::Quaternion)>(&Pathfinding::AILerp::FinalizeMovement)> {
  static const MethodInfo* get() {
    static auto* nextPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* nextRotation = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "FinalizeMovement", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{nextPosition, nextRotation});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::SimulateRotationTowards
// Il2CppName: SimulateRotationTowards
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Quaternion (Pathfinding::AILerp::*)(::UnityEngine::Vector3, float)>(&Pathfinding::AILerp::SimulateRotationTowards)> {
  static const MethodInfo* get() {
    static auto* direction = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* deltaTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "SimulateRotationTowards", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{direction, deltaTime});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::CalculateNextPosition
// Il2CppName: CalculateNextPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)(ByRef<::UnityEngine::Vector3>, float)>(&Pathfinding::AILerp::CalculateNextPosition)> {
  static const MethodInfo* get() {
    static auto* direction = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* deltaTime = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "CalculateNextPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{direction, deltaTime});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::OnDrawGizmos
// Il2CppName: OnDrawGizmos
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::OnDrawGizmos)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "OnDrawGizmos", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::$Awake$b__91_0
// Il2CppName: <Awake>b__91_0
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::$Awake$b__91_0)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "<Awake>b__91_0", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: Pathfinding::AILerp::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Pathfinding::AILerp::*)()>(&Pathfinding::AILerp::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Pathfinding::AILerp::OnUpgradeSerializedData
// Il2CppName: OnUpgradeSerializedData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Pathfinding::AILerp::*)(int, bool)>(&Pathfinding::AILerp::OnUpgradeSerializedData)> {
  static const MethodInfo* get() {
    static auto* version = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* unityThread = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Pathfinding::AILerp*), "OnUpgradeSerializedData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{version, unityThread});
  }
};
