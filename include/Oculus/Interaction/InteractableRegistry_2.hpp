// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Including type: System.Collections.Generic.IEnumerable`1
#include "System/Collections/Generic/IEnumerable_1.hpp"
// Including type: System.Collections.Generic.IEnumerator`1
#include "System/Collections/Generic/IEnumerator_1.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Oculus::Interaction
namespace Oculus::Interaction {
  // Skipping declaration: InteractableSet because it is already included!
  // Forward declaring type: Interactor`2<TInteractor, TInteractable>
  template<typename TInteractor, typename TInteractable>
  class Interactor_2;
  // Forward declaring type: Interactable`2<TInteractor, TInteractable>
  template<typename TInteractor, typename TInteractable>
  class Interactable_2;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: HashSet`1<T>
  template<typename T>
  class HashSet_1;
  // Forward declaring type: IReadOnlyList`1<T>
  template<typename T>
  class IReadOnlyList_1;
  // Forward declaring type: ISet`1<T>
  template<typename T>
  class ISet_1;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Skipping declaration: IEnumerator because it is already included!
}
// Completed forward declares
// Type namespace: Oculus.Interaction
namespace Oculus::Interaction {
  // Forward declaring type: InteractableRegistry`2<TInteractor, TInteractable>
  template<typename TInteractor, typename TInteractable>
  class InteractableRegistry_2;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(::Oculus::Interaction::InteractableRegistry_2, "Oculus.Interaction", "InteractableRegistry`2");
// Type namespace: Oculus.Interaction
namespace Oculus::Interaction {
  // WARNING Size may be invalid!
  // Autogenerated type: Oculus.Interaction.InteractableRegistry`2
  // [TokenAttribute] Offset: FFFFFFFF
  template<typename TInteractor, typename TInteractable>
  class InteractableRegistry_2 : public ::Il2CppObject {
    public:
    // Nested type: ::Oculus::Interaction::InteractableRegistry_2::InteractableSet<TInteractor, TInteractable>
    struct InteractableSet;
    // WARNING Size may be invalid!
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: Oculus.Interaction.InteractableRegistry`2/InteractableSet
    // [TokenAttribute] Offset: FFFFFFFF
    struct InteractableSet : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::ValueType, public ::System::Collections::Generic::IEnumerable_1<TInteractable>*/ {
      public:
      using declaring_type = InteractableRegistry_2<TInteractor, TInteractable>*;
      static constexpr std::string_view NESTED_NAME = "InteractableSet";
      static constexpr bool IS_VALUE_TYPE = true;
      // Nested type: ::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator<TInteractor, TInteractable>
      struct Enumerator;
      // WARNING Size may be invalid!
      // WARNING Layout: Sequential may not be correctly taken into account!
      // Autogenerated type: Oculus.Interaction.InteractableRegistry`2/InteractableSet/Enumerator
      // [TokenAttribute] Offset: FFFFFFFF
      struct Enumerator : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::ValueType, public ::System::Collections::Generic::IEnumerator_1<TInteractable>*/ {
        public:
        using declaring_type = typename InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet;
        static constexpr std::string_view NESTED_NAME = "Enumerator";
        static constexpr bool IS_VALUE_TYPE = true;
        public:
        // private readonly Oculus.Interaction.InteractableRegistry`2/InteractableSet<TInteractor,TInteractable> _set
        // Size: 0xFFFFFFFF
        // Offset: 0x0
        typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet set;
        // private System.Int32 _position
        // Size: 0x4
        // Offset: 0x0
        int position;
        // Field size check
        static_assert(sizeof(int) == 0x4);
        public:
        // Creating value type constructor for type: Enumerator
        constexpr Enumerator(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet set_ = {}, int position_ = {}) noexcept : set{set_}, position{position_} {}
        // Creating interface conversion operator: operator ::System::ValueType
        operator ::System::ValueType() noexcept {
          return *reinterpret_cast<::System::ValueType*>(this);
        }
        // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerator_1<TInteractable>
        operator ::System::Collections::Generic::IEnumerator_1<TInteractable>() noexcept {
          return *reinterpret_cast<::System::Collections::Generic::IEnumerator_1<TInteractable>*>(this);
        }
        // Autogenerated instance field getter
        // Get instance field: private readonly Oculus.Interaction.InteractableRegistry`2/InteractableSet<TInteractor,TInteractable> _set
        [[deprecated("Use field access instead!")]] typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet& dyn__set() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::dyn__set");
          auto ___internal__instance = *this;
          static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_set"))->offset;
          return *reinterpret_cast<typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
        }
        // Autogenerated instance field getter
        // Get instance field: private System.Int32 _position
        [[deprecated("Use field access instead!")]] int& dyn__position() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::dyn__position");
          auto ___internal__instance = *this;
          static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_position"))->offset;
          return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
        }
        // private System.Collections.Generic.IReadOnlyList`1<TInteractable> get_Data()
        // Offset: 0xFFFFFFFFFFFFFFFF
        ::System::Collections::Generic::IReadOnlyList_1<TInteractable>* get_Data() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::get_Data");
          static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "get_Data", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
          return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::IReadOnlyList_1<TInteractable>*, false>(this, ___internal__method);
        }
        // public System.Void .ctor(in Oculus.Interaction.InteractableRegistry`2/InteractableSet<TInteractor,TInteractable> set)
        // Offset: 0xFFFFFFFFFFFFFFFF
        Enumerator(ByRef<typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet> set) {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::.ctor");
          static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(set)})));
          ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, byref(set));
        }
        // public TInteractable get_Current()
        // Offset: 0xFFFFFFFFFFFFFFFF
        TInteractable get_Current() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::get_Current");
          auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet::Enumerator), -1)));
          return ::il2cpp_utils::RunMethodRethrow<TInteractable, false>(this, ___internal__method);
        }
        // private System.Object System.Collections.IEnumerator.get_Current()
        // Offset: 0xFFFFFFFFFFFFFFFF
        ::Il2CppObject* System_Collections_IEnumerator_get_Current() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::System.Collections.IEnumerator.get_Current");
          auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet::Enumerator), -1)));
          return ::il2cpp_utils::RunMethodRethrow<::Il2CppObject*, false>(this, ___internal__method);
        }
        // public System.Boolean MoveNext()
        // Offset: 0xFFFFFFFFFFFFFFFF
        bool MoveNext() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::MoveNext");
          auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet::Enumerator), -1)));
          return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
        }
        // public System.Void Reset()
        // Offset: 0xFFFFFFFFFFFFFFFF
        void Reset() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::Reset");
          auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet::Enumerator), -1)));
          ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
        }
        // public System.Void Dispose()
        // Offset: 0xFFFFFFFFFFFFFFFF
        void Dispose() {
          static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Enumerator::Dispose");
          auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet::Enumerator), -1)));
          ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
        }
      }; // Oculus.Interaction.InteractableRegistry`2/InteractableSet/Enumerator
      // Could not write size check! Type: Oculus.Interaction.InteractableRegistry`2/InteractableSet/Enumerator is generic, or has no fields that are valid for size checks!
      public:
      // private readonly System.Collections.Generic.IReadOnlyList`1<TInteractable> _data
      // Size: 0x8
      // Offset: 0x0
      ::System::Collections::Generic::IReadOnlyList_1<TInteractable>* data;
      // Field size check
      static_assert(sizeof(::System::Collections::Generic::IReadOnlyList_1<TInteractable>*) == 0x8);
      // private readonly System.Collections.Generic.ISet`1<TInteractable> _onlyInclude
      // Size: 0x8
      // Offset: 0x0
      ::System::Collections::Generic::ISet_1<TInteractable>* onlyInclude;
      // Field size check
      static_assert(sizeof(::System::Collections::Generic::ISet_1<TInteractable>*) == 0x8);
      // private readonly TInteractor _testAgainst
      // Size: 0xFFFFFFFF
      // Offset: 0x0
      TInteractor testAgainst;
      public:
      // Creating value type constructor for type: InteractableSet
      constexpr InteractableSet(::System::Collections::Generic::IReadOnlyList_1<TInteractable>* data_ = {}, ::System::Collections::Generic::ISet_1<TInteractable>* onlyInclude_ = {}, TInteractor testAgainst_ = {}) noexcept : data{data_}, onlyInclude{onlyInclude_}, testAgainst{testAgainst_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerable_1<TInteractable>
      operator ::System::Collections::Generic::IEnumerable_1<TInteractable>() noexcept {
        return *reinterpret_cast<::System::Collections::Generic::IEnumerable_1<TInteractable>*>(this);
      }
      // Autogenerated instance field getter
      // Get instance field: private readonly System.Collections.Generic.IReadOnlyList`1<TInteractable> _data
      [[deprecated("Use field access instead!")]] ::System::Collections::Generic::IReadOnlyList_1<TInteractable>*& dyn__data() {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::dyn__data");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_data"))->offset;
        return *reinterpret_cast<::System::Collections::Generic::IReadOnlyList_1<TInteractable>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: private readonly System.Collections.Generic.ISet`1<TInteractable> _onlyInclude
      [[deprecated("Use field access instead!")]] ::System::Collections::Generic::ISet_1<TInteractable>*& dyn__onlyInclude() {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::dyn__onlyInclude");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_onlyInclude"))->offset;
        return *reinterpret_cast<::System::Collections::Generic::ISet_1<TInteractable>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // Autogenerated instance field getter
      // Get instance field: private readonly TInteractor _testAgainst
      [[deprecated("Use field access instead!")]] TInteractor& dyn__testAgainst() {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::dyn__testAgainst");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_testAgainst"))->offset;
        return *reinterpret_cast<TInteractor*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // public System.Void .ctor(System.Collections.Generic.ISet`1<TInteractable> onlyInclude, TInteractor testAgainst)
      // Offset: 0xFFFFFFFFFFFFFFFF
      InteractableSet(::System::Collections::Generic::ISet_1<TInteractable>* onlyInclude, TInteractor testAgainst) {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::.ctor");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, ".ctor", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(onlyInclude), ::il2cpp_utils::ExtractType(testAgainst)})));
        ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, onlyInclude, testAgainst);
      }
      // public Oculus.Interaction.InteractableRegistry`2/InteractableSet/Enumerator<TInteractor,TInteractable> GetEnumerator()
      // Offset: 0xFFFFFFFFFFFFFFFF
      typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet::Enumerator GetEnumerator() {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::GetEnumerator");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "GetEnumerator", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
        return ::il2cpp_utils::RunMethodRethrow<typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet::Enumerator, false>(this, ___internal__method);
      }
      // private System.Collections.Generic.IEnumerator`1<TInteractable> System.Collections.Generic.IEnumerable<TInteractable>.GetEnumerator()
      // Offset: 0xFFFFFFFFFFFFFFFF
      ::System::Collections::Generic::IEnumerator_1<TInteractable>* System_Collections_Generic_IEnumerable$TInteractable$_GetEnumerator() {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::System.Collections.Generic.IEnumerable<TInteractable>.GetEnumerator");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet), -1)));
        return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::IEnumerator_1<TInteractable>*, false>(this, ___internal__method);
      }
      // private System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      // Offset: 0xFFFFFFFFFFFFFFFF
      ::System::Collections::IEnumerator* System_Collections_IEnumerable_GetEnumerator() {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::System.Collections.IEnumerable.GetEnumerator");
        auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(*this, classof(typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet), -1)));
        return ::il2cpp_utils::RunMethodRethrow<::System::Collections::IEnumerator*, false>(this, ___internal__method);
      }
      // private System.Boolean Include(TInteractable interactable)
      // Offset: 0xFFFFFFFFFFFFFFFF
      bool Include(TInteractable interactable) {
        static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::InteractableSet::Include");
        static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "Include", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(interactable)})));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, interactable);
      }
    }; // Oculus.Interaction.InteractableRegistry`2/InteractableSet
    // Could not write size check! Type: Oculus.Interaction.InteractableRegistry`2/InteractableSet is generic, or has no fields that are valid for size checks!
    // Autogenerated static field getter
    // Get static field: static private System.Collections.Generic.List`1<TInteractable> _interactables
    static ::System::Collections::Generic::List_1<TInteractable>* _get__interactables() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::_get__interactables");
      return THROW_UNLESS((il2cpp_utils::GetFieldValue<::System::Collections::Generic::List_1<TInteractable>*>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<InteractableRegistry_2<TInteractor, TInteractable>*>::get(), "_interactables")));
    }
    // Autogenerated static field setter
    // Set static field: static private System.Collections.Generic.List`1<TInteractable> _interactables
    static void _set__interactables(::System::Collections::Generic::List_1<TInteractable>* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::_set__interactables");
      THROW_UNLESS((il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<InteractableRegistry_2<TInteractor, TInteractable>*>::get(), "_interactables", value)));
    }
    // public System.Void .ctor()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static InteractableRegistry_2<TInteractor, TInteractable>* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<InteractableRegistry_2<TInteractor, TInteractable>*, creationType>()));
    }
    // public System.Void Register(TInteractable interactable)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Register(TInteractable interactable) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::Register");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, interactable);
    }
    // public System.Void Unregister(TInteractable interactable)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Unregister(TInteractable interactable) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::Unregister");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>*), -1)));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, interactable);
    }
    // protected Oculus.Interaction.InteractableRegistry`2/InteractableSet<TInteractor,TInteractable> List(TInteractor interactor, System.Collections.Generic.HashSet`1<TInteractable> onlyInclude)
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet List(TInteractor interactor, ::System::Collections::Generic::HashSet_1<TInteractable>* onlyInclude) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::List");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "List", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(interactor), ::il2cpp_utils::ExtractType(onlyInclude)})));
      return ::il2cpp_utils::RunMethodRethrow<typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet, false>(this, ___internal__method, interactor, onlyInclude);
    }
    // public Oculus.Interaction.InteractableRegistry`2/InteractableSet<TInteractor,TInteractable> List(TInteractor interactor)
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet List(TInteractor interactor) {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::List");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet, false>(this, ___internal__method, interactor);
    }
    // public Oculus.Interaction.InteractableRegistry`2/InteractableSet<TInteractor,TInteractable> List()
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet List() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Oculus::Interaction::InteractableRegistry_2::List");
      auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::ResolveVtableSlot(this, classof(::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>*), -1)));
      return ::il2cpp_utils::RunMethodRethrow<typename ::Oculus::Interaction::InteractableRegistry_2<TInteractor, TInteractable>::InteractableSet, false>(this, ___internal__method);
    }
  }; // Oculus.Interaction.InteractableRegistry`2
  // Could not write size check! Type: Oculus.Interaction.InteractableRegistry`2 is generic, or has no fields that are valid for size checks!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
