// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: emotitron.Compression.LiteCrusher`1
#include "emotitron/Compression/LiteCrusher_1.hpp"
// Including type: emotitron.Compression.LiteFloatCompressType
#include "emotitron/Compression/LiteFloatCompressType.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Type namespace: emotitron.Compression
namespace emotitron::Compression {
  // Forward declaring type: LiteFloatCrusher
  class LiteFloatCrusher;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::emotitron::Compression::LiteFloatCrusher);
DEFINE_IL2CPP_ARG_TYPE(::emotitron::Compression::LiteFloatCrusher*, "emotitron.Compression", "LiteFloatCrusher");
// Type namespace: emotitron.Compression
namespace emotitron::Compression {
  // WARNING Size may be invalid!
  // Autogenerated type: emotitron.Compression.LiteFloatCrusher
  // [TokenAttribute] Offset: FFFFFFFF
  class LiteFloatCrusher : public ::emotitron::Compression::LiteCrusher_1<float> {
    public:
    public:
    // protected System.Single min
    // Size: 0x4
    // Offset: 0x14
    float min;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // protected System.Single max
    // Size: 0x4
    // Offset: 0x18
    float max;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public emotitron.Compression.LiteFloatCompressType compressType
    // Size: 0x4
    // Offset: 0x1C
    ::emotitron::Compression::LiteFloatCompressType compressType;
    // Field size check
    static_assert(sizeof(::emotitron::Compression::LiteFloatCompressType) == 0x4);
    // private System.Boolean accurateCenter
    // Size: 0x1
    // Offset: 0x20
    bool accurateCenter;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Single encoder
    // Size: 0x4
    // Offset: 0x24
    float encoder;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single decoder
    // Size: 0x4
    // Offset: 0x28
    float decoder;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.UInt64 maxCVal
    // Size: 0x8
    // Offset: 0x30
    uint64_t maxCVal;
    // Field size check
    static_assert(sizeof(uint64_t) == 0x8);
    public:
    // Deleting conversion operator: operator int
    constexpr operator int() const noexcept = delete;
    // Get instance field reference: protected System.Single min
    [[deprecated("Use field access instead!")]] float& dyn_min();
    // Get instance field reference: protected System.Single max
    [[deprecated("Use field access instead!")]] float& dyn_max();
    // Get instance field reference: public emotitron.Compression.LiteFloatCompressType compressType
    [[deprecated("Use field access instead!")]] ::emotitron::Compression::LiteFloatCompressType& dyn_compressType();
    // Get instance field reference: private System.Boolean accurateCenter
    [[deprecated("Use field access instead!")]] bool& dyn_accurateCenter();
    // Get instance field reference: private System.Single encoder
    [[deprecated("Use field access instead!")]] float& dyn_encoder();
    // Get instance field reference: private System.Single decoder
    [[deprecated("Use field access instead!")]] float& dyn_decoder();
    // Get instance field reference: private System.UInt64 maxCVal
    [[deprecated("Use field access instead!")]] uint64_t& dyn_maxCVal();
    // public System.Void .ctor(emotitron.Compression.LiteFloatCompressType compressType, System.Single min, System.Single max, System.Boolean accurateCenter)
    // Offset: 0x28C9324
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static LiteFloatCrusher* New_ctor(::emotitron::Compression::LiteFloatCompressType compressType, float min, float max, bool accurateCenter) {
      static auto ___internal__logger = ::Logger::get().WithContext("::emotitron::Compression::LiteFloatCrusher::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<LiteFloatCrusher*, creationType>(compressType, min, max, accurateCenter)));
    }
    // static public System.Void Recalculate(emotitron.Compression.LiteFloatCompressType compressType, System.Single min, System.Single max, System.Boolean accurateCenter, ref System.Int32 bits, ref System.Single encoder, ref System.Single decoder, ref System.UInt64 maxCVal)
    // Offset: 0x28C92C4
    static void Recalculate(::emotitron::Compression::LiteFloatCompressType compressType, float min, float max, bool accurateCenter, ByRef<int> bits, ByRef<float> encoder, ByRef<float> decoder, ByRef<uint64_t> maxCVal);
    // public System.UInt64 Encode(System.Single val)
    // Offset: 0x28C940C
    uint64_t Encode(float val);
    // public System.Single Decode(System.UInt32 cval)
    // Offset: 0x28C94D0
    float Decode(uint cval);
    // public System.UInt64 WriteValue(System.Single val, System.Byte[] buffer, ref System.Int32 bitposition)
    // Offset: 0x28C9590
    uint64_t WriteValue(float val, ::ArrayW<uint8_t> buffer, ByRef<int> bitposition);
    // public System.Single ReadValue(System.Byte[] buffer, ref System.Int32 bitposition)
    // Offset: 0x28C967C
    float ReadValue(::ArrayW<uint8_t> buffer, ByRef<int> bitposition);
    // public System.Void .ctor()
    // Offset: 0x28C9234
    // Implemented from: emotitron.Compression.LiteCrusher`1
    // Base method: System.Void LiteCrusher_1::.ctor()
    // Base method: System.Void LiteCrusher::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static LiteFloatCrusher* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::emotitron::Compression::LiteFloatCrusher::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<LiteFloatCrusher*, creationType>()));
    }
    // public override System.Void WriteCValue(System.UInt32 cval, System.Byte[] buffer, ref System.Int32 bitposition)
    // Offset: 0x28C9664
    // Implemented from: emotitron.Compression.LiteCrusher`1
    // Base method: System.Void LiteCrusher_1::WriteCValue(System.UInt32 cval, System.Byte[] buffer, ref System.Int32 bitposition)
    void WriteCValue(uint cval, ::ArrayW<uint8_t> buffer, ByRef<int> bitposition);
    // public override System.String ToString()
    // Offset: 0x28C9748
    // Implemented from: System.Object
    // Base method: System.String Object::ToString()
    ::StringW ToString();
  }; // emotitron.Compression.LiteFloatCrusher
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::Recalculate
// Il2CppName: Recalculate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::emotitron::Compression::LiteFloatCompressType, float, float, bool, ByRef<int>, ByRef<float>, ByRef<float>, ByRef<uint64_t>)>(&emotitron::Compression::LiteFloatCrusher::Recalculate)> {
  static const MethodInfo* get() {
    static auto* compressType = &::il2cpp_utils::GetClassFromName("emotitron.Compression", "LiteFloatCompressType")->byval_arg;
    static auto* min = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* max = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* accurateCenter = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* bits = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* encoder = &::il2cpp_utils::GetClassFromName("System", "Single")->this_arg;
    static auto* decoder = &::il2cpp_utils::GetClassFromName("System", "Single")->this_arg;
    static auto* maxCVal = &::il2cpp_utils::GetClassFromName("System", "UInt64")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteFloatCrusher*), "Recalculate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{compressType, min, max, accurateCenter, bits, encoder, decoder, maxCVal});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::Encode
// Il2CppName: Encode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<uint64_t (emotitron::Compression::LiteFloatCrusher::*)(float)>(&emotitron::Compression::LiteFloatCrusher::Encode)> {
  static const MethodInfo* get() {
    static auto* val = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteFloatCrusher*), "Encode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{val});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::Decode
// Il2CppName: Decode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (emotitron::Compression::LiteFloatCrusher::*)(uint)>(&emotitron::Compression::LiteFloatCrusher::Decode)> {
  static const MethodInfo* get() {
    static auto* cval = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteFloatCrusher*), "Decode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cval});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::WriteValue
// Il2CppName: WriteValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<uint64_t (emotitron::Compression::LiteFloatCrusher::*)(float, ::ArrayW<uint8_t>, ByRef<int>)>(&emotitron::Compression::LiteFloatCrusher::WriteValue)> {
  static const MethodInfo* get() {
    static auto* val = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* buffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    static auto* bitposition = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteFloatCrusher*), "WriteValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{val, buffer, bitposition});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::ReadValue
// Il2CppName: ReadValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (emotitron::Compression::LiteFloatCrusher::*)(::ArrayW<uint8_t>, ByRef<int>)>(&emotitron::Compression::LiteFloatCrusher::ReadValue)> {
  static const MethodInfo* get() {
    static auto* buffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    static auto* bitposition = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteFloatCrusher*), "ReadValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{buffer, bitposition});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::WriteCValue
// Il2CppName: WriteCValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (emotitron::Compression::LiteFloatCrusher::*)(uint, ::ArrayW<uint8_t>, ByRef<int>)>(&emotitron::Compression::LiteFloatCrusher::WriteCValue)> {
  static const MethodInfo* get() {
    static auto* cval = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* buffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    static auto* bitposition = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteFloatCrusher*), "WriteCValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cval, buffer, bitposition});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteFloatCrusher::ToString
// Il2CppName: ToString
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (emotitron::Compression::LiteFloatCrusher::*)()>(&emotitron::Compression::LiteFloatCrusher::ToString)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteFloatCrusher*), "ToString", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
