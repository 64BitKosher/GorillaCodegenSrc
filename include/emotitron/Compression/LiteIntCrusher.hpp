// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: emotitron.Compression.LiteCrusher`1
#include "emotitron/Compression/LiteCrusher_1.hpp"
// Including type: emotitron.Compression.LiteIntCompressType
#include "emotitron/Compression/LiteIntCompressType.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Type namespace: emotitron.Compression
namespace emotitron::Compression {
  // Forward declaring type: LiteIntCrusher
  class LiteIntCrusher;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::emotitron::Compression::LiteIntCrusher);
DEFINE_IL2CPP_ARG_TYPE(::emotitron::Compression::LiteIntCrusher*, "emotitron.Compression", "LiteIntCrusher");
// Type namespace: emotitron.Compression
namespace emotitron::Compression {
  // WARNING Size may be invalid!
  // Autogenerated type: emotitron.Compression.LiteIntCrusher
  // [TokenAttribute] Offset: FFFFFFFF
  class LiteIntCrusher : public ::emotitron::Compression::LiteCrusher_1<int> {
    public:
    public:
    // public emotitron.Compression.LiteIntCompressType compressType
    // Size: 0x4
    // Offset: 0x14
    ::emotitron::Compression::LiteIntCompressType compressType;
    // Field size check
    static_assert(sizeof(::emotitron::Compression::LiteIntCompressType) == 0x4);
    // protected System.Int32 min
    // Size: 0x4
    // Offset: 0x18
    int min;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // protected System.Int32 max
    // Size: 0x4
    // Offset: 0x1C
    int max;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 smallest
    // Size: 0x4
    // Offset: 0x20
    int smallest;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 biggest
    // Size: 0x4
    // Offset: 0x24
    int biggest;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // Deleting conversion operator: operator int
    constexpr operator int() const noexcept = delete;
    // Get instance field reference: public emotitron.Compression.LiteIntCompressType compressType
    [[deprecated("Use field access instead!")]] ::emotitron::Compression::LiteIntCompressType& dyn_compressType();
    // Get instance field reference: protected System.Int32 min
    [[deprecated("Use field access instead!")]] int& dyn_min();
    // Get instance field reference: protected System.Int32 max
    [[deprecated("Use field access instead!")]] int& dyn_max();
    // Get instance field reference: private System.Int32 smallest
    [[deprecated("Use field access instead!")]] int& dyn_smallest();
    // Get instance field reference: private System.Int32 biggest
    [[deprecated("Use field access instead!")]] int& dyn_biggest();
    // public System.Void .ctor(emotitron.Compression.LiteIntCompressType comType, System.Int32 min, System.Int32 max)
    // Offset: 0x28C9A98
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static LiteIntCrusher* New_ctor(::emotitron::Compression::LiteIntCompressType comType, int min, int max) {
      static auto ___internal__logger = ::Logger::get().WithContext("::emotitron::Compression::LiteIntCrusher::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<LiteIntCrusher*, creationType>(comType, min, max)));
    }
    // public System.UInt64 WriteValue(System.Int32 val, System.Byte[] buffer, ref System.Int32 bitposition)
    // Offset: 0x28C9B40
    uint64_t WriteValue(int val, ::ArrayW<uint8_t> buffer, ByRef<int> bitposition);
    // public System.Int32 ReadValue(System.Byte[] buffer, ref System.Int32 bitposition)
    // Offset: 0x28C9C18
    int ReadValue(::ArrayW<uint8_t> buffer, ByRef<int> bitposition);
    // public System.UInt64 Encode(System.Int32 value)
    // Offset: 0x28C9CA4
    uint64_t Encode(int value);
    // public System.Int32 Decode(System.UInt32 cvalue)
    // Offset: 0x28C9CC4
    int Decode(uint cvalue);
    // static public System.Void Recalculate(System.Int32 min, System.Int32 max, ref System.Int32 smallest, ref System.Int32 biggest, ref System.Int32 bits)
    // Offset: 0x28C9A5C
    static void Recalculate(int min, int max, ByRef<int> smallest, ByRef<int> biggest, ByRef<int> bits);
    // public System.Void .ctor()
    // Offset: 0x28C99FC
    // Implemented from: emotitron.Compression.LiteCrusher`1
    // Base method: System.Void LiteCrusher_1::.ctor()
    // Base method: System.Void LiteCrusher::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static LiteIntCrusher* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::emotitron::Compression::LiteIntCrusher::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<LiteIntCrusher*, creationType>()));
    }
    // public override System.Void WriteCValue(System.UInt32 cval, System.Byte[] buffer, ref System.Int32 bitposition)
    // Offset: 0x28C9BD0
    // Implemented from: emotitron.Compression.LiteCrusher`1
    // Base method: System.Void LiteCrusher_1::WriteCValue(System.UInt32 cval, System.Byte[] buffer, ref System.Int32 bitposition)
    void WriteCValue(uint cval, ::ArrayW<uint8_t> buffer, ByRef<int> bitposition);
    // public override System.String ToString()
    // Offset: 0x28C9CD0
    // Implemented from: System.Object
    // Base method: System.String Object::ToString()
    ::StringW ToString();
  }; // emotitron.Compression.LiteIntCrusher
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::WriteValue
// Il2CppName: WriteValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<uint64_t (emotitron::Compression::LiteIntCrusher::*)(int, ::ArrayW<uint8_t>, ByRef<int>)>(&emotitron::Compression::LiteIntCrusher::WriteValue)> {
  static const MethodInfo* get() {
    static auto* val = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* buffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    static auto* bitposition = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteIntCrusher*), "WriteValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{val, buffer, bitposition});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::ReadValue
// Il2CppName: ReadValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (emotitron::Compression::LiteIntCrusher::*)(::ArrayW<uint8_t>, ByRef<int>)>(&emotitron::Compression::LiteIntCrusher::ReadValue)> {
  static const MethodInfo* get() {
    static auto* buffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    static auto* bitposition = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteIntCrusher*), "ReadValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{buffer, bitposition});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::Encode
// Il2CppName: Encode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<uint64_t (emotitron::Compression::LiteIntCrusher::*)(int)>(&emotitron::Compression::LiteIntCrusher::Encode)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteIntCrusher*), "Encode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::Decode
// Il2CppName: Decode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (emotitron::Compression::LiteIntCrusher::*)(uint)>(&emotitron::Compression::LiteIntCrusher::Decode)> {
  static const MethodInfo* get() {
    static auto* cvalue = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteIntCrusher*), "Decode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cvalue});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::Recalculate
// Il2CppName: Recalculate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(int, int, ByRef<int>, ByRef<int>, ByRef<int>)>(&emotitron::Compression::LiteIntCrusher::Recalculate)> {
  static const MethodInfo* get() {
    static auto* min = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* max = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* smallest = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* biggest = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* bits = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteIntCrusher*), "Recalculate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{min, max, smallest, biggest, bits});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::WriteCValue
// Il2CppName: WriteCValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (emotitron::Compression::LiteIntCrusher::*)(uint, ::ArrayW<uint8_t>, ByRef<int>)>(&emotitron::Compression::LiteIntCrusher::WriteCValue)> {
  static const MethodInfo* get() {
    static auto* cval = &::il2cpp_utils::GetClassFromName("System", "UInt32")->byval_arg;
    static auto* buffer = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    static auto* bitposition = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteIntCrusher*), "WriteCValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cval, buffer, bitposition});
  }
};
// Writing MetadataGetter for method: emotitron::Compression::LiteIntCrusher::ToString
// Il2CppName: ToString
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (emotitron::Compression::LiteIntCrusher::*)()>(&emotitron::Compression::LiteIntCrusher::ToString)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(emotitron::Compression::LiteIntCrusher*), "ToString", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
