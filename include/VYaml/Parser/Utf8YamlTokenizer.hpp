// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Including type: System.Buffers.SequenceReader`1
#include "System/Buffers/SequenceReader_1.hpp"
// Including type: VYaml.Parser.Marker
#include "VYaml/Parser/Marker.hpp"
// Including type: VYaml.Parser.Token
#include "VYaml/Parser/Token.hpp"
// Including type: VYaml.Parser.SimpleKeyState
#include "VYaml/Parser/SimpleKeyState.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: VYaml::Internal
namespace VYaml::Internal {
  // Forward declaring type: InsertionQueue`1<T>
  template<typename T>
  class InsertionQueue_1;
  // Forward declaring type: ExpandBuffer`1<T>
  template<typename T>
  class ExpandBuffer_1;
  // Forward declaring type: LineBreakState
  struct LineBreakState;
}
// Forward declaring namespace: VYaml::Parser
namespace VYaml::Parser {
  // Skipping declaration: TokenType because it is already included!
  // Forward declaring type: ITokenContent
  class ITokenContent;
  // Forward declaring type: Scalar
  class Scalar;
}
// Forward declaring namespace: System::Buffers
namespace System::Buffers {
  // Skipping declaration: ReadOnlySequence`1 because it is already included!
}
// Completed forward declares
// Type namespace: VYaml.Parser
namespace VYaml::Parser {
  // Forward declaring type: Utf8YamlTokenizer
  struct Utf8YamlTokenizer;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::VYaml::Parser::Utf8YamlTokenizer, "VYaml.Parser", "Utf8YamlTokenizer");
// Type namespace: VYaml.Parser
namespace VYaml::Parser {
  // WARNING Size may be invalid!
  // WARNING Layout: Sequential may not be correctly taken into account!
  // Autogenerated type: VYaml.Parser.Utf8YamlTokenizer
  // [TokenAttribute] Offset: FFFFFFFF
  // [NullableContextAttribute] Offset: FFFFFFFF
  // [NullableAttribute] Offset: FFFFFFFF
  // [IsByRefLikeAttribute] Offset: FFFFFFFF
  // [ObsoleteAttribute] Offset: FFFFFFFF
  struct Utf8YamlTokenizer/*, public ::System::ValueType*/ {
    public:
    public:
    // private System.Buffers.SequenceReader`1<System.Byte> reader
    // Size: 0xFFFFFFFF
    // Offset: 0x0
    ::System::Buffers::SequenceReader_1<uint8_t> reader;
    // private VYaml.Parser.Marker mark
    // Size: 0xC
    // Offset: 0x68
    ::VYaml::Parser::Marker mark;
    // Field size check
    static_assert(sizeof(::VYaml::Parser::Marker) == 0xC);
    // private VYaml.Parser.Token currentToken
    // Size: 0x10
    // Offset: 0x78
    ::VYaml::Parser::Token currentToken;
    // Field size check
    static_assert(sizeof(::VYaml::Parser::Token) == 0x10);
    // private System.Boolean streamStartProduced
    // Size: 0x1
    // Offset: 0x88
    bool streamStartProduced;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean streamEndProduced
    // Size: 0x1
    // Offset: 0x89
    bool streamEndProduced;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Byte currentCode
    // Size: 0x1
    // Offset: 0x8A
    uint8_t currentCode;
    // Field size check
    static_assert(sizeof(uint8_t) == 0x1);
    // private System.Int32 indent
    // Size: 0x4
    // Offset: 0x8C
    int indent;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean simpleKeyAllowed
    // Size: 0x1
    // Offset: 0x90
    bool simpleKeyAllowed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Int32 adjacentValueAllowedAt
    // Size: 0x4
    // Offset: 0x94
    int adjacentValueAllowedAt;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 flowLevel
    // Size: 0x4
    // Offset: 0x98
    int flowLevel;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 tokensParsed
    // Size: 0x4
    // Offset: 0x9C
    int tokensParsed;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean tokenAvailable
    // Size: 0x1
    // Offset: 0xA0
    bool tokenAvailable;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private readonly VYaml.Internal.InsertionQueue`1<VYaml.Parser.Token> tokens
    // Size: 0x8
    // Offset: 0xA8
    ::VYaml::Internal::InsertionQueue_1<::VYaml::Parser::Token>* tokens;
    // Field size check
    static_assert(sizeof(::VYaml::Internal::InsertionQueue_1<::VYaml::Parser::Token>*) == 0x8);
    // private readonly VYaml.Internal.ExpandBuffer`1<VYaml.Parser.SimpleKeyState> simpleKeyCandidates
    // Size: 0x8
    // Offset: 0xB0
    ::VYaml::Internal::ExpandBuffer_1<::VYaml::Parser::SimpleKeyState>* simpleKeyCandidates;
    // Field size check
    static_assert(sizeof(::VYaml::Internal::ExpandBuffer_1<::VYaml::Parser::SimpleKeyState>*) == 0x8);
    // private readonly VYaml.Internal.ExpandBuffer`1<System.Int32> indents
    // Size: 0x8
    // Offset: 0xB8
    ::VYaml::Internal::ExpandBuffer_1<int>* indents;
    // Field size check
    static_assert(sizeof(::VYaml::Internal::ExpandBuffer_1<int>*) == 0x8);
    public:
    // Creating value type constructor for type: Utf8YamlTokenizer
    constexpr Utf8YamlTokenizer(::System::Buffers::SequenceReader_1<uint8_t> reader_ = {}, ::VYaml::Parser::Marker mark_ = {}, ::VYaml::Parser::Token currentToken_ = {}, bool streamStartProduced_ = {}, bool streamEndProduced_ = {}, uint8_t currentCode_ = {}, int indent_ = {}, bool simpleKeyAllowed_ = {}, int adjacentValueAllowedAt_ = {}, int flowLevel_ = {}, int tokensParsed_ = {}, bool tokenAvailable_ = {}, ::VYaml::Internal::InsertionQueue_1<::VYaml::Parser::Token>* tokens_ = {}, ::VYaml::Internal::ExpandBuffer_1<::VYaml::Parser::SimpleKeyState>* simpleKeyCandidates_ = {}, ::VYaml::Internal::ExpandBuffer_1<int>* indents_ = {}) noexcept : reader{reader_}, mark{mark_}, currentToken{currentToken_}, streamStartProduced{streamStartProduced_}, streamEndProduced{streamEndProduced_}, currentCode{currentCode_}, indent{indent_}, simpleKeyAllowed{simpleKeyAllowed_}, adjacentValueAllowedAt{adjacentValueAllowedAt_}, flowLevel{flowLevel_}, tokensParsed{tokensParsed_}, tokenAvailable{tokenAvailable_}, tokens{tokens_}, simpleKeyCandidates{simpleKeyCandidates_}, indents{indents_} {}
    // Creating interface conversion operator: operator ::System::ValueType
    operator ::System::ValueType() noexcept {
      return *reinterpret_cast<::System::ValueType*>(this);
    }
    // Get static field: static private VYaml.Internal.InsertionQueue`1<VYaml.Parser.Token> tokensBufferStatic
    static ::VYaml::Internal::InsertionQueue_1<::VYaml::Parser::Token>* _get_tokensBufferStatic();
    // Set static field: static private VYaml.Internal.InsertionQueue`1<VYaml.Parser.Token> tokensBufferStatic
    static void _set_tokensBufferStatic(::VYaml::Internal::InsertionQueue_1<::VYaml::Parser::Token>* value);
    // Get static field: static private VYaml.Internal.ExpandBuffer`1<VYaml.Parser.SimpleKeyState> simpleKeyBufferStatic
    static ::VYaml::Internal::ExpandBuffer_1<::VYaml::Parser::SimpleKeyState>* _get_simpleKeyBufferStatic();
    // Set static field: static private VYaml.Internal.ExpandBuffer`1<VYaml.Parser.SimpleKeyState> simpleKeyBufferStatic
    static void _set_simpleKeyBufferStatic(::VYaml::Internal::ExpandBuffer_1<::VYaml::Parser::SimpleKeyState>* value);
    // Get static field: static private VYaml.Internal.ExpandBuffer`1<System.Int32> indentsBufferStatic
    static ::VYaml::Internal::ExpandBuffer_1<int>* _get_indentsBufferStatic();
    // Set static field: static private VYaml.Internal.ExpandBuffer`1<System.Int32> indentsBufferStatic
    static void _set_indentsBufferStatic(::VYaml::Internal::ExpandBuffer_1<int>* value);
    // Get static field: static private VYaml.Internal.ExpandBuffer`1<System.Byte> lineBreaksBufferStatic
    static ::VYaml::Internal::ExpandBuffer_1<uint8_t>* _get_lineBreaksBufferStatic();
    // Set static field: static private VYaml.Internal.ExpandBuffer`1<System.Byte> lineBreaksBufferStatic
    static void _set_lineBreaksBufferStatic(::VYaml::Internal::ExpandBuffer_1<uint8_t>* value);
    // Get instance field reference: private System.Buffers.SequenceReader`1<System.Byte> reader
    [[deprecated("Use field access instead!")]] ::System::Buffers::SequenceReader_1<uint8_t>& dyn_reader();
    // Get instance field reference: private VYaml.Parser.Marker mark
    [[deprecated("Use field access instead!")]] ::VYaml::Parser::Marker& dyn_mark();
    // Get instance field reference: private VYaml.Parser.Token currentToken
    [[deprecated("Use field access instead!")]] ::VYaml::Parser::Token& dyn_currentToken();
    // Get instance field reference: private System.Boolean streamStartProduced
    [[deprecated("Use field access instead!")]] bool& dyn_streamStartProduced();
    // Get instance field reference: private System.Boolean streamEndProduced
    [[deprecated("Use field access instead!")]] bool& dyn_streamEndProduced();
    // Get instance field reference: private System.Byte currentCode
    [[deprecated("Use field access instead!")]] uint8_t& dyn_currentCode();
    // Get instance field reference: private System.Int32 indent
    [[deprecated("Use field access instead!")]] int& dyn_indent();
    // Get instance field reference: private System.Boolean simpleKeyAllowed
    [[deprecated("Use field access instead!")]] bool& dyn_simpleKeyAllowed();
    // Get instance field reference: private System.Int32 adjacentValueAllowedAt
    [[deprecated("Use field access instead!")]] int& dyn_adjacentValueAllowedAt();
    // Get instance field reference: private System.Int32 flowLevel
    [[deprecated("Use field access instead!")]] int& dyn_flowLevel();
    // Get instance field reference: private System.Int32 tokensParsed
    [[deprecated("Use field access instead!")]] int& dyn_tokensParsed();
    // Get instance field reference: private System.Boolean tokenAvailable
    [[deprecated("Use field access instead!")]] bool& dyn_tokenAvailable();
    // Get instance field reference: private readonly VYaml.Internal.InsertionQueue`1<VYaml.Parser.Token> tokens
    [[deprecated("Use field access instead!")]] ::VYaml::Internal::InsertionQueue_1<::VYaml::Parser::Token>*& dyn_tokens();
    // Get instance field reference: private readonly VYaml.Internal.ExpandBuffer`1<VYaml.Parser.SimpleKeyState> simpleKeyCandidates
    [[deprecated("Use field access instead!")]] ::VYaml::Internal::ExpandBuffer_1<::VYaml::Parser::SimpleKeyState>*& dyn_simpleKeyCandidates();
    // Get instance field reference: private readonly VYaml.Internal.ExpandBuffer`1<System.Int32> indents
    [[deprecated("Use field access instead!")]] ::VYaml::Internal::ExpandBuffer_1<int>*& dyn_indents();
    // public VYaml.Parser.TokenType get_CurrentTokenType()
    // Offset: 0x5734418
    ::VYaml::Parser::TokenType get_CurrentTokenType();
    // public VYaml.Parser.Marker get_CurrentMark()
    // Offset: 0x5734420
    ::VYaml::Parser::Marker get_CurrentMark();
    // public System.Void .ctor(System.Buffers.ReadOnlySequence`1<System.Byte> sequence)
    // Offset: 0x5734430
    Utf8YamlTokenizer(::System::Buffers::ReadOnlySequence_1<uint8_t> sequence);
    // public System.Boolean Read()
    // Offset: 0x57346FC
    bool Read();
    // T TakeCurrentTokenContent()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T TakeCurrentTokenContent() {
      static_assert(std::is_convertible_v<std::remove_pointer_t<T>, ::VYaml::Parser::ITokenContent>);
      static auto ___internal__logger = ::Logger::get().WithContext("::VYaml::Parser::Utf8YamlTokenizer::TakeCurrentTokenContent");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "TakeCurrentTokenContent", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T, false>(this, ___generic__method);
    }
    // System.Boolean TrySkipUnityStrippedSymbol()
    // Offset: 0x5734900
    bool TrySkipUnityStrippedSymbol();
    // private System.Void ConsumeMoreTokens()
    // Offset: 0x573481C
    void ConsumeMoreTokens();
    // private System.Void ConsumeNextToken()
    // Offset: 0x5734B30
    void ConsumeNextToken();
    // private System.Void ConsumeStreamStart()
    // Offset: 0x5735118
    void ConsumeStreamStart();
    // private System.Void ConsumeStreamEnd()
    // Offset: 0x5735528
    void ConsumeStreamEnd();
    // private System.Void ConsumeBom()
    // Offset: 0x57394DC
    void ConsumeBom();
    // private System.Void ConsumeDirective()
    // Offset: 0x57355D4
    void ConsumeDirective();
    // private System.Void ConsumeDirectiveName(VYaml.Parser.Scalar result)
    // Offset: 0x57396D8
    void ConsumeDirectiveName(::VYaml::Parser::Scalar* result);
    // private System.Void ConsumeVersionDirectiveValue()
    // Offset: 0x5739924
    void ConsumeVersionDirectiveValue();
    // private System.Int32 ConsumeVersionDirectiveNumber()
    // Offset: 0x5739FD8
    int ConsumeVersionDirectiveNumber();
    // private System.Void ConsumeTagDirectiveValue()
    // Offset: 0x5739AB0
    void ConsumeTagDirectiveValue();
    // private System.Void ConsumeDocumentIndicator(VYaml.Parser.TokenType tokenType)
    // Offset: 0x5735DF4
    void ConsumeDocumentIndicator(::VYaml::Parser::TokenType tokenType);
    // private System.Void ConsumeFlowCollectionStart(VYaml.Parser.TokenType tokenType)
    // Offset: 0x5735E9C
    void ConsumeFlowCollectionStart(::VYaml::Parser::TokenType tokenType);
    // private System.Void ConsumeFlowCollectionEnd(VYaml.Parser.TokenType tokenType)
    // Offset: 0x5736054
    void ConsumeFlowCollectionEnd(::VYaml::Parser::TokenType tokenType);
    // private System.Void ConsumeFlowEntryStart()
    // Offset: 0x5736198
    void ConsumeFlowEntryStart();
    // private System.Void ConsumeBlockEntry()
    // Offset: 0x5736238
    void ConsumeBlockEntry();
    // private System.Void ConsumeComplexKeyStart()
    // Offset: 0x5736394
    void ConsumeComplexKeyStart();
    // private System.Void ConsumeValueStart()
    // Offset: 0x57364D4
    void ConsumeValueStart();
    // private System.Void ConsumeAnchor(System.Boolean alias)
    // Offset: 0x5736744
    void ConsumeAnchor(bool alias);
    // private System.Void ConsumeTag()
    // Offset: 0x5736A48
    void ConsumeTag();
    // private System.Void ConsumeTagHandle(System.Boolean directive, VYaml.Parser.Scalar buf)
    // Offset: 0x573A19C
    void ConsumeTagHandle(bool directive, ::VYaml::Parser::Scalar* buf);
    // private System.Void ConsumeTagPrefix(VYaml.Parser.Scalar prefix)
    // Offset: 0x573A5BC
    void ConsumeTagPrefix(::VYaml::Parser::Scalar* prefix);
    // private System.Boolean TryConsumeUriChar(VYaml.Parser.Scalar scalar)
    // Offset: 0x573AB68
    bool TryConsumeUriChar(::VYaml::Parser::Scalar* scalar);
    // private System.Boolean TryConsumeTagChar(VYaml.Parser.Scalar scalar)
    // Offset: 0x573B0A8
    bool TryConsumeTagChar(::VYaml::Parser::Scalar* scalar);
    // private System.Int32 ConsumeUriEscapes()
    // Offset: 0x573AD54
    int ConsumeUriEscapes();
    // private System.Void ConsumeBlockScaler(System.Boolean literal)
    // Offset: 0x573716C
    void ConsumeBlockScaler(bool literal);
    // private System.Void ConsumeBlockScalarBreaks(ref System.Int32 blockIndent, ref VYaml.Internal.ExpandBuffer`1<System.Byte> blockLineBreaks)
    // Offset: 0x573B278
    void ConsumeBlockScalarBreaks(ByRef<int> blockIndent, ByRef<::VYaml::Internal::ExpandBuffer_1<uint8_t>*> blockLineBreaks);
    // private System.Void ConsumeFlowScaler(System.Boolean singleQuote)
    // Offset: 0x5737A78
    void ConsumeFlowScaler(bool singleQuote);
    // private System.Void ConsumePlainScalar()
    // Offset: 0x5738C54
    void ConsumePlainScalar();
    // private System.Void SkipToNextToken()
    // Offset: 0x57352A0
    void SkipToNextToken();
    // private System.Void Advance(System.Int32 offset)
    // Offset: 0x573B600
    void Advance(int offset);
    // private VYaml.Internal.LineBreakState ConsumeLineBreaks()
    // Offset: 0x5739EFC
    ::VYaml::Internal::LineBreakState ConsumeLineBreaks();
    // private System.Void StaleSimpleKeyCandidates()
    // Offset: 0x5734A1C
    void StaleSimpleKeyCandidates();
    // private System.Void SaveSimpleKeyCandidate()
    // Offset: 0x573A85C
    void SaveSimpleKeyCandidate();
    // private System.Void RemoveSimpleKeyCandidate()
    // Offset: 0x57393F8
    void RemoveSimpleKeyCandidate();
    // private System.Void RollIndent(System.Int32 colTo, in VYaml.Parser.Token nextToken, System.Int32 insertNumber)
    // Offset: 0x573A9CC
    void RollIndent(int colTo, ByRef<::VYaml::Parser::Token> nextToken, int insertNumber);
    // private System.Void UnrollIndent(System.Int32 col)
    // Offset: 0x57353E0
    void UnrollIndent(int col);
    // private System.Void IncreaseFlowLevel()
    // Offset: 0x573B714
    void IncreaseFlowLevel();
    // private System.Void DecreaseFlowLevel()
    // Offset: 0x573B850
    void DecreaseFlowLevel();
    // private System.Boolean IsEmptyNext(System.Int32 offset)
    // Offset: 0x5735BAC
    bool IsEmptyNext(int offset);
    // private System.Boolean TryPeek(System.Int64 offset, out System.Byte value)
    // Offset: 0x573B914
    bool TryPeek(int64_t offset, ByRef<uint8_t> value);
  }; // VYaml.Parser.Utf8YamlTokenizer
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::get_CurrentTokenType
// Il2CppName: get_CurrentTokenType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::VYaml::Parser::TokenType (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::get_CurrentTokenType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "get_CurrentTokenType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::get_CurrentMark
// Il2CppName: get_CurrentMark
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::VYaml::Parser::Marker (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::get_CurrentMark)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "get_CurrentMark", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::Utf8YamlTokenizer
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::Read
// Il2CppName: Read
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::Read)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "Read", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::TakeCurrentTokenContent
// Il2CppName: TakeCurrentTokenContent
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::TrySkipUnityStrippedSymbol
// Il2CppName: TrySkipUnityStrippedSymbol
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::TrySkipUnityStrippedSymbol)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "TrySkipUnityStrippedSymbol", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeMoreTokens
// Il2CppName: ConsumeMoreTokens
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeMoreTokens)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeMoreTokens", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeNextToken
// Il2CppName: ConsumeNextToken
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeNextToken)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeNextToken", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeStreamStart
// Il2CppName: ConsumeStreamStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeStreamStart)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeStreamStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeStreamEnd
// Il2CppName: ConsumeStreamEnd
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeStreamEnd)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeStreamEnd", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeBom
// Il2CppName: ConsumeBom
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeBom)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeBom", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeDirective
// Il2CppName: ConsumeDirective
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeDirective)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeDirective", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeDirectiveName
// Il2CppName: ConsumeDirectiveName
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(::VYaml::Parser::Scalar*)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeDirectiveName)> {
  static const MethodInfo* get() {
    static auto* result = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "Scalar")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeDirectiveName", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{result});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeVersionDirectiveValue
// Il2CppName: ConsumeVersionDirectiveValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeVersionDirectiveValue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeVersionDirectiveValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeVersionDirectiveNumber
// Il2CppName: ConsumeVersionDirectiveNumber
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeVersionDirectiveNumber)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeVersionDirectiveNumber", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeTagDirectiveValue
// Il2CppName: ConsumeTagDirectiveValue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeTagDirectiveValue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeTagDirectiveValue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeDocumentIndicator
// Il2CppName: ConsumeDocumentIndicator
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(::VYaml::Parser::TokenType)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeDocumentIndicator)> {
  static const MethodInfo* get() {
    static auto* tokenType = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "TokenType")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeDocumentIndicator", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tokenType});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowCollectionStart
// Il2CppName: ConsumeFlowCollectionStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(::VYaml::Parser::TokenType)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowCollectionStart)> {
  static const MethodInfo* get() {
    static auto* tokenType = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "TokenType")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeFlowCollectionStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tokenType});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowCollectionEnd
// Il2CppName: ConsumeFlowCollectionEnd
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(::VYaml::Parser::TokenType)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowCollectionEnd)> {
  static const MethodInfo* get() {
    static auto* tokenType = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "TokenType")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeFlowCollectionEnd", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{tokenType});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowEntryStart
// Il2CppName: ConsumeFlowEntryStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowEntryStart)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeFlowEntryStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeBlockEntry
// Il2CppName: ConsumeBlockEntry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeBlockEntry)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeBlockEntry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeComplexKeyStart
// Il2CppName: ConsumeComplexKeyStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeComplexKeyStart)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeComplexKeyStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeValueStart
// Il2CppName: ConsumeValueStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeValueStart)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeValueStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeAnchor
// Il2CppName: ConsumeAnchor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(bool)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeAnchor)> {
  static const MethodInfo* get() {
    static auto* alias = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeAnchor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{alias});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeTag
// Il2CppName: ConsumeTag
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeTag)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeTag", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeTagHandle
// Il2CppName: ConsumeTagHandle
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(bool, ::VYaml::Parser::Scalar*)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeTagHandle)> {
  static const MethodInfo* get() {
    static auto* directive = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* buf = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "Scalar")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeTagHandle", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{directive, buf});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeTagPrefix
// Il2CppName: ConsumeTagPrefix
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(::VYaml::Parser::Scalar*)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeTagPrefix)> {
  static const MethodInfo* get() {
    static auto* prefix = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "Scalar")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeTagPrefix", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{prefix});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::TryConsumeUriChar
// Il2CppName: TryConsumeUriChar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (VYaml::Parser::Utf8YamlTokenizer::*)(::VYaml::Parser::Scalar*)>(&VYaml::Parser::Utf8YamlTokenizer::TryConsumeUriChar)> {
  static const MethodInfo* get() {
    static auto* scalar = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "Scalar")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "TryConsumeUriChar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scalar});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::TryConsumeTagChar
// Il2CppName: TryConsumeTagChar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (VYaml::Parser::Utf8YamlTokenizer::*)(::VYaml::Parser::Scalar*)>(&VYaml::Parser::Utf8YamlTokenizer::TryConsumeTagChar)> {
  static const MethodInfo* get() {
    static auto* scalar = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "Scalar")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "TryConsumeTagChar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{scalar});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeUriEscapes
// Il2CppName: ConsumeUriEscapes
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeUriEscapes)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeUriEscapes", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeBlockScaler
// Il2CppName: ConsumeBlockScaler
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(bool)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeBlockScaler)> {
  static const MethodInfo* get() {
    static auto* literal = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeBlockScaler", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{literal});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeBlockScalarBreaks
// Il2CppName: ConsumeBlockScalarBreaks
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(ByRef<int>, ByRef<::VYaml::Internal::ExpandBuffer_1<uint8_t>*>)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeBlockScalarBreaks)> {
  static const MethodInfo* get() {
    static auto* blockIndent = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    static auto* blockLineBreaks = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("VYaml.Internal", "ExpandBuffer`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Byte")})->this_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeBlockScalarBreaks", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{blockIndent, blockLineBreaks});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowScaler
// Il2CppName: ConsumeFlowScaler
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(bool)>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeFlowScaler)> {
  static const MethodInfo* get() {
    static auto* singleQuote = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeFlowScaler", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{singleQuote});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumePlainScalar
// Il2CppName: ConsumePlainScalar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumePlainScalar)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumePlainScalar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::SkipToNextToken
// Il2CppName: SkipToNextToken
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::SkipToNextToken)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "SkipToNextToken", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::Advance
// Il2CppName: Advance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(int)>(&VYaml::Parser::Utf8YamlTokenizer::Advance)> {
  static const MethodInfo* get() {
    static auto* offset = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "Advance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{offset});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::ConsumeLineBreaks
// Il2CppName: ConsumeLineBreaks
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::VYaml::Internal::LineBreakState (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::ConsumeLineBreaks)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "ConsumeLineBreaks", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::StaleSimpleKeyCandidates
// Il2CppName: StaleSimpleKeyCandidates
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::StaleSimpleKeyCandidates)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "StaleSimpleKeyCandidates", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::SaveSimpleKeyCandidate
// Il2CppName: SaveSimpleKeyCandidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::SaveSimpleKeyCandidate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "SaveSimpleKeyCandidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::RemoveSimpleKeyCandidate
// Il2CppName: RemoveSimpleKeyCandidate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::RemoveSimpleKeyCandidate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "RemoveSimpleKeyCandidate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::RollIndent
// Il2CppName: RollIndent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(int, ByRef<::VYaml::Parser::Token>, int)>(&VYaml::Parser::Utf8YamlTokenizer::RollIndent)> {
  static const MethodInfo* get() {
    static auto* colTo = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* nextToken = &::il2cpp_utils::GetClassFromName("VYaml.Parser", "Token")->this_arg;
    static auto* insertNumber = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "RollIndent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{colTo, nextToken, insertNumber});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::UnrollIndent
// Il2CppName: UnrollIndent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)(int)>(&VYaml::Parser::Utf8YamlTokenizer::UnrollIndent)> {
  static const MethodInfo* get() {
    static auto* col = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "UnrollIndent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{col});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::IncreaseFlowLevel
// Il2CppName: IncreaseFlowLevel
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::IncreaseFlowLevel)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "IncreaseFlowLevel", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::DecreaseFlowLevel
// Il2CppName: DecreaseFlowLevel
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (VYaml::Parser::Utf8YamlTokenizer::*)()>(&VYaml::Parser::Utf8YamlTokenizer::DecreaseFlowLevel)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "DecreaseFlowLevel", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::IsEmptyNext
// Il2CppName: IsEmptyNext
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (VYaml::Parser::Utf8YamlTokenizer::*)(int)>(&VYaml::Parser::Utf8YamlTokenizer::IsEmptyNext)> {
  static const MethodInfo* get() {
    static auto* offset = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "IsEmptyNext", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{offset});
  }
};
// Writing MetadataGetter for method: VYaml::Parser::Utf8YamlTokenizer::TryPeek
// Il2CppName: TryPeek
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (VYaml::Parser::Utf8YamlTokenizer::*)(int64_t, ByRef<uint8_t>)>(&VYaml::Parser::Utf8YamlTokenizer::TryPeek)> {
  static const MethodInfo* get() {
    static auto* offset = &::il2cpp_utils::GetClassFromName("System", "Int64")->byval_arg;
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Byte")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(VYaml::Parser::Utf8YamlTokenizer), "TryPeek", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{offset, value});
  }
};
