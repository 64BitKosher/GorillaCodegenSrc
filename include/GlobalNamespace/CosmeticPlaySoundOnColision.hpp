// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: SoundIdRemapping
  class SoundIdRemapping;
  // Forward declaring type: TransferrableObject
  class TransferrableObject;
}
// Forward declaring namespace: UnityEngine::Events
namespace UnityEngine::Events {
  // Forward declaring type: UnityEvent
  class UnityEvent;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: Coroutine
  class Coroutine;
  // Forward declaring type: Collider
  class Collider;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: CosmeticPlaySoundOnColision
  class CosmeticPlaySoundOnColision;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::CosmeticPlaySoundOnColision);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::CosmeticPlaySoundOnColision*, "", "CosmeticPlaySoundOnColision");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x7B
  #pragma pack(push, 1)
  // Autogenerated type: CosmeticPlaySoundOnColision
  // [TokenAttribute] Offset: FFFFFFFF
  class CosmeticPlaySoundOnColision : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::CosmeticPlaySoundOnColision::$waitForStopPlayback$d__17
    class $waitForStopPlayback$d__17;
    public:
    // private System.Int32 defaultSound
    // Size: 0x4
    // Offset: 0x20
    int defaultSound;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: defaultSound and: soundIdRemappings
    char __padding0[0x4] = {};
    // private SoundIdRemapping[] soundIdRemappings
    // Size: 0x8
    // Offset: 0x28
    ::ArrayW<::GlobalNamespace::SoundIdRemapping*> soundIdRemappings;
    // Field size check
    static_assert(sizeof(::ArrayW<::GlobalNamespace::SoundIdRemapping*>) == 0x8);
    // private UnityEngine.Events.UnityEvent OnStartPlayback
    // Size: 0x8
    // Offset: 0x30
    ::UnityEngine::Events::UnityEvent* OnStartPlayback;
    // Field size check
    static_assert(sizeof(::UnityEngine::Events::UnityEvent*) == 0x8);
    // private UnityEngine.Events.UnityEvent OnStopPlayback
    // Size: 0x8
    // Offset: 0x38
    ::UnityEngine::Events::UnityEvent* OnStopPlayback;
    // Field size check
    static_assert(sizeof(::UnityEngine::Events::UnityEvent*) == 0x8);
    // private System.Single minSpeed
    // Size: 0x4
    // Offset: 0x40
    float minSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: minSpeed and: transferrableObject
    char __padding4[0x4] = {};
    // private TransferrableObject transferrableObject
    // Size: 0x8
    // Offset: 0x48
    ::GlobalNamespace::TransferrableObject* transferrableObject;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::TransferrableObject*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<System.Int32,System.Int32> soundLookup
    // Size: 0x8
    // Offset: 0x50
    ::System::Collections::Generic::Dictionary_2<int, int>* soundLookup;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<int, int>*) == 0x8);
    // private UnityEngine.AudioSource audioSource
    // Size: 0x8
    // Offset: 0x58
    ::UnityEngine::AudioSource* audioSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.Coroutine crWaitForStopPlayback
    // Size: 0x8
    // Offset: 0x60
    ::UnityEngine::Coroutine* crWaitForStopPlayback;
    // Field size check
    static_assert(sizeof(::UnityEngine::Coroutine*) == 0x8);
    // private System.Single speed
    // Size: 0x4
    // Offset: 0x68
    float speed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 previousFramePosition
    // Size: 0xC
    // Offset: 0x6C
    ::UnityEngine::Vector3 previousFramePosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Boolean invokeEventsOnAllClients
    // Size: 0x1
    // Offset: 0x78
    bool invokeEventsOnAllClients;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean invokeEventOnOverideSound
    // Size: 0x1
    // Offset: 0x79
    bool invokeEventOnOverideSound;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean invokeEventOnDefaultSound
    // Size: 0x1
    // Offset: 0x7A
    bool invokeEventOnDefaultSound;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Get instance field reference: private System.Int32 defaultSound
    [[deprecated("Use field access instead!")]] int& dyn_defaultSound();
    // Get instance field reference: private SoundIdRemapping[] soundIdRemappings
    [[deprecated("Use field access instead!")]] ::ArrayW<::GlobalNamespace::SoundIdRemapping*>& dyn_soundIdRemappings();
    // Get instance field reference: private UnityEngine.Events.UnityEvent OnStartPlayback
    [[deprecated("Use field access instead!")]] ::UnityEngine::Events::UnityEvent*& dyn_OnStartPlayback();
    // Get instance field reference: private UnityEngine.Events.UnityEvent OnStopPlayback
    [[deprecated("Use field access instead!")]] ::UnityEngine::Events::UnityEvent*& dyn_OnStopPlayback();
    // Get instance field reference: private System.Single minSpeed
    [[deprecated("Use field access instead!")]] float& dyn_minSpeed();
    // Get instance field reference: private TransferrableObject transferrableObject
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::TransferrableObject*& dyn_transferrableObject();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<System.Int32,System.Int32> soundLookup
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<int, int>*& dyn_soundLookup();
    // Get instance field reference: private UnityEngine.AudioSource audioSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_audioSource();
    // Get instance field reference: private UnityEngine.Coroutine crWaitForStopPlayback
    [[deprecated("Use field access instead!")]] ::UnityEngine::Coroutine*& dyn_crWaitForStopPlayback();
    // Get instance field reference: private System.Single speed
    [[deprecated("Use field access instead!")]] float& dyn_speed();
    // Get instance field reference: private UnityEngine.Vector3 previousFramePosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousFramePosition();
    // Get instance field reference: private System.Boolean invokeEventsOnAllClients
    [[deprecated("Use field access instead!")]] bool& dyn_invokeEventsOnAllClients();
    // Get instance field reference: private System.Boolean invokeEventOnOverideSound
    [[deprecated("Use field access instead!")]] bool& dyn_invokeEventOnOverideSound();
    // Get instance field reference: private System.Boolean invokeEventOnDefaultSound
    [[deprecated("Use field access instead!")]] bool& dyn_invokeEventOnDefaultSound();
    // private System.Void Awake()
    // Offset: 0x2686A6C
    void Awake();
    // private System.Void OnTriggerEnter(UnityEngine.Collider other)
    // Offset: 0x2686BC4
    void OnTriggerEnter(::UnityEngine::Collider* other);
    // private System.Void playSound(System.Int32 soundIndex, System.Boolean invokeEvent)
    // Offset: 0x2686C98
    void playSound(int soundIndex, bool invokeEvent);
    // private System.Collections.IEnumerator waitForStopPlayback()
    // Offset: 0x2686EAC
    ::System::Collections::IEnumerator* waitForStopPlayback();
    // private System.Void FixedUpdate()
    // Offset: 0x2686F40
    void FixedUpdate();
    // public System.Void .ctor()
    // Offset: 0x2687034
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static CosmeticPlaySoundOnColision* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::CosmeticPlaySoundOnColision::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<CosmeticPlaySoundOnColision*, creationType>()));
    }
  }; // CosmeticPlaySoundOnColision
  #pragma pack(pop)
  static check_size<sizeof(CosmeticPlaySoundOnColision), 122 + sizeof(bool)> __GlobalNamespace_CosmeticPlaySoundOnColisionSizeCheck;
  static_assert(sizeof(CosmeticPlaySoundOnColision) == 0x7B);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::CosmeticPlaySoundOnColision::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::CosmeticPlaySoundOnColision::*)()>(&GlobalNamespace::CosmeticPlaySoundOnColision::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::CosmeticPlaySoundOnColision*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::CosmeticPlaySoundOnColision::OnTriggerEnter
// Il2CppName: OnTriggerEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::CosmeticPlaySoundOnColision::*)(::UnityEngine::Collider*)>(&GlobalNamespace::CosmeticPlaySoundOnColision::OnTriggerEnter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::CosmeticPlaySoundOnColision*), "OnTriggerEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::CosmeticPlaySoundOnColision::playSound
// Il2CppName: playSound
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::CosmeticPlaySoundOnColision::*)(int, bool)>(&GlobalNamespace::CosmeticPlaySoundOnColision::playSound)> {
  static const MethodInfo* get() {
    static auto* soundIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* invokeEvent = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::CosmeticPlaySoundOnColision*), "playSound", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{soundIndex, invokeEvent});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::CosmeticPlaySoundOnColision::waitForStopPlayback
// Il2CppName: waitForStopPlayback
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::CosmeticPlaySoundOnColision::*)()>(&GlobalNamespace::CosmeticPlaySoundOnColision::waitForStopPlayback)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::CosmeticPlaySoundOnColision*), "waitForStopPlayback", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::CosmeticPlaySoundOnColision::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::CosmeticPlaySoundOnColision::*)()>(&GlobalNamespace::CosmeticPlaySoundOnColision::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::CosmeticPlaySoundOnColision*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::CosmeticPlaySoundOnColision::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
