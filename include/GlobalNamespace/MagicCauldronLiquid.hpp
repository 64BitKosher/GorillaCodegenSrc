// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: ApplyMaterialProperty
  class ApplyMaterialProperty;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: AnimationCurve
  class AnimationCurve;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: MagicCauldronLiquid
  class MagicCauldronLiquid;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::MagicCauldronLiquid);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::MagicCauldronLiquid*, "", "MagicCauldronLiquid");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x84
  #pragma pack(push, 1)
  // Autogenerated type: MagicCauldronLiquid
  // [TokenAttribute] Offset: FFFFFFFF
  class MagicCauldronLiquid : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::MagicCauldronLiquid::WaveParams
    struct WaveParams;
    // Size: 0x10
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: MagicCauldronLiquid/WaveParams
    // [TokenAttribute] Offset: FFFFFFFF
    struct WaveParams/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Single amplitude
      // Size: 0x4
      // Offset: 0x0
      float amplitude;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single frequency
      // Size: 0x4
      // Offset: 0x4
      float frequency;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single scale
      // Size: 0x4
      // Offset: 0x8
      float scale;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single rotation
      // Size: 0x4
      // Offset: 0xC
      float rotation;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      public:
      // Creating value type constructor for type: WaveParams
      constexpr WaveParams(float amplitude_ = {}, float frequency_ = {}, float scale_ = {}, float rotation_ = {}) noexcept : amplitude{amplitude_}, frequency{frequency_}, scale{scale_}, rotation{rotation_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Single amplitude
      [[deprecated("Use field access instead!")]] float& dyn_amplitude();
      // Get instance field reference: public System.Single frequency
      [[deprecated("Use field access instead!")]] float& dyn_frequency();
      // Get instance field reference: public System.Single scale
      [[deprecated("Use field access instead!")]] float& dyn_scale();
      // Get instance field reference: public System.Single rotation
      [[deprecated("Use field access instead!")]] float& dyn_rotation();
    }; // MagicCauldronLiquid/WaveParams
    #pragma pack(pop)
    static check_size<sizeof(MagicCauldronLiquid::WaveParams), 12 + sizeof(float)> __GlobalNamespace_MagicCauldronLiquid_WaveParamsSizeCheck;
    static_assert(sizeof(MagicCauldronLiquid::WaveParams) == 0x10);
    public:
    // private ApplyMaterialProperty _applyMaterial
    // Size: 0x8
    // Offset: 0x20
    ::GlobalNamespace::ApplyMaterialProperty* applyMaterial;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::ApplyMaterialProperty*) == 0x8);
    // private UnityEngine.Color _colorStart
    // Size: 0x10
    // Offset: 0x28
    ::UnityEngine::Color colorStart;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private UnityEngine.Color _colorEnd
    // Size: 0x10
    // Offset: 0x38
    ::UnityEngine::Color colorEnd;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private System.Boolean _animating
    // Size: 0x1
    // Offset: 0x48
    bool animating;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: animating and: animProgress
    char __padding3[0x3] = {};
    // private System.Single _animProgress
    // Size: 0x4
    // Offset: 0x4C
    float animProgress;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.AnimationCurve _animationCurve
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::AnimationCurve* animationCurve;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // private UnityEngine.AnimationCurve _waveCurve
    // Size: 0x8
    // Offset: 0x58
    ::UnityEngine::AnimationCurve* waveCurve;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // public System.Single animLength
    // Size: 0x4
    // Offset: 0x60
    float animLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public MagicCauldronLiquid/WaveParams waveNormal
    // Size: 0x10
    // Offset: 0x64
    ::GlobalNamespace::MagicCauldronLiquid::WaveParams waveNormal;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::MagicCauldronLiquid::WaveParams) == 0x10);
    // public MagicCauldronLiquid/WaveParams waveAnimating
    // Size: 0x10
    // Offset: 0x74
    ::GlobalNamespace::MagicCauldronLiquid::WaveParams waveAnimating;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::MagicCauldronLiquid::WaveParams) == 0x10);
    public:
    // Get instance field reference: private ApplyMaterialProperty _applyMaterial
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::ApplyMaterialProperty*& dyn__applyMaterial();
    // Get instance field reference: private UnityEngine.Color _colorStart
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn__colorStart();
    // Get instance field reference: private UnityEngine.Color _colorEnd
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn__colorEnd();
    // Get instance field reference: private System.Boolean _animating
    [[deprecated("Use field access instead!")]] bool& dyn__animating();
    // Get instance field reference: private System.Single _animProgress
    [[deprecated("Use field access instead!")]] float& dyn__animProgress();
    // Get instance field reference: private UnityEngine.AnimationCurve _animationCurve
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn__animationCurve();
    // Get instance field reference: private UnityEngine.AnimationCurve _waveCurve
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn__waveCurve();
    // Get instance field reference: public System.Single animLength
    [[deprecated("Use field access instead!")]] float& dyn_animLength();
    // Get instance field reference: public MagicCauldronLiquid/WaveParams waveNormal
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::MagicCauldronLiquid::WaveParams& dyn_waveNormal();
    // Get instance field reference: public MagicCauldronLiquid/WaveParams waveAnimating
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::MagicCauldronLiquid::WaveParams& dyn_waveAnimating();
    // private System.Void Test()
    // Offset: 0x2728A08
    void Test();
    // public System.Void AnimateColorFromTo(UnityEngine.Color a, UnityEngine.Color b, System.Single length)
    // Offset: 0x2727F48
    void AnimateColorFromTo(::UnityEngine::Color a, ::UnityEngine::Color b, float length);
    // private System.Void ApplyColor(UnityEngine.Color color)
    // Offset: 0x2728A20
    void ApplyColor(::UnityEngine::Color color);
    // private System.Void ApplyWaveParams(System.Single amplitude, System.Single frequency, System.Single scale, System.Single rotation)
    // Offset: 0x2728B00
    void ApplyWaveParams(float amplitude, float frequency, float scale, float rotation);
    // private System.Void OnEnable()
    // Offset: 0x2728C28
    void OnEnable();
    // private System.Void OnDisable()
    // Offset: 0x2728CA0
    void OnDisable();
    // private System.Void Update()
    // Offset: 0x2728CAC
    void Update();
    // public System.Void .ctor()
    // Offset: 0x2728D90
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static MagicCauldronLiquid* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::MagicCauldronLiquid::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<MagicCauldronLiquid*, creationType>()));
    }
  }; // MagicCauldronLiquid
  #pragma pack(pop)
  static check_size<sizeof(MagicCauldronLiquid), 116 + sizeof(::GlobalNamespace::MagicCauldronLiquid::WaveParams)> __GlobalNamespace_MagicCauldronLiquidSizeCheck;
  static_assert(sizeof(MagicCauldronLiquid) == 0x84);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::MagicCauldronLiquid::WaveParams, "", "MagicCauldronLiquid/WaveParams");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::Test
// Il2CppName: Test
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MagicCauldronLiquid::*)()>(&GlobalNamespace::MagicCauldronLiquid::Test)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MagicCauldronLiquid*), "Test", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::AnimateColorFromTo
// Il2CppName: AnimateColorFromTo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MagicCauldronLiquid::*)(::UnityEngine::Color, ::UnityEngine::Color, float)>(&GlobalNamespace::MagicCauldronLiquid::AnimateColorFromTo)> {
  static const MethodInfo* get() {
    static auto* a = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    static auto* b = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    static auto* length = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MagicCauldronLiquid*), "AnimateColorFromTo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, b, length});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::ApplyColor
// Il2CppName: ApplyColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MagicCauldronLiquid::*)(::UnityEngine::Color)>(&GlobalNamespace::MagicCauldronLiquid::ApplyColor)> {
  static const MethodInfo* get() {
    static auto* color = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MagicCauldronLiquid*), "ApplyColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{color});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::ApplyWaveParams
// Il2CppName: ApplyWaveParams
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MagicCauldronLiquid::*)(float, float, float, float)>(&GlobalNamespace::MagicCauldronLiquid::ApplyWaveParams)> {
  static const MethodInfo* get() {
    static auto* amplitude = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* frequency = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* scale = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* rotation = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MagicCauldronLiquid*), "ApplyWaveParams", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{amplitude, frequency, scale, rotation});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MagicCauldronLiquid::*)()>(&GlobalNamespace::MagicCauldronLiquid::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MagicCauldronLiquid*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MagicCauldronLiquid::*)()>(&GlobalNamespace::MagicCauldronLiquid::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MagicCauldronLiquid*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MagicCauldronLiquid::*)()>(&GlobalNamespace::MagicCauldronLiquid::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MagicCauldronLiquid*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MagicCauldronLiquid::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
