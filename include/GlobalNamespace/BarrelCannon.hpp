// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Photon.Pun.MonoBehaviourPun
#include "Photon/Pun/MonoBehaviourPun.hpp"
// Including type: Photon.Pun.IPunObservable
#include "Photon/Pun/IPunObservable.hpp"
// Including type: Photon.Pun.IPunOwnershipCallbacks
#include "Photon/Pun/IPunOwnershipCallbacks.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: AnimationCurve
  class AnimationCurve;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: CapsuleCollider
  class CapsuleCollider;
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: Rigidbody
  class Rigidbody;
}
// Forward declaring namespace: Photon::Pun
namespace Photon::Pun {
  // Forward declaring type: PhotonStream
  class PhotonStream;
  // Forward declaring type: PhotonMessageInfo
  struct PhotonMessageInfo;
  // Forward declaring type: PhotonView
  class PhotonView;
}
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: BarrelCannon
  class BarrelCannon;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::BarrelCannon);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::BarrelCannon*, "", "BarrelCannon");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0xB0
  #pragma pack(push, 1)
  // Autogenerated type: BarrelCannon
  // [TokenAttribute] Offset: FFFFFFFF
  class BarrelCannon : public ::Photon::Pun::MonoBehaviourPun/*, public ::Photon::Pun::IPunObservable, public ::Photon::Pun::IPunOwnershipCallbacks*/ {
    public:
    // Nested type: ::GlobalNamespace::BarrelCannon::BarrelCannonState
    struct BarrelCannonState;
    // Nested type: ::GlobalNamespace::BarrelCannon::BarrelCannonSyncedState
    class BarrelCannonSyncedState;
    public:
    // private System.Single firingSpeed
    // Size: 0x4
    // Offset: 0x28
    float firingSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 firingPositionOffset
    // Size: 0xC
    // Offset: 0x2C
    ::UnityEngine::Vector3 firingPositionOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 firingRotationOffset
    // Size: 0xC
    // Offset: 0x38
    ::UnityEngine::Vector3 firingRotationOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: firingRotationOffset and: firePositionAnimationCurve
    char __padding2[0x4] = {};
    // private UnityEngine.AnimationCurve firePositionAnimationCurve
    // Size: 0x8
    // Offset: 0x48
    ::UnityEngine::AnimationCurve* firePositionAnimationCurve;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // private UnityEngine.AnimationCurve fireRotationAnimationCurve
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::AnimationCurve* fireRotationAnimationCurve;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // private System.Single moveToFiringPositionTime
    // Size: 0x4
    // Offset: 0x58
    float moveToFiringPositionTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single cannonEntryDelayTime
    // Size: 0x4
    // Offset: 0x5C
    float cannonEntryDelayTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single preFiringDelayTime
    // Size: 0x4
    // Offset: 0x60
    float preFiringDelayTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single postFiringCooldownTime
    // Size: 0x4
    // Offset: 0x64
    float postFiringCooldownTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single returnToIdlePositionTime
    // Size: 0x4
    // Offset: 0x68
    float returnToIdlePositionTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: returnToIdlePositionTime and: audioSource
    char __padding9[0x4] = {};
    // private UnityEngine.AudioSource audioSource
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::AudioSource* audioSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.CapsuleCollider triggerCollider
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::CapsuleCollider* triggerCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::CapsuleCollider*) == 0x8);
    // private UnityEngine.Collider[] colliders
    // Size: 0x8
    // Offset: 0x80
    ::ArrayW<::UnityEngine::Collider*> colliders;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Collider*>) == 0x8);
    // private BarrelCannon/BarrelCannonSyncedState syncedState
    // Size: 0x8
    // Offset: 0x88
    ::GlobalNamespace::BarrelCannon::BarrelCannonSyncedState* syncedState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::BarrelCannon::BarrelCannonSyncedState*) == 0x8);
    // private UnityEngine.Collider[] triggerOverlapResults
    // Size: 0x8
    // Offset: 0x90
    ::ArrayW<::UnityEngine::Collider*> triggerOverlapResults;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Collider*>) == 0x8);
    // private System.Boolean localPlayerInside
    // Size: 0x1
    // Offset: 0x98
    bool localPlayerInside;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: localPlayerInside and: localPlayerRigidbody
    char __padding15[0x7] = {};
    // private UnityEngine.Rigidbody localPlayerRigidbody
    // Size: 0x8
    // Offset: 0xA0
    ::UnityEngine::Rigidbody* localPlayerRigidbody;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // private System.Single stateStartTime
    // Size: 0x4
    // Offset: 0xA8
    float stateStartTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single localFiringPositionLerpValue
    // Size: 0x4
    // Offset: 0xAC
    float localFiringPositionLerpValue;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    public:
    // Creating interface conversion operator: operator ::Photon::Pun::IPunObservable
    operator ::Photon::Pun::IPunObservable() noexcept {
      return *reinterpret_cast<::Photon::Pun::IPunObservable*>(this);
    }
    // Creating interface conversion operator: operator ::Photon::Pun::IPunOwnershipCallbacks
    operator ::Photon::Pun::IPunOwnershipCallbacks() noexcept {
      return *reinterpret_cast<::Photon::Pun::IPunOwnershipCallbacks*>(this);
    }
    // Get instance field reference: private System.Single firingSpeed
    [[deprecated("Use field access instead!")]] float& dyn_firingSpeed();
    // Get instance field reference: private UnityEngine.Vector3 firingPositionOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_firingPositionOffset();
    // Get instance field reference: private UnityEngine.Vector3 firingRotationOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_firingRotationOffset();
    // Get instance field reference: private UnityEngine.AnimationCurve firePositionAnimationCurve
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn_firePositionAnimationCurve();
    // Get instance field reference: private UnityEngine.AnimationCurve fireRotationAnimationCurve
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn_fireRotationAnimationCurve();
    // Get instance field reference: private System.Single moveToFiringPositionTime
    [[deprecated("Use field access instead!")]] float& dyn_moveToFiringPositionTime();
    // Get instance field reference: private System.Single cannonEntryDelayTime
    [[deprecated("Use field access instead!")]] float& dyn_cannonEntryDelayTime();
    // Get instance field reference: private System.Single preFiringDelayTime
    [[deprecated("Use field access instead!")]] float& dyn_preFiringDelayTime();
    // Get instance field reference: private System.Single postFiringCooldownTime
    [[deprecated("Use field access instead!")]] float& dyn_postFiringCooldownTime();
    // Get instance field reference: private System.Single returnToIdlePositionTime
    [[deprecated("Use field access instead!")]] float& dyn_returnToIdlePositionTime();
    // Get instance field reference: private UnityEngine.AudioSource audioSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_audioSource();
    // Get instance field reference: private UnityEngine.CapsuleCollider triggerCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::CapsuleCollider*& dyn_triggerCollider();
    // Get instance field reference: private UnityEngine.Collider[] colliders
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Collider*>& dyn_colliders();
    // Get instance field reference: private BarrelCannon/BarrelCannonSyncedState syncedState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::BarrelCannon::BarrelCannonSyncedState*& dyn_syncedState();
    // Get instance field reference: private UnityEngine.Collider[] triggerOverlapResults
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Collider*>& dyn_triggerOverlapResults();
    // Get instance field reference: private System.Boolean localPlayerInside
    [[deprecated("Use field access instead!")]] bool& dyn_localPlayerInside();
    // Get instance field reference: private UnityEngine.Rigidbody localPlayerRigidbody
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_localPlayerRigidbody();
    // Get instance field reference: private System.Single stateStartTime
    [[deprecated("Use field access instead!")]] float& dyn_stateStartTime();
    // Get instance field reference: private System.Single localFiringPositionLerpValue
    [[deprecated("Use field access instead!")]] float& dyn_localFiringPositionLerpValue();
    // private System.Void Update()
    // Offset: 0x268DFF0
    void Update();
    // private System.Void AuthorityUpdate()
    // Offset: 0x268E030
    void AuthorityUpdate();
    // private System.Void ClientUpdate()
    // Offset: 0x268E61C
    void ClientUpdate();
    // private System.Void SharedUpdate()
    // Offset: 0x268E664
    void SharedUpdate();
    // private System.Void FireBarrelCannonRPC(UnityEngine.Vector3 cannonCenter, UnityEngine.Vector3 firingDirection)
    // Offset: 0x268E9C4
    void FireBarrelCannonRPC(::UnityEngine::Vector3 cannonCenter, ::UnityEngine::Vector3 firingDirection);
    // private System.Void FireBarrelCannonLocal(UnityEngine.Vector3 cannonCenter, UnityEngine.Vector3 firingDirection)
    // Offset: 0x268E828
    void FireBarrelCannonLocal(::UnityEngine::Vector3 cannonCenter, ::UnityEngine::Vector3 firingDirection);
    // private System.Void OnTriggerEnter(UnityEngine.Collider other)
    // Offset: 0x268E9C8
    void OnTriggerEnter(::UnityEngine::Collider* other);
    // private System.Void OnTriggerExit(UnityEngine.Collider other)
    // Offset: 0x268EB70
    void OnTriggerExit(::UnityEngine::Collider* other);
    // private System.Boolean LocalPlayerTriggerFilter(UnityEngine.Collider other, out UnityEngine.Rigidbody rb)
    // Offset: 0x268EA08
    bool LocalPlayerTriggerFilter(::UnityEngine::Collider* other, ByRef<::UnityEngine::Rigidbody*> rb);
    // private System.Boolean IsLocalPlayerInCannon()
    // Offset: 0x268EBAC
    bool IsLocalPlayerInCannon();
    // private System.Void GetCapsulePoints(UnityEngine.CapsuleCollider capsule, out UnityEngine.Vector3 pointA, out UnityEngine.Vector3 pointB)
    // Offset: 0x268ECEC
    void GetCapsulePoints(::UnityEngine::CapsuleCollider* capsule, ByRef<::UnityEngine::Vector3> pointA, ByRef<::UnityEngine::Vector3> pointB);
    // public System.Void OnPhotonSerializeView(Photon.Pun.PhotonStream stream, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0x268EE10
    void OnPhotonSerializeView(::Photon::Pun::PhotonStream* stream, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void OnOwnershipRequest(Photon.Pun.PhotonView targetView, Photon.Realtime.Player requestingPlayer)
    // Offset: 0x268EF5C
    void OnOwnershipRequest(::Photon::Pun::PhotonView* targetView, ::Photon::Realtime::Player* requestingPlayer);
    // public System.Void OnOwnershipTransfered(Photon.Pun.PhotonView targetView, Photon.Realtime.Player previousOwner)
    // Offset: 0x268EF8C
    void OnOwnershipTransfered(::Photon::Pun::PhotonView* targetView, ::Photon::Realtime::Player* previousOwner);
    // public System.Void OnOwnershipTransferFailed(Photon.Pun.PhotonView targetView, Photon.Realtime.Player senderOfFailedRequest)
    // Offset: 0x268EF90
    void OnOwnershipTransferFailed(::Photon::Pun::PhotonView* targetView, ::Photon::Realtime::Player* senderOfFailedRequest);
    // public System.Void .ctor()
    // Offset: 0x268EF94
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static BarrelCannon* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::BarrelCannon::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<BarrelCannon*, creationType>()));
    }
  }; // BarrelCannon
  #pragma pack(pop)
  static check_size<sizeof(BarrelCannon), 172 + sizeof(float)> __GlobalNamespace_BarrelCannonSizeCheck;
  static_assert(sizeof(BarrelCannon) == 0xB0);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)()>(&GlobalNamespace::BarrelCannon::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::AuthorityUpdate
// Il2CppName: AuthorityUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)()>(&GlobalNamespace::BarrelCannon::AuthorityUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "AuthorityUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::ClientUpdate
// Il2CppName: ClientUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)()>(&GlobalNamespace::BarrelCannon::ClientUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "ClientUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::SharedUpdate
// Il2CppName: SharedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)()>(&GlobalNamespace::BarrelCannon::SharedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "SharedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::FireBarrelCannonRPC
// Il2CppName: FireBarrelCannonRPC
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&GlobalNamespace::BarrelCannon::FireBarrelCannonRPC)> {
  static const MethodInfo* get() {
    static auto* cannonCenter = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* firingDirection = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "FireBarrelCannonRPC", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cannonCenter, firingDirection});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::FireBarrelCannonLocal
// Il2CppName: FireBarrelCannonLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&GlobalNamespace::BarrelCannon::FireBarrelCannonLocal)> {
  static const MethodInfo* get() {
    static auto* cannonCenter = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* firingDirection = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "FireBarrelCannonLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cannonCenter, firingDirection});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::OnTriggerEnter
// Il2CppName: OnTriggerEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::UnityEngine::Collider*)>(&GlobalNamespace::BarrelCannon::OnTriggerEnter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "OnTriggerEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::OnTriggerExit
// Il2CppName: OnTriggerExit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::UnityEngine::Collider*)>(&GlobalNamespace::BarrelCannon::OnTriggerExit)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "OnTriggerExit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::LocalPlayerTriggerFilter
// Il2CppName: LocalPlayerTriggerFilter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::BarrelCannon::*)(::UnityEngine::Collider*, ByRef<::UnityEngine::Rigidbody*>)>(&GlobalNamespace::BarrelCannon::LocalPlayerTriggerFilter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    static auto* rb = &::il2cpp_utils::GetClassFromName("UnityEngine", "Rigidbody")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "LocalPlayerTriggerFilter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other, rb});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::IsLocalPlayerInCannon
// Il2CppName: IsLocalPlayerInCannon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::BarrelCannon::*)()>(&GlobalNamespace::BarrelCannon::IsLocalPlayerInCannon)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "IsLocalPlayerInCannon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::GetCapsulePoints
// Il2CppName: GetCapsulePoints
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::UnityEngine::CapsuleCollider*, ByRef<::UnityEngine::Vector3>, ByRef<::UnityEngine::Vector3>)>(&GlobalNamespace::BarrelCannon::GetCapsulePoints)> {
  static const MethodInfo* get() {
    static auto* capsule = &::il2cpp_utils::GetClassFromName("UnityEngine", "CapsuleCollider")->byval_arg;
    static auto* pointA = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* pointB = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "GetCapsulePoints", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{capsule, pointA, pointB});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::OnPhotonSerializeView
// Il2CppName: OnPhotonSerializeView
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::Photon::Pun::PhotonStream*, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::BarrelCannon::OnPhotonSerializeView)> {
  static const MethodInfo* get() {
    static auto* stream = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonStream")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "OnPhotonSerializeView", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{stream, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::OnOwnershipRequest
// Il2CppName: OnOwnershipRequest
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::Photon::Pun::PhotonView*, ::Photon::Realtime::Player*)>(&GlobalNamespace::BarrelCannon::OnOwnershipRequest)> {
  static const MethodInfo* get() {
    static auto* targetView = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonView")->byval_arg;
    static auto* requestingPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "OnOwnershipRequest", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{targetView, requestingPlayer});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::OnOwnershipTransfered
// Il2CppName: OnOwnershipTransfered
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::Photon::Pun::PhotonView*, ::Photon::Realtime::Player*)>(&GlobalNamespace::BarrelCannon::OnOwnershipTransfered)> {
  static const MethodInfo* get() {
    static auto* targetView = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonView")->byval_arg;
    static auto* previousOwner = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "OnOwnershipTransfered", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{targetView, previousOwner});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::OnOwnershipTransferFailed
// Il2CppName: OnOwnershipTransferFailed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BarrelCannon::*)(::Photon::Pun::PhotonView*, ::Photon::Realtime::Player*)>(&GlobalNamespace::BarrelCannon::OnOwnershipTransferFailed)> {
  static const MethodInfo* get() {
    static auto* targetView = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonView")->byval_arg;
    static auto* senderOfFailedRequest = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BarrelCannon*), "OnOwnershipTransferFailed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{targetView, senderOfFailedRequest});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BarrelCannon::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
