// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Fusion.SimulationBehaviour
#include "Fusion/SimulationBehaviour.hpp"
// Including type: Fusion.IPlayerJoined
#include "Fusion/IPlayerJoined.hpp"
// Including type: Fusion.IPlayerLeft
#include "Fusion/IPlayerLeft.hpp"
// Including type: Fusion.ISpawned
#include "Fusion/ISpawned.hpp"
// Including type: Fusion.ISceneLoadDone
#include "Fusion/ISceneLoadDone.hpp"
// Including type: Fusion.PlayerRef
#include "Fusion/PlayerRef.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Skipping declaration: SpawnMethods because it is already included!
  // Skipping declaration: AuthorityOptions because it is already included!
  // Forward declaring type: ISpawnPointPrototype
  class ISpawnPointPrototype;
  // Forward declaring type: ISpawnPointManagerPrototype`1<T>
  template<typename T>
  class ISpawnPointManagerPrototype_1;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Skipping declaration: Component because it is already included!
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: Fusion
namespace Fusion {
  // Forward declaring type: NetworkObject
  class NetworkObject;
  // Forward declaring type: NetworkRunner
  class NetworkRunner;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: SpawnerPrototype`1<T>
  template<typename T>
  class SpawnerPrototype_1;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(::GlobalNamespace::SpawnerPrototype_1, "", "SpawnerPrototype`1");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: SpawnerPrototype`1
  // [TokenAttribute] Offset: FFFFFFFF
  // [ScriptHelpAttribute] Offset: FFFFFFFF
  template<typename T>
  class SpawnerPrototype_1 : public ::Fusion::SimulationBehaviour/*, public ::Fusion::IPlayerJoined, public ::Fusion::IPlayerLeft, public ::Fusion::ISpawned, public ::Fusion::ISceneLoadDone*/ {
    public:
    // Nested type: ::GlobalNamespace::SpawnerPrototype_1::SpawnMethods<T>
    struct SpawnMethods;
    // Nested type: ::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions<T>
    struct AuthorityOptions;
    // WARNING Size may be invalid!
    // Autogenerated type: SpawnerPrototype`1/SpawnMethods
    // [TokenAttribute] Offset: FFFFFFFF
    struct SpawnMethods : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::Enum*/ {
      public:
      using declaring_type = SpawnerPrototype_1<T>*;
      static constexpr std::string_view NESTED_NAME = "SpawnMethods";
      static constexpr bool IS_VALUE_TYPE = true;
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: SpawnMethods
      constexpr SpawnMethods(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // Autogenerated static field getter
      // Get static field: static public SpawnerPrototype`1/SpawnMethods<T> AutoOnNetworkStart
      static typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods _get_AutoOnNetworkStart() {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::SpawnMethods::_get_AutoOnNetworkStart");
        return THROW_UNLESS(il2cpp_utils::GetFieldValue<typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::SpawnMethods>::get(), "AutoOnNetworkStart"));
      }
      // Autogenerated static field setter
      // Set static field: static public SpawnerPrototype`1/SpawnMethods<T> AutoOnNetworkStart
      static void _set_AutoOnNetworkStart(typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods value) {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::SpawnMethods::_set_AutoOnNetworkStart");
        THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::SpawnMethods>::get(), "AutoOnNetworkStart", value));
      }
      // Autogenerated static field getter
      // Get static field: static public SpawnerPrototype`1/SpawnMethods<T> ByScriptOnly
      static typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods _get_ByScriptOnly() {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::SpawnMethods::_get_ByScriptOnly");
        return THROW_UNLESS(il2cpp_utils::GetFieldValue<typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::SpawnMethods>::get(), "ByScriptOnly"));
      }
      // Autogenerated static field setter
      // Set static field: static public SpawnerPrototype`1/SpawnMethods<T> ByScriptOnly
      static void _set_ByScriptOnly(typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods value) {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::SpawnMethods::_set_ByScriptOnly");
        THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::SpawnMethods>::get(), "ByScriptOnly", value));
      }
      // Autogenerated instance field getter
      // Get instance field: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__() {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::SpawnMethods::dyn_value__");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "value__"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
    }; // SpawnerPrototype`1/SpawnMethods
    // Could not write size check! Type: SpawnerPrototype`1/SpawnMethods is generic, or has no fields that are valid for size checks!
    // WARNING Size may be invalid!
    // Autogenerated type: SpawnerPrototype`1/AuthorityOptions
    // [TokenAttribute] Offset: FFFFFFFF
    struct AuthorityOptions : public ::il2cpp_utils::il2cpp_type_check::NestedType/*, public ::System::Enum*/ {
      public:
      using declaring_type = SpawnerPrototype_1<T>*;
      static constexpr std::string_view NESTED_NAME = "AuthorityOptions";
      static constexpr bool IS_VALUE_TYPE = true;
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: AuthorityOptions
      constexpr AuthorityOptions(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // Autogenerated static field getter
      // Get static field: static public SpawnerPrototype`1/AuthorityOptions<T> Auto
      static typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions _get_Auto() {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions::_get_Auto");
        return THROW_UNLESS(il2cpp_utils::GetFieldValue<typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::AuthorityOptions>::get(), "Auto"));
      }
      // Autogenerated static field setter
      // Set static field: static public SpawnerPrototype`1/AuthorityOptions<T> Auto
      static void _set_Auto(typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions value) {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions::_set_Auto");
        THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::AuthorityOptions>::get(), "Auto", value));
      }
      // Autogenerated static field getter
      // Get static field: static public SpawnerPrototype`1/AuthorityOptions<T> Server
      static typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions _get_Server() {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions::_get_Server");
        return THROW_UNLESS(il2cpp_utils::GetFieldValue<typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::AuthorityOptions>::get(), "Server"));
      }
      // Autogenerated static field setter
      // Set static field: static public SpawnerPrototype`1/AuthorityOptions<T> Server
      static void _set_Server(typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions value) {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions::_set_Server");
        THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::AuthorityOptions>::get(), "Server", value));
      }
      // Autogenerated static field getter
      // Get static field: static public SpawnerPrototype`1/AuthorityOptions<T> Player
      static typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions _get_Player() {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions::_get_Player");
        return THROW_UNLESS(il2cpp_utils::GetFieldValue<typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::AuthorityOptions>::get(), "Player"));
      }
      // Autogenerated static field setter
      // Set static field: static public SpawnerPrototype`1/AuthorityOptions<T> Player
      static void _set_Player(typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions value) {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions::_set_Player");
        THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<typename SpawnerPrototype_1<T>::AuthorityOptions>::get(), "Player", value));
      }
      // Autogenerated instance field getter
      // Get instance field: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__() {
        static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::AuthorityOptions::dyn_value__");
        auto ___internal__instance = *this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "value__"))->offset;
        return *reinterpret_cast<int*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
    }; // SpawnerPrototype`1/AuthorityOptions
    // Could not write size check! Type: SpawnerPrototype`1/AuthorityOptions is generic, or has no fields that are valid for size checks!
    public:
    // protected System.Collections.Generic.Dictionary`2<Fusion.PlayerRef,System.Collections.Generic.List`1<Fusion.NetworkObject>> _spawnedLookup
    // Size: 0x8
    // Offset: 0x0
    ::System::Collections::Generic::Dictionary_2<::Fusion::PlayerRef, ::System::Collections::Generic::List_1<::Fusion::NetworkObject*>*>* spawnedLookup;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::Fusion::PlayerRef, ::System::Collections::Generic::List_1<::Fusion::NetworkObject*>*>*) == 0x8);
    // public Fusion.NetworkObject PlayerPrefab
    // Size: 0x8
    // Offset: 0x0
    ::Fusion::NetworkObject* PlayerPrefab;
    // Field size check
    static_assert(sizeof(::Fusion::NetworkObject*) == 0x8);
    // public SpawnerPrototype`1/SpawnMethods<T> SpawnMethod
    // Size: 0xFFFFFFFF
    // Offset: 0x0
    typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods SpawnMethod;
    // public SpawnerPrototype`1/AuthorityOptions<T> StateAuthority
    // Size: 0xFFFFFFFF
    // Offset: 0x0
    typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions StateAuthority;
    // protected ISpawnPointManagerPrototype`1<T> spawnManager
    // Size: 0x8
    // Offset: 0x0
    ::GlobalNamespace::ISpawnPointManagerPrototype_1<T>* spawnManager;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::ISpawnPointManagerPrototype_1<T>*) == 0x8);
    public:
    // Creating interface conversion operator: operator ::Fusion::IPlayerJoined
    operator ::Fusion::IPlayerJoined() noexcept {
      return *reinterpret_cast<::Fusion::IPlayerJoined*>(this);
    }
    // Creating interface conversion operator: operator ::Fusion::IPlayerLeft
    operator ::Fusion::IPlayerLeft() noexcept {
      return *reinterpret_cast<::Fusion::IPlayerLeft*>(this);
    }
    // Creating interface conversion operator: operator ::Fusion::ISpawned
    operator ::Fusion::ISpawned() noexcept {
      return *reinterpret_cast<::Fusion::ISpawned*>(this);
    }
    // Creating interface conversion operator: operator ::Fusion::ISceneLoadDone
    operator ::Fusion::ISceneLoadDone() noexcept {
      return *reinterpret_cast<::Fusion::ISceneLoadDone*>(this);
    }
    // Autogenerated instance field getter
    // Get instance field: protected System.Collections.Generic.Dictionary`2<Fusion.PlayerRef,System.Collections.Generic.List`1<Fusion.NetworkObject>> _spawnedLookup
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::Fusion::PlayerRef, ::System::Collections::Generic::List_1<::Fusion::NetworkObject*>*>*& dyn__spawnedLookup() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::dyn__spawnedLookup");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_spawnedLookup"))->offset;
      return *reinterpret_cast<::System::Collections::Generic::Dictionary_2<::Fusion::PlayerRef, ::System::Collections::Generic::List_1<::Fusion::NetworkObject*>*>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: public Fusion.NetworkObject PlayerPrefab
    [[deprecated("Use field access instead!")]] ::Fusion::NetworkObject*& dyn_PlayerPrefab() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::dyn_PlayerPrefab");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "PlayerPrefab"))->offset;
      return *reinterpret_cast<::Fusion::NetworkObject**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: public SpawnerPrototype`1/SpawnMethods<T> SpawnMethod
    [[deprecated("Use field access instead!")]] typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods& dyn_SpawnMethod() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::dyn_SpawnMethod");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "SpawnMethod"))->offset;
      return *reinterpret_cast<typename ::GlobalNamespace::SpawnerPrototype_1<T>::SpawnMethods*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: public SpawnerPrototype`1/AuthorityOptions<T> StateAuthority
    [[deprecated("Use field access instead!")]] typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions& dyn_StateAuthority() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::dyn_StateAuthority");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "StateAuthority"))->offset;
      return *reinterpret_cast<typename ::GlobalNamespace::SpawnerPrototype_1<T>::AuthorityOptions*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: protected ISpawnPointManagerPrototype`1<T> spawnManager
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::ISpawnPointManagerPrototype_1<T>*& dyn_spawnManager() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::dyn_spawnManager");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "spawnManager"))->offset;
      return *reinterpret_cast<::GlobalNamespace::ISpawnPointManagerPrototype_1<T>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // protected System.Boolean get__AllowClientObjects()
    // Offset: 0xFFFFFFFFFFFFFFFF
    bool get__AllowClientObjects() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::get__AllowClientObjects");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "get__AllowClientObjects", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method);
    }
    // protected System.Void Awake()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Awake() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::Awake");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::GlobalNamespace::SpawnerPrototype_1<T>*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // public System.Void Spawned()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Spawned() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::Spawned");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::GlobalNamespace::SpawnerPrototype_1<T>*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // public System.Void SceneLoadDone()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void SceneLoadDone() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::SceneLoadDone");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::GlobalNamespace::SpawnerPrototype_1<T>*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // public System.Void PlayerJoined(Fusion.PlayerRef player)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void PlayerJoined(::Fusion::PlayerRef player) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::PlayerJoined");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::GlobalNamespace::SpawnerPrototype_1<T>*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, player);
    }
    // public System.Void PlayerLeft(Fusion.PlayerRef player)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void PlayerLeft(::Fusion::PlayerRef player) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::PlayerLeft");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::GlobalNamespace::SpawnerPrototype_1<T>*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, player);
    }
    // private System.Void PlayerJoined(Fusion.NetworkRunner runner, Fusion.PlayerRef player)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void PlayerJoined(::Fusion::NetworkRunner* runner, ::Fusion::PlayerRef player) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::PlayerJoined");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "PlayerJoined", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(runner), ::il2cpp_utils::ExtractType(player)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, runner, player);
    }
    // private System.Void PlayerLeft(Fusion.NetworkRunner runner, Fusion.PlayerRef player)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void PlayerLeft(::Fusion::NetworkRunner* runner, ::Fusion::PlayerRef player) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::PlayerLeft");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "PlayerLeft", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(runner), ::il2cpp_utils::ExtractType(player)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, runner, player);
    }
    // public Fusion.NetworkObject TrySpawn(Fusion.NetworkRunner runner, Fusion.PlayerRef player)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::Fusion::NetworkObject* TrySpawn(::Fusion::NetworkRunner* runner, ::Fusion::PlayerRef player) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::TrySpawn");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "TrySpawn", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(runner), ::il2cpp_utils::ExtractType(player)})));
      return ::il2cpp_utils::RunMethodRethrow<::Fusion::NetworkObject*, false>(this, ___internal__method, runner, player);
    }
    // public System.Void TrySpawnAll()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void TrySpawnAll() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::TrySpawnAll");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "TrySpawnAll", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method);
    }
    // protected System.Void RegisterPlayerAndObject(Fusion.PlayerRef player, Fusion.NetworkObject playerObject)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void RegisterPlayerAndObject(::Fusion::PlayerRef player, ::Fusion::NetworkObject* playerObject) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::RegisterPlayerAndObject");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::GlobalNamespace::SpawnerPrototype_1<T>*), -1));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, player, playerObject);
    }
    // protected System.Void DespawnPlayersObjects(Fusion.NetworkRunner runner, Fusion.PlayerRef player)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void DespawnPlayersObjects(::Fusion::NetworkRunner* runner, ::Fusion::PlayerRef player) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::DespawnPlayersObjects");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "DespawnPlayersObjects", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(runner), ::il2cpp_utils::ExtractType(player)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, runner, player);
    }
    // protected System.Void UnregisterPlayer(Fusion.PlayerRef player)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void UnregisterPlayer(::Fusion::PlayerRef player) {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::UnregisterPlayer");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "UnregisterPlayer", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(player)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, player);
    }
    // public System.Void .ctor()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static SpawnerPrototype_1<T>* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::SpawnerPrototype_1::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<SpawnerPrototype_1<T>*, creationType>()));
    }
  }; // SpawnerPrototype`1
  // Could not write size check! Type: SpawnerPrototype`1 is generic, or has no fields that are valid for size checks!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
