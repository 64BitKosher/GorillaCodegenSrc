// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: TransferrableObject
#include "GlobalNamespace/TransferrableObject.hpp"
// Including type: RoomSystem
#include "GlobalNamespace/RoomSystem.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: InteractionPoint
  class InteractionPoint;
  // Forward declaring type: SlingshotProjectile
  class SlingshotProjectile;
  // Forward declaring type: DropZone
  class DropZone;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: LineRenderer
  class LineRenderer;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: AudioClip
  class AudioClip;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: Color
  struct Color;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Forward declaring namespace: Photon::Pun
namespace Photon::Pun {
  // Skipping declaration: PhotonMessageInfo because it is already included!
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: Slingshot
  class Slingshot;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::Slingshot);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::Slingshot*, "", "Slingshot");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: Slingshot
  // [TokenAttribute] Offset: FFFFFFFF
  class Slingshot : public ::GlobalNamespace::TransferrableObject {
    public:
    // Nested type: ::GlobalNamespace::Slingshot::SlingshotState
    struct SlingshotState;
    // Nested type: ::GlobalNamespace::Slingshot::SlingshotActions
    struct SlingshotActions;
    public:
    // public UnityEngine.LineRenderer elasticLeft
    // Size: 0x8
    // Offset: 0x2D0
    ::UnityEngine::LineRenderer* elasticLeft;
    // Field size check
    static_assert(sizeof(::UnityEngine::LineRenderer*) == 0x8);
    // public UnityEngine.LineRenderer elasticRight
    // Size: 0x8
    // Offset: 0x2D8
    ::UnityEngine::LineRenderer* elasticRight;
    // Field size check
    static_assert(sizeof(::UnityEngine::LineRenderer*) == 0x8);
    // public UnityEngine.Transform leftArm
    // Size: 0x8
    // Offset: 0x2E0
    ::UnityEngine::Transform* leftArm;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform rightArm
    // Size: 0x8
    // Offset: 0x2E8
    ::UnityEngine::Transform* rightArm;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform center
    // Size: 0x8
    // Offset: 0x2F0
    ::UnityEngine::Transform* center;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform centerOrigin
    // Size: 0x8
    // Offset: 0x2F8
    ::UnityEngine::Transform* centerOrigin;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private UnityEngine.GameObject dummyProjectile
    // Size: 0x8
    // Offset: 0x300
    ::UnityEngine::GameObject* dummyProjectile;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.GameObject drawingHand
    // Size: 0x8
    // Offset: 0x308
    ::UnityEngine::GameObject* drawingHand;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.GameObject projectilePrefab
    // Size: 0x8
    // Offset: 0x310
    ::UnityEngine::GameObject* projectilePrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.GameObject projectileTrail
    // Size: 0x8
    // Offset: 0x318
    ::UnityEngine::GameObject* projectileTrail;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public InteractionPoint nock
    // Size: 0x8
    // Offset: 0x320
    ::GlobalNamespace::InteractionPoint* nock;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::InteractionPoint*) == 0x8);
    // public InteractionPoint grip
    // Size: 0x8
    // Offset: 0x328
    ::GlobalNamespace::InteractionPoint* grip;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::InteractionPoint*) == 0x8);
    // public System.Single springConstant
    // Size: 0x4
    // Offset: 0x330
    float springConstant;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single maxDraw
    // Size: 0x4
    // Offset: 0x334
    float maxDraw;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Transform leftHandSnap
    // Size: 0x8
    // Offset: 0x338
    ::UnityEngine::Transform* leftHandSnap;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.String _leftHandSnap_path
    // Size: 0x8
    // Offset: 0x340
    ::StringW leftHandSnap_path;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public UnityEngine.Transform rightHandSnap
    // Size: 0x8
    // Offset: 0x348
    ::UnityEngine::Transform* rightHandSnap;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.String _rightHandSnap_path
    // Size: 0x8
    // Offset: 0x350
    ::StringW rightHandSnap_path;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // public UnityEngine.AudioClip[] shootSfxClips
    // Size: 0x8
    // Offset: 0x358
    ::ArrayW<::UnityEngine::AudioClip*> shootSfxClips;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::AudioClip*>) == 0x8);
    // public UnityEngine.AudioSource shootSfx
    // Size: 0x8
    // Offset: 0x360
    ::UnityEngine::AudioSource* shootSfx;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // public System.Boolean disableWhenNotInRoom
    // Size: 0x1
    // Offset: 0x368
    bool disableWhenNotInRoom;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean hasDummyProjectile
    // Size: 0x1
    // Offset: 0x369
    bool hasDummyProjectile;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Single delayLaunchTime
    // Size: 0x4
    // Offset: 0x36C
    float delayLaunchTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single minTimeToLaunch
    // Size: 0x4
    // Offset: 0x370
    float minTimeToLaunch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single dummyProjectileColliderRadius
    // Size: 0x4
    // Offset: 0x374
    float dummyProjectileColliderRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single dummyProjectileInitialScale
    // Size: 0x4
    // Offset: 0x378
    float dummyProjectileInitialScale;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Int32 projectileCount
    // Size: 0x4
    // Offset: 0x37C
    int projectileCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Vector3[] elasticLeftPoints
    // Size: 0x8
    // Offset: 0x380
    ::ArrayW<::UnityEngine::Vector3> elasticLeftPoints;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private UnityEngine.Vector3[] elasticRightPoints
    // Size: 0x8
    // Offset: 0x388
    ::ArrayW<::UnityEngine::Vector3> elasticRightPoints;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Vector3>) == 0x8);
    // private System.Single _elasticIntialWidthMultiplier
    // Size: 0x4
    // Offset: 0x390
    float elasticIntialWidthMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Collections.Generic.Dictionary`2<System.Int32,SlingshotProjectile> activeProjectiles
    // Size: 0x8
    // Offset: 0x398
    ::System::Collections::Generic::Dictionary_2<int, ::GlobalNamespace::SlingshotProjectile*>* activeProjectiles;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<int, ::GlobalNamespace::SlingshotProjectile*>*) == 0x8);
    public:
    // Get instance field reference: public UnityEngine.LineRenderer elasticLeft
    [[deprecated("Use field access instead!")]] ::UnityEngine::LineRenderer*& dyn_elasticLeft();
    // Get instance field reference: public UnityEngine.LineRenderer elasticRight
    [[deprecated("Use field access instead!")]] ::UnityEngine::LineRenderer*& dyn_elasticRight();
    // Get instance field reference: public UnityEngine.Transform leftArm
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_leftArm();
    // Get instance field reference: public UnityEngine.Transform rightArm
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_rightArm();
    // Get instance field reference: public UnityEngine.Transform center
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_center();
    // Get instance field reference: public UnityEngine.Transform centerOrigin
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_centerOrigin();
    // Get instance field reference: private UnityEngine.GameObject dummyProjectile
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_dummyProjectile();
    // Get instance field reference: public UnityEngine.GameObject drawingHand
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_drawingHand();
    // Get instance field reference: public UnityEngine.GameObject projectilePrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_projectilePrefab();
    // Get instance field reference: public UnityEngine.GameObject projectileTrail
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_projectileTrail();
    // Get instance field reference: public InteractionPoint nock
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::InteractionPoint*& dyn_nock();
    // Get instance field reference: public InteractionPoint grip
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::InteractionPoint*& dyn_grip();
    // Get instance field reference: public System.Single springConstant
    [[deprecated("Use field access instead!")]] float& dyn_springConstant();
    // Get instance field reference: public System.Single maxDraw
    [[deprecated("Use field access instead!")]] float& dyn_maxDraw();
    // Get instance field reference: public UnityEngine.Transform leftHandSnap
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_leftHandSnap();
    // Get instance field reference: public System.String _leftHandSnap_path
    [[deprecated("Use field access instead!")]] ::StringW& dyn__leftHandSnap_path();
    // Get instance field reference: public UnityEngine.Transform rightHandSnap
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_rightHandSnap();
    // Get instance field reference: public System.String _rightHandSnap_path
    [[deprecated("Use field access instead!")]] ::StringW& dyn__rightHandSnap_path();
    // Get instance field reference: public UnityEngine.AudioClip[] shootSfxClips
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::AudioClip*>& dyn_shootSfxClips();
    // Get instance field reference: public UnityEngine.AudioSource shootSfx
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_shootSfx();
    // Get instance field reference: public System.Boolean disableWhenNotInRoom
    [[deprecated("Use field access instead!")]] bool& dyn_disableWhenNotInRoom();
    // Get instance field reference: private System.Boolean hasDummyProjectile
    [[deprecated("Use field access instead!")]] bool& dyn_hasDummyProjectile();
    // Get instance field reference: private System.Single delayLaunchTime
    [[deprecated("Use field access instead!")]] float& dyn_delayLaunchTime();
    // Get instance field reference: private System.Single minTimeToLaunch
    [[deprecated("Use field access instead!")]] float& dyn_minTimeToLaunch();
    // Get instance field reference: private System.Single dummyProjectileColliderRadius
    [[deprecated("Use field access instead!")]] float& dyn_dummyProjectileColliderRadius();
    // Get instance field reference: private System.Single dummyProjectileInitialScale
    [[deprecated("Use field access instead!")]] float& dyn_dummyProjectileInitialScale();
    // Get instance field reference: private System.Int32 projectileCount
    [[deprecated("Use field access instead!")]] int& dyn_projectileCount();
    // Get instance field reference: private UnityEngine.Vector3[] elasticLeftPoints
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_elasticLeftPoints();
    // Get instance field reference: private UnityEngine.Vector3[] elasticRightPoints
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Vector3>& dyn_elasticRightPoints();
    // Get instance field reference: private System.Single _elasticIntialWidthMultiplier
    [[deprecated("Use field access instead!")]] float& dyn__elasticIntialWidthMultiplier();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<System.Int32,SlingshotProjectile> activeProjectiles
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<int, ::GlobalNamespace::SlingshotProjectile*>*& dyn_activeProjectiles();
    // private System.Void DestroyDummyProjectile()
    // Offset: 0x296D508
    void DestroyDummyProjectile();
    // static public System.Boolean IsSlingShotEnabled()
    // Offset: 0x296E3F4
    static bool IsSlingShotEnabled();
    // private System.Void GetIsOnTeams(out System.Boolean blueTeam, out System.Boolean orangeTeam)
    // Offset: 0x296E06C
    void GetIsOnTeams(ByRef<bool> blueTeam, ByRef<bool> orangeTeam);
    // private System.Void AttachTrail(System.Int32 trailHash, UnityEngine.GameObject newProjectile, UnityEngine.Vector3 location, System.Boolean blueTeam, System.Boolean orangeTeam)
    // Offset: 0x296E540
    void AttachTrail(int trailHash, ::UnityEngine::GameObject* newProjectile, ::UnityEngine::Vector3 location, bool blueTeam, bool orangeTeam);
    // private System.Void PlayLaunchSfx()
    // Offset: 0x296E7C8
    void PlayLaunchSfx();
    // private System.Void LaunchProjectile()
    // Offset: 0x296E884
    void LaunchProjectile();
    // System.Void LaunchNetworkedProjectile(UnityEngine.Vector3 location, UnityEngine.Vector3 velocity, RoomSystem/ProjectileSource projectileSource, System.Int32 projectileCounter, System.Single scale, System.Boolean shouldOverrideColor, UnityEngine.Color color, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0x296F1A8
    void LaunchNetworkedProjectile(::UnityEngine::Vector3 location, ::UnityEngine::Vector3 velocity, ::GlobalNamespace::RoomSystem::ProjectileSource projectileSource, int projectileCounter, float scale, bool shouldOverrideColor, ::UnityEngine::Color color, ::Photon::Pun::PhotonMessageInfo info);
    // public System.Void DestroyProjectile(System.Int32 projectileCount, UnityEngine.Vector3 worldPosition)
    // Offset: 0x296F790
    void DestroyProjectile(int projectileCount, ::UnityEngine::Vector3 worldPosition);
    // private System.Boolean ForLeftHandSlingshot()
    // Offset: 0x296E368
    bool ForLeftHandSlingshot();
    // private System.Boolean InDrawingState()
    // Offset: 0x296E050
    bool InDrawingState();
    // protected override System.Void Awake()
    // Offset: 0x296D628
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::Awake()
    void Awake();
    // public override System.Void OnSpawn()
    // Offset: 0x296D658
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnSpawn()
    void OnSpawn();
    // public override System.Void OnEnable()
    // Offset: 0x296D958
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnEnable()
    void OnEnable();
    // public override System.Void OnDisable()
    // Offset: 0x296DA78
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnDisable()
    void OnDisable();
    // protected override System.Void LateUpdateShared()
    // Offset: 0x296DA94
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateShared()
    void LateUpdateShared();
    // protected override System.Void LateUpdateLocal()
    // Offset: 0x296E2A8
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateLocal()
    void LateUpdateLocal();
    // protected override System.Void LateUpdateReplicated()
    // Offset: 0x296E38C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateReplicated()
    void LateUpdateReplicated();
    // public override System.Void OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    // Offset: 0x296F870
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    void OnGrab(::GlobalNamespace::InteractionPoint* pointGrabbed, ::UnityEngine::GameObject* grabbingHand);
    // public override System.Boolean OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    // Offset: 0x296FAA4
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    bool OnRelease(::GlobalNamespace::DropZone* zoneReleased, ::UnityEngine::GameObject* releasingHand);
    // public override System.Void DropItemCleanup()
    // Offset: 0x296FCFC
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::DropItemCleanup()
    void DropItemCleanup();
    // public override System.Boolean AutoGrabTrue(System.Boolean leftGrabbingHand)
    // Offset: 0x296FD24
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::AutoGrabTrue(System.Boolean leftGrabbingHand)
    bool AutoGrabTrue(bool leftGrabbingHand);
    // public System.Void .ctor()
    // Offset: 0x296FD2C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::.ctor()
    // Base method: System.Void HoldableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Slingshot* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::Slingshot::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Slingshot*, creationType>()));
    }
  }; // Slingshot
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::DestroyDummyProjectile
// Il2CppName: DestroyDummyProjectile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::DestroyDummyProjectile)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "DestroyDummyProjectile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::IsSlingShotEnabled
// Il2CppName: IsSlingShotEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)()>(&GlobalNamespace::Slingshot::IsSlingShotEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "IsSlingShotEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::GetIsOnTeams
// Il2CppName: GetIsOnTeams
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)(ByRef<bool>, ByRef<bool>)>(&GlobalNamespace::Slingshot::GetIsOnTeams)> {
  static const MethodInfo* get() {
    static auto* blueTeam = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    static auto* orangeTeam = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "GetIsOnTeams", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{blueTeam, orangeTeam});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::AttachTrail
// Il2CppName: AttachTrail
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)(int, ::UnityEngine::GameObject*, ::UnityEngine::Vector3, bool, bool)>(&GlobalNamespace::Slingshot::AttachTrail)> {
  static const MethodInfo* get() {
    static auto* trailHash = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* newProjectile = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* location = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* blueTeam = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* orangeTeam = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "AttachTrail", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{trailHash, newProjectile, location, blueTeam, orangeTeam});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::PlayLaunchSfx
// Il2CppName: PlayLaunchSfx
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::PlayLaunchSfx)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "PlayLaunchSfx", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::LaunchProjectile
// Il2CppName: LaunchProjectile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::LaunchProjectile)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "LaunchProjectile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::LaunchNetworkedProjectile
// Il2CppName: LaunchNetworkedProjectile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3, ::GlobalNamespace::RoomSystem::ProjectileSource, int, float, bool, ::UnityEngine::Color, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::Slingshot::LaunchNetworkedProjectile)> {
  static const MethodInfo* get() {
    static auto* location = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* velocity = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* projectileSource = &::il2cpp_utils::GetClassFromName("", "RoomSystem/ProjectileSource")->byval_arg;
    static auto* projectileCounter = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* scale = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* shouldOverrideColor = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* color = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "LaunchNetworkedProjectile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{location, velocity, projectileSource, projectileCounter, scale, shouldOverrideColor, color, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::DestroyProjectile
// Il2CppName: DestroyProjectile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)(int, ::UnityEngine::Vector3)>(&GlobalNamespace::Slingshot::DestroyProjectile)> {
  static const MethodInfo* get() {
    static auto* projectileCount = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* worldPosition = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "DestroyProjectile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{projectileCount, worldPosition});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::ForLeftHandSlingshot
// Il2CppName: ForLeftHandSlingshot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::ForLeftHandSlingshot)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "ForLeftHandSlingshot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::InDrawingState
// Il2CppName: InDrawingState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::InDrawingState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "InDrawingState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::OnSpawn
// Il2CppName: OnSpawn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::OnSpawn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "OnSpawn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::LateUpdateShared
// Il2CppName: LateUpdateShared
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::LateUpdateShared)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "LateUpdateShared", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::LateUpdateLocal
// Il2CppName: LateUpdateLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::LateUpdateLocal)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "LateUpdateLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::LateUpdateReplicated
// Il2CppName: LateUpdateReplicated
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::LateUpdateReplicated)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "LateUpdateReplicated", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::OnGrab
// Il2CppName: OnGrab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)(::GlobalNamespace::InteractionPoint*, ::UnityEngine::GameObject*)>(&GlobalNamespace::Slingshot::OnGrab)> {
  static const MethodInfo* get() {
    static auto* pointGrabbed = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    static auto* grabbingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "OnGrab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointGrabbed, grabbingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::OnRelease
// Il2CppName: OnRelease
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::Slingshot::*)(::GlobalNamespace::DropZone*, ::UnityEngine::GameObject*)>(&GlobalNamespace::Slingshot::OnRelease)> {
  static const MethodInfo* get() {
    static auto* zoneReleased = &::il2cpp_utils::GetClassFromName("", "DropZone")->byval_arg;
    static auto* releasingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "OnRelease", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{zoneReleased, releasingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::DropItemCleanup
// Il2CppName: DropItemCleanup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Slingshot::*)()>(&GlobalNamespace::Slingshot::DropItemCleanup)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "DropItemCleanup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::AutoGrabTrue
// Il2CppName: AutoGrabTrue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::Slingshot::*)(bool)>(&GlobalNamespace::Slingshot::AutoGrabTrue)> {
  static const MethodInfo* get() {
    static auto* leftGrabbingHand = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Slingshot*), "AutoGrabTrue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{leftGrabbingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Slingshot::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
