// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: FlockingManager
#include "GlobalNamespace/FlockingManager.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: SlingshotProjectile
  class SlingshotProjectile;
  // Skipping declaration: FishState because it is already included!
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Transform
  class Transform;
}
// Forward declaring namespace: GorillaTagScripts
namespace GorillaTagScripts {
  // Forward declaring type: GameObjectManagerWithId
  class GameObjectManagerWithId;
}
// Forward declaring namespace: UnityEngine::Events
namespace UnityEngine::Events {
  // Forward declaring type: UnityEvent`2<T0, T1>
  template<typename T0, typename T1>
  class UnityEvent_2;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: Flocking
  class Flocking;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::Flocking);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::Flocking*, "", "Flocking");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0xD8
  #pragma pack(push, 1)
  // Autogenerated type: Flocking
  // [TokenAttribute] Offset: FFFFFFFF
  class Flocking : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::Flocking::FishState
    struct FishState;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: Flocking/FishState
    // [TokenAttribute] Offset: FFFFFFFF
    struct FishState/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: FishState
      constexpr FishState(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public Flocking/FishState flock
      static constexpr const int flock = 0;
      // Get static field: static public Flocking/FishState flock
      static ::GlobalNamespace::Flocking::FishState _get_flock();
      // Set static field: static public Flocking/FishState flock
      static void _set_flock(::GlobalNamespace::Flocking::FishState value);
      // static field const value: static public Flocking/FishState patrol
      static constexpr const int patrol = 1;
      // Get static field: static public Flocking/FishState patrol
      static ::GlobalNamespace::Flocking::FishState _get_patrol();
      // Set static field: static public Flocking/FishState patrol
      static void _set_patrol(::GlobalNamespace::Flocking::FishState value);
      // static field const value: static public Flocking/FishState followFood
      static constexpr const int followFood = 2;
      // Get static field: static public Flocking/FishState followFood
      static ::GlobalNamespace::Flocking::FishState _get_followFood();
      // Set static field: static public Flocking/FishState followFood
      static void _set_followFood(::GlobalNamespace::Flocking::FishState value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // Flocking/FishState
    #pragma pack(pop)
    static check_size<sizeof(Flocking::FishState), 0 + sizeof(int)> __GlobalNamespace_Flocking_FishStateSizeCheck;
    static_assert(sizeof(Flocking::FishState) == 0x4);
    public:
    // public System.Single minSpeed
    // Size: 0x4
    // Offset: 0x20
    float minSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single maxSpeed
    // Size: 0x4
    // Offset: 0x24
    float maxSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single rotationSpeed
    // Size: 0x4
    // Offset: 0x28
    float rotationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single maxNeighbourDistance
    // Size: 0x4
    // Offset: 0x2C
    float maxNeighbourDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single eatFoodDuration
    // Size: 0x4
    // Offset: 0x30
    float eatFoodDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single followFoodSpeedMult
    // Size: 0x4
    // Offset: 0x34
    float followFoodSpeedMult;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single avoidHandSpeed
    // Size: 0x4
    // Offset: 0x38
    float avoidHandSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single flockingAvoidanceDistance
    // Size: 0x4
    // Offset: 0x3C
    float flockingAvoidanceDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Double FollowFoodStopDistance
    // Size: 0x8
    // Offset: 0x40
    double FollowFoodStopDistance;
    // Field size check
    static_assert(sizeof(double) == 0x8);
    // public System.Single FollowFakeFoodStopDistance
    // Size: 0x4
    // Offset: 0x48
    float FollowFakeFoodStopDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single speed
    // Size: 0x4
    // Offset: 0x4C
    float speed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 averageHeading
    // Size: 0xC
    // Offset: 0x50
    ::UnityEngine::Vector3 averageHeading;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 averagePosition
    // Size: 0xC
    // Offset: 0x5C
    ::UnityEngine::Vector3 averagePosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single feedingTimeStarted
    // Size: 0x4
    // Offset: 0x68
    float feedingTimeStarted;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: feedingTimeStarted and: projectileGameObject
    char __padding13[0x4] = {};
    // private UnityEngine.GameObject projectileGameObject
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::GameObject* projectileGameObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private System.Boolean followingFood
    // Size: 0x1
    // Offset: 0x78
    bool followingFood;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: followingFood and: manager
    char __padding15[0x7] = {};
    // private FlockingManager manager
    // Size: 0x8
    // Offset: 0x80
    ::GlobalNamespace::FlockingManager* manager;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::FlockingManager*) == 0x8);
    // private GorillaTagScripts.GameObjectManagerWithId _fishSceneGameObjectsManager
    // Size: 0x8
    // Offset: 0x88
    ::GorillaTagScripts::GameObjectManagerWithId* fishSceneGameObjectsManager;
    // Field size check
    static_assert(sizeof(::GorillaTagScripts::GameObjectManagerWithId*) == 0x8);
    // private UnityEngine.Events.UnityEvent`2<System.String,UnityEngine.Transform> sendIdEvent
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::Events::UnityEvent_2<::StringW, ::UnityEngine::Transform*>* sendIdEvent;
    // Field size check
    static_assert(sizeof(::UnityEngine::Events::UnityEvent_2<::StringW, ::UnityEngine::Transform*>*) == 0x8);
    // private Flocking/FishState fishState
    // Size: 0x4
    // Offset: 0x98
    ::GlobalNamespace::Flocking::FishState fishState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::Flocking::FishState) == 0x4);
    // public UnityEngine.Vector3 pos
    // Size: 0xC
    // Offset: 0x9C
    ::UnityEngine::Vector3 pos;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Quaternion rot
    // Size: 0x10
    // Offset: 0xA8
    ::UnityEngine::Quaternion rot;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private System.Single velocity
    // Size: 0x4
    // Offset: 0xB8
    float velocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean isTurning
    // Size: 0x1
    // Offset: 0xBC
    bool isTurning;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean isRealFood
    // Size: 0x1
    // Offset: 0xBD
    bool isRealFood;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isRealFood and: avointPointRadius
    char __padding24[0x2] = {};
    // public System.Single avointPointRadius
    // Size: 0x4
    // Offset: 0xC0
    float avointPointRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single cacheSpeed
    // Size: 0x4
    // Offset: 0xC4
    float cacheSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean isAvoindingHand
    // Size: 0x1
    // Offset: 0xC8
    bool isAvoindingHand;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: isAvoindingHand and: FishArea
    char __padding27[0x7] = {};
    // private FlockingManager/FishArea <FishArea>k__BackingField
    // Size: 0x8
    // Offset: 0xD0
    ::GlobalNamespace::FlockingManager::FishArea* FishArea;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::FlockingManager::FishArea*) == 0x8);
    public:
    // Get instance field reference: public System.Single minSpeed
    [[deprecated("Use field access instead!")]] float& dyn_minSpeed();
    // Get instance field reference: public System.Single maxSpeed
    [[deprecated("Use field access instead!")]] float& dyn_maxSpeed();
    // Get instance field reference: public System.Single rotationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_rotationSpeed();
    // Get instance field reference: public System.Single maxNeighbourDistance
    [[deprecated("Use field access instead!")]] float& dyn_maxNeighbourDistance();
    // Get instance field reference: public System.Single eatFoodDuration
    [[deprecated("Use field access instead!")]] float& dyn_eatFoodDuration();
    // Get instance field reference: public System.Single followFoodSpeedMult
    [[deprecated("Use field access instead!")]] float& dyn_followFoodSpeedMult();
    // Get instance field reference: public System.Single avoidHandSpeed
    [[deprecated("Use field access instead!")]] float& dyn_avoidHandSpeed();
    // Get instance field reference: public System.Single flockingAvoidanceDistance
    [[deprecated("Use field access instead!")]] float& dyn_flockingAvoidanceDistance();
    // Get instance field reference: public System.Double FollowFoodStopDistance
    [[deprecated("Use field access instead!")]] double& dyn_FollowFoodStopDistance();
    // Get instance field reference: public System.Single FollowFakeFoodStopDistance
    [[deprecated("Use field access instead!")]] float& dyn_FollowFakeFoodStopDistance();
    // Get instance field reference: private System.Single speed
    [[deprecated("Use field access instead!")]] float& dyn_speed();
    // Get instance field reference: private UnityEngine.Vector3 averageHeading
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_averageHeading();
    // Get instance field reference: private UnityEngine.Vector3 averagePosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_averagePosition();
    // Get instance field reference: private System.Single feedingTimeStarted
    [[deprecated("Use field access instead!")]] float& dyn_feedingTimeStarted();
    // Get instance field reference: private UnityEngine.GameObject projectileGameObject
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_projectileGameObject();
    // Get instance field reference: private System.Boolean followingFood
    [[deprecated("Use field access instead!")]] bool& dyn_followingFood();
    // Get instance field reference: private FlockingManager manager
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::FlockingManager*& dyn_manager();
    // Get instance field reference: private GorillaTagScripts.GameObjectManagerWithId _fishSceneGameObjectsManager
    [[deprecated("Use field access instead!")]] ::GorillaTagScripts::GameObjectManagerWithId*& dyn__fishSceneGameObjectsManager();
    // Get instance field reference: private UnityEngine.Events.UnityEvent`2<System.String,UnityEngine.Transform> sendIdEvent
    [[deprecated("Use field access instead!")]] ::UnityEngine::Events::UnityEvent_2<::StringW, ::UnityEngine::Transform*>*& dyn_sendIdEvent();
    // Get instance field reference: private Flocking/FishState fishState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::Flocking::FishState& dyn_fishState();
    // Get instance field reference: public UnityEngine.Vector3 pos
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_pos();
    // Get instance field reference: public UnityEngine.Quaternion rot
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_rot();
    // Get instance field reference: private System.Single velocity
    [[deprecated("Use field access instead!")]] float& dyn_velocity();
    // Get instance field reference: private System.Boolean isTurning
    [[deprecated("Use field access instead!")]] bool& dyn_isTurning();
    // Get instance field reference: private System.Boolean isRealFood
    [[deprecated("Use field access instead!")]] bool& dyn_isRealFood();
    // Get instance field reference: public System.Single avointPointRadius
    [[deprecated("Use field access instead!")]] float& dyn_avointPointRadius();
    // Get instance field reference: private System.Single cacheSpeed
    [[deprecated("Use field access instead!")]] float& dyn_cacheSpeed();
    // Get instance field reference: private System.Boolean isAvoindingHand
    [[deprecated("Use field access instead!")]] bool& dyn_isAvoindingHand();
    // Get instance field reference: private FlockingManager/FishArea <FishArea>k__BackingField
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::FlockingManager::FishArea*& dyn_$FishArea$k__BackingField();
    // public FlockingManager/FishArea get_FishArea()
    // Offset: 0x26F32B4
    ::GlobalNamespace::FlockingManager::FishArea* get_FishArea();
    // public System.Void set_FishArea(FlockingManager/FishArea value)
    // Offset: 0x26F32BC
    void set_FishArea(::GlobalNamespace::FlockingManager::FishArea* value);
    // private System.Void Awake()
    // Offset: 0x26F32C4
    void Awake();
    // private System.Void Start()
    // Offset: 0x26F331C
    void Start();
    // private System.Void OnDisable()
    // Offset: 0x26F3344
    void OnDisable();
    // public System.Void InvokeUpdate()
    // Offset: 0x26F35F4
    void InvokeUpdate();
    // private System.Void MaybeTurn()
    // Offset: 0x26F3A78
    void MaybeTurn();
    // private System.Void Turn(UnityEngine.Vector3 towardPoint)
    // Offset: 0x26F4704
    void Turn(::UnityEngine::Vector3 towardPoint);
    // private System.Void SwitchState(Flocking/FishState state)
    // Offset: 0x26F48A4
    void SwitchState(::GlobalNamespace::Flocking::FishState state);
    // private System.Void Flock(UnityEngine.Vector3 nextGoal)
    // Offset: 0x26F3C5C
    void Flock(::UnityEngine::Vector3 nextGoal);
    // private System.Void HandleOnFoodDetected(SlingshotProjectile projectile, System.Boolean _isRealFood)
    // Offset: 0x26F48AC
    void HandleOnFoodDetected(::GlobalNamespace::SlingshotProjectile* projectile, bool _isRealFood);
    // private System.Void HandleOnFoodDestroyed()
    // Offset: 0x26F48FC
    void HandleOnFoodDestroyed();
    // private System.Void FollowFood()
    // Offset: 0x26F42C8
    void FollowFood();
    // private System.Void AvoidPlayerHands()
    // Offset: 0x26F3840
    void AvoidPlayerHands();
    // System.Void SetSyncPosRot(UnityEngine.Vector3 syncPos, UnityEngine.Quaternion syncRot)
    // Offset: 0x26F4A10
    void SetSyncPosRot(::UnityEngine::Vector3 syncPos, ::UnityEngine::Quaternion syncRot);
    // private System.Void OnEnable()
    // Offset: 0x26F4E34
    void OnEnable();
    // public System.Void .ctor()
    // Offset: 0x26F5138
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static Flocking* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::Flocking::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<Flocking*, creationType>()));
    }
  }; // Flocking
  #pragma pack(pop)
  static check_size<sizeof(Flocking), 208 + sizeof(::GlobalNamespace::FlockingManager::FishArea*)> __GlobalNamespace_FlockingSizeCheck;
  static_assert(sizeof(Flocking) == 0xD8);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::Flocking::FishState, "", "Flocking/FishState");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::Flocking::get_FishArea
// Il2CppName: get_FishArea
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::FlockingManager::FishArea* (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::get_FishArea)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "get_FishArea", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::set_FishArea
// Il2CppName: set_FishArea
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)(::GlobalNamespace::FlockingManager::FishArea*)>(&GlobalNamespace::Flocking::set_FishArea)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("", "FlockingManager/FishArea")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "set_FishArea", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::InvokeUpdate
// Il2CppName: InvokeUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::InvokeUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "InvokeUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::MaybeTurn
// Il2CppName: MaybeTurn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::MaybeTurn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "MaybeTurn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::Turn
// Il2CppName: Turn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)(::UnityEngine::Vector3)>(&GlobalNamespace::Flocking::Turn)> {
  static const MethodInfo* get() {
    static auto* towardPoint = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "Turn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{towardPoint});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::SwitchState
// Il2CppName: SwitchState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)(::GlobalNamespace::Flocking::FishState)>(&GlobalNamespace::Flocking::SwitchState)> {
  static const MethodInfo* get() {
    static auto* state = &::il2cpp_utils::GetClassFromName("", "Flocking/FishState")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "SwitchState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{state});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::Flock
// Il2CppName: Flock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)(::UnityEngine::Vector3)>(&GlobalNamespace::Flocking::Flock)> {
  static const MethodInfo* get() {
    static auto* nextGoal = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "Flock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{nextGoal});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::HandleOnFoodDetected
// Il2CppName: HandleOnFoodDetected
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)(::GlobalNamespace::SlingshotProjectile*, bool)>(&GlobalNamespace::Flocking::HandleOnFoodDetected)> {
  static const MethodInfo* get() {
    static auto* projectile = &::il2cpp_utils::GetClassFromName("", "SlingshotProjectile")->byval_arg;
    static auto* _isRealFood = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "HandleOnFoodDetected", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{projectile, _isRealFood});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::HandleOnFoodDestroyed
// Il2CppName: HandleOnFoodDestroyed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::HandleOnFoodDestroyed)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "HandleOnFoodDestroyed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::FollowFood
// Il2CppName: FollowFood
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::FollowFood)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "FollowFood", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::AvoidPlayerHands
// Il2CppName: AvoidPlayerHands
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::AvoidPlayerHands)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "AvoidPlayerHands", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::SetSyncPosRot
// Il2CppName: SetSyncPosRot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)(::UnityEngine::Vector3, ::UnityEngine::Quaternion)>(&GlobalNamespace::Flocking::SetSyncPosRot)> {
  static const MethodInfo* get() {
    static auto* syncPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* syncRot = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "SetSyncPosRot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{syncPos, syncRot});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::Flocking::*)()>(&GlobalNamespace::Flocking::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::Flocking*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::Flocking::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
