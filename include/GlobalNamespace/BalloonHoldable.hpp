// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: TransferrableObject
#include "GlobalNamespace/TransferrableObject.hpp"
// Including type: IFXContext
#include "GlobalNamespace/IFXContext.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: Renderer
  class Renderer;
  // Forward declaring type: LineRenderer
  class LineRenderer;
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: Collision
  class Collision;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: ITetheredObjectBehavior
  class ITetheredObjectBehavior;
  // Forward declaring type: FXSystemSettings
  class FXSystemSettings;
}
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Forward declaring namespace: GorillaLocomotion::Swimming
namespace GorillaLocomotion::Swimming {
  // Forward declaring type: WaterVolume
  class WaterVolume;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: BalloonHoldable
  class BalloonHoldable;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::BalloonHoldable);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::BalloonHoldable*, "", "BalloonHoldable");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: BalloonHoldable
  // [TokenAttribute] Offset: FFFFFFFF
  class BalloonHoldable : public ::GlobalNamespace::TransferrableObject/*, public ::GlobalNamespace::IFXContext*/ {
    public:
    // Nested type: ::GlobalNamespace::BalloonHoldable::BalloonStates
    struct BalloonStates;
    // Nested type: ::GlobalNamespace::BalloonHoldable::$$c
    class $$c;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: BalloonHoldable/BalloonStates
    // [TokenAttribute] Offset: FFFFFFFF
    struct BalloonStates/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: BalloonStates
      constexpr BalloonStates(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public BalloonHoldable/BalloonStates Normal
      static constexpr const int Normal = 0;
      // Get static field: static public BalloonHoldable/BalloonStates Normal
      static ::GlobalNamespace::BalloonHoldable::BalloonStates _get_Normal();
      // Set static field: static public BalloonHoldable/BalloonStates Normal
      static void _set_Normal(::GlobalNamespace::BalloonHoldable::BalloonStates value);
      // static field const value: static public BalloonHoldable/BalloonStates Pop
      static constexpr const int Pop = 1;
      // Get static field: static public BalloonHoldable/BalloonStates Pop
      static ::GlobalNamespace::BalloonHoldable::BalloonStates _get_Pop();
      // Set static field: static public BalloonHoldable/BalloonStates Pop
      static void _set_Pop(::GlobalNamespace::BalloonHoldable::BalloonStates value);
      // static field const value: static public BalloonHoldable/BalloonStates Waiting
      static constexpr const int Waiting = 2;
      // Get static field: static public BalloonHoldable/BalloonStates Waiting
      static ::GlobalNamespace::BalloonHoldable::BalloonStates _get_Waiting();
      // Set static field: static public BalloonHoldable/BalloonStates Waiting
      static void _set_Waiting(::GlobalNamespace::BalloonHoldable::BalloonStates value);
      // static field const value: static public BalloonHoldable/BalloonStates WaitForOwnershipTransfer
      static constexpr const int WaitForOwnershipTransfer = 3;
      // Get static field: static public BalloonHoldable/BalloonStates WaitForOwnershipTransfer
      static ::GlobalNamespace::BalloonHoldable::BalloonStates _get_WaitForOwnershipTransfer();
      // Set static field: static public BalloonHoldable/BalloonStates WaitForOwnershipTransfer
      static void _set_WaitForOwnershipTransfer(::GlobalNamespace::BalloonHoldable::BalloonStates value);
      // static field const value: static public BalloonHoldable/BalloonStates WaitForReDock
      static constexpr const int WaitForReDock = 4;
      // Get static field: static public BalloonHoldable/BalloonStates WaitForReDock
      static ::GlobalNamespace::BalloonHoldable::BalloonStates _get_WaitForReDock();
      // Set static field: static public BalloonHoldable/BalloonStates WaitForReDock
      static void _set_WaitForReDock(::GlobalNamespace::BalloonHoldable::BalloonStates value);
      // static field const value: static public BalloonHoldable/BalloonStates Refilling
      static constexpr const int Refilling = 5;
      // Get static field: static public BalloonHoldable/BalloonStates Refilling
      static ::GlobalNamespace::BalloonHoldable::BalloonStates _get_Refilling();
      // Set static field: static public BalloonHoldable/BalloonStates Refilling
      static void _set_Refilling(::GlobalNamespace::BalloonHoldable::BalloonStates value);
      // static field const value: static public BalloonHoldable/BalloonStates Returning
      static constexpr const int Returning = 6;
      // Get static field: static public BalloonHoldable/BalloonStates Returning
      static ::GlobalNamespace::BalloonHoldable::BalloonStates _get_Returning();
      // Set static field: static public BalloonHoldable/BalloonStates Returning
      static void _set_Returning(::GlobalNamespace::BalloonHoldable::BalloonStates value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // BalloonHoldable/BalloonStates
    #pragma pack(pop)
    static check_size<sizeof(BalloonHoldable::BalloonStates), 0 + sizeof(int)> __GlobalNamespace_BalloonHoldable_BalloonStatesSizeCheck;
    static_assert(sizeof(BalloonHoldable::BalloonStates) == 0x4);
    public:
    // private ITetheredObjectBehavior balloonDynamics
    // Size: 0x8
    // Offset: 0x2D0
    ::GlobalNamespace::ITetheredObjectBehavior* balloonDynamics;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::ITetheredObjectBehavior*) == 0x8);
    // private UnityEngine.Renderer mesh
    // Size: 0x8
    // Offset: 0x2D8
    ::UnityEngine::Renderer* mesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::Renderer*) == 0x8);
    // private UnityEngine.LineRenderer lineRenderer
    // Size: 0x8
    // Offset: 0x2E0
    ::UnityEngine::LineRenderer* lineRenderer;
    // Field size check
    static_assert(sizeof(::UnityEngine::LineRenderer*) == 0x8);
    // private UnityEngine.Rigidbody rb
    // Size: 0x8
    // Offset: 0x2E8
    ::UnityEngine::Rigidbody* rb;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // private Photon.Realtime.Player originalOwner
    // Size: 0x8
    // Offset: 0x2F0
    ::Photon::Realtime::Player* originalOwner;
    // Field size check
    static_assert(sizeof(::Photon::Realtime::Player*) == 0x8);
    // public UnityEngine.GameObject balloonPopFXPrefab
    // Size: 0x8
    // Offset: 0x2F8
    ::UnityEngine::GameObject* balloonPopFXPrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.Color balloonPopFXColor
    // Size: 0x10
    // Offset: 0x300
    ::UnityEngine::Color balloonPopFXColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private System.Single timer
    // Size: 0x4
    // Offset: 0x310
    float timer;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single scaleTimerLength
    // Size: 0x4
    // Offset: 0x314
    float scaleTimerLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single poppedTimerLength
    // Size: 0x4
    // Offset: 0x318
    float poppedTimerLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single beginScale
    // Size: 0x4
    // Offset: 0x31C
    float beginScale;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single bopSpeed
    // Size: 0x4
    // Offset: 0x320
    float bopSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 localScale
    // Size: 0xC
    // Offset: 0x324
    ::UnityEngine::Vector3 localScale;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.AudioSource balloonBopSource
    // Size: 0x8
    // Offset: 0x330
    ::UnityEngine::AudioSource* balloonBopSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // public UnityEngine.AudioSource balloonInflatSource
    // Size: 0x8
    // Offset: 0x338
    ::UnityEngine::AudioSource* balloonInflatSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.Vector3 forceAppliedAsRemote
    // Size: 0xC
    // Offset: 0x340
    ::UnityEngine::Vector3 forceAppliedAsRemote;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 collisionPtAsRemote
    // Size: 0xC
    // Offset: 0x34C
    ::UnityEngine::Vector3 collisionPtAsRemote;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private GorillaLocomotion.Swimming.WaterVolume waterVolume
    // Size: 0x8
    // Offset: 0x358
    ::GorillaLocomotion::Swimming::WaterVolume* waterVolume;
    // Field size check
    static_assert(sizeof(::GorillaLocomotion::Swimming::WaterVolume*) == 0x8);
    // private BalloonHoldable/BalloonStates balloonState
    // Size: 0x4
    // Offset: 0x360
    ::GlobalNamespace::BalloonHoldable::BalloonStates balloonState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::BalloonHoldable::BalloonStates) == 0x4);
    // private System.Single returnTimer
    // Size: 0x4
    // Offset: 0x364
    float returnTimer;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single lastOwnershipRequest
    // Size: 0x4
    // Offset: 0x368
    float lastOwnershipRequest;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean disableCollisionHandling
    // Size: 0x1
    // Offset: 0x36C
    bool disableCollisionHandling;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean disableRelease
    // Size: 0x1
    // Offset: 0x36D
    bool disableRelease;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator ::GlobalNamespace::IFXContext
    operator ::GlobalNamespace::IFXContext() noexcept {
      return *reinterpret_cast<::GlobalNamespace::IFXContext*>(this);
    }
    // Get instance field reference: private ITetheredObjectBehavior balloonDynamics
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::ITetheredObjectBehavior*& dyn_balloonDynamics();
    // Get instance field reference: private UnityEngine.Renderer mesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::Renderer*& dyn_mesh();
    // Get instance field reference: private UnityEngine.LineRenderer lineRenderer
    [[deprecated("Use field access instead!")]] ::UnityEngine::LineRenderer*& dyn_lineRenderer();
    // Get instance field reference: private UnityEngine.Rigidbody rb
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_rb();
    // Get instance field reference: private Photon.Realtime.Player originalOwner
    [[deprecated("Use field access instead!")]] ::Photon::Realtime::Player*& dyn_originalOwner();
    // Get instance field reference: public UnityEngine.GameObject balloonPopFXPrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_balloonPopFXPrefab();
    // Get instance field reference: public UnityEngine.Color balloonPopFXColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_balloonPopFXColor();
    // Get instance field reference: private System.Single timer
    [[deprecated("Use field access instead!")]] float& dyn_timer();
    // Get instance field reference: public System.Single scaleTimerLength
    [[deprecated("Use field access instead!")]] float& dyn_scaleTimerLength();
    // Get instance field reference: public System.Single poppedTimerLength
    [[deprecated("Use field access instead!")]] float& dyn_poppedTimerLength();
    // Get instance field reference: public System.Single beginScale
    [[deprecated("Use field access instead!")]] float& dyn_beginScale();
    // Get instance field reference: public System.Single bopSpeed
    [[deprecated("Use field access instead!")]] float& dyn_bopSpeed();
    // Get instance field reference: private UnityEngine.Vector3 localScale
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_localScale();
    // Get instance field reference: public UnityEngine.AudioSource balloonBopSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_balloonBopSource();
    // Get instance field reference: public UnityEngine.AudioSource balloonInflatSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_balloonInflatSource();
    // Get instance field reference: private UnityEngine.Vector3 forceAppliedAsRemote
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_forceAppliedAsRemote();
    // Get instance field reference: private UnityEngine.Vector3 collisionPtAsRemote
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_collisionPtAsRemote();
    // Get instance field reference: private GorillaLocomotion.Swimming.WaterVolume waterVolume
    [[deprecated("Use field access instead!")]] ::GorillaLocomotion::Swimming::WaterVolume*& dyn_waterVolume();
    // Get instance field reference: private BalloonHoldable/BalloonStates balloonState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::BalloonHoldable::BalloonStates& dyn_balloonState();
    // Get instance field reference: private System.Single returnTimer
    [[deprecated("Use field access instead!")]] float& dyn_returnTimer();
    // Get instance field reference: public System.Single lastOwnershipRequest
    [[deprecated("Use field access instead!")]] float& dyn_lastOwnershipRequest();
    // Get instance field reference: private System.Boolean disableCollisionHandling
    [[deprecated("Use field access instead!")]] bool& dyn_disableCollisionHandling();
    // Get instance field reference: private System.Boolean disableRelease
    [[deprecated("Use field access instead!")]] bool& dyn_disableRelease();
    // private System.Boolean ShouldSimulate()
    // Offset: 0x2964B74
    bool ShouldSimulate();
    // private System.Void PlayPopBalloonFX()
    // Offset: 0x29652F0
    void PlayPopBalloonFX();
    // private System.Void EnableDynamics(System.Boolean enable, System.Boolean forceKinematicOn)
    // Offset: 0x2964478
    void EnableDynamics(bool enable, bool forceKinematicOn);
    // private System.Void PopBalloon()
    // Offset: 0x2964F74
    void PopBalloon();
    // public System.Void PopBalloonRemote()
    // Offset: 0x29655DC
    void PopBalloonRemote();
    // public System.Void OnOwnerChangeCb(Photon.Realtime.Player newOwner, Photon.Realtime.Player prevOwner)
    // Offset: 0x29655FC
    void OnOwnerChangeCb(::Photon::Realtime::Player* newOwner, ::Photon::Realtime::Player* prevOwner);
    // private System.Void OwnerPopBalloon()
    // Offset: 0x296582C
    void OwnerPopBalloon();
    // private System.Void RunLocalPopSM()
    // Offset: 0x2965968
    void RunLocalPopSM();
    // private System.Void Grab()
    // Offset: 0x2964774
    void Grab();
    // private System.Void Release()
    // Offset: 0x2964928
    void Release();
    // public System.Void OnTriggerEnter(UnityEngine.Collider other)
    // Offset: 0x2965FD4
    void OnTriggerEnter(::UnityEngine::Collider* other);
    // public System.Void OnCollisionEnter(UnityEngine.Collision collision)
    // Offset: 0x2966398
    void OnCollisionEnter(::UnityEngine::Collision* collision);
    // private FXSystemSettings IFXContext.get_settings()
    // Offset: 0x29664C8
    ::GlobalNamespace::FXSystemSettings* IFXContext_get_settings();
    // private System.Void IFXContext.OnPlayFX()
    // Offset: 0x29664E4
    void IFXContext_OnPlayFX();
    // public override System.Void OnSpawn()
    // Offset: 0x296434C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnSpawn()
    void OnSpawn();
    // protected override System.Void Start()
    // Offset: 0x2964454
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::Start()
    void Start();
    // public override System.Void OnEnable()
    // Offset: 0x2964630
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnEnable()
    void OnEnable();
    // public override System.Void OnJoinedRoom()
    // Offset: 0x2964AEC
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnJoinedRoom()
    void OnJoinedRoom();
    // public override System.Void OnDisable()
    // Offset: 0x2964BB4
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnDisable()
    void OnDisable();
    // public override System.Void PreDisable()
    // Offset: 0x2964BF0
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::PreDisable()
    void PreDisable();
    // public override System.Void ResetToDefaultState()
    // Offset: 0x2964C18
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::ResetToDefaultState()
    void ResetToDefaultState();
    // protected override System.Void OnWorldShareableItemSpawn()
    // Offset: 0x2964C94
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnWorldShareableItemSpawn()
    void OnWorldShareableItemSpawn();
    // public override System.Void ResetToHome()
    // Offset: 0x2964DE4
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::ResetToHome()
    void ResetToHome();
    // protected override System.Void PlayDestroyedOrDisabledEffect()
    // Offset: 0x29652B4
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::PlayDestroyedOrDisabledEffect()
    void PlayDestroyedOrDisabledEffect();
    // protected override System.Void OnItemDestroyedOrDisabled()
    // Offset: 0x296531C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnItemDestroyedOrDisabled()
    void OnItemDestroyedOrDisabled();
    // public override System.Void OnOwnershipTransferred(Photon.Realtime.Player newOwner, Photon.Realtime.Player prevOwner)
    // Offset: 0x2965600
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnOwnershipTransferred(Photon.Realtime.Player newOwner, Photon.Realtime.Player prevOwner)
    void OnOwnershipTransferred(::Photon::Realtime::Player* newOwner, ::Photon::Realtime::Player* prevOwner);
    // protected override System.Void LateUpdateShared()
    // Offset: 0x2965D5C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateShared()
    void LateUpdateShared();
    // protected override System.Void LateUpdateReplicated()
    // Offset: 0x2965FCC
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateReplicated()
    void LateUpdateReplicated();
    // public System.Void .ctor()
    // Offset: 0x2966680
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::.ctor()
    // Base method: System.Void HoldableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static BalloonHoldable* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::BalloonHoldable::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<BalloonHoldable*, creationType>()));
    }
  }; // BalloonHoldable
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::BalloonHoldable::BalloonStates, "", "BalloonHoldable/BalloonStates");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::ShouldSimulate
// Il2CppName: ShouldSimulate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::ShouldSimulate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "ShouldSimulate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::PlayPopBalloonFX
// Il2CppName: PlayPopBalloonFX
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::PlayPopBalloonFX)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "PlayPopBalloonFX", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::EnableDynamics
// Il2CppName: EnableDynamics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)(bool, bool)>(&GlobalNamespace::BalloonHoldable::EnableDynamics)> {
  static const MethodInfo* get() {
    static auto* enable = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* forceKinematicOn = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "EnableDynamics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{enable, forceKinematicOn});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::PopBalloon
// Il2CppName: PopBalloon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::PopBalloon)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "PopBalloon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::PopBalloonRemote
// Il2CppName: PopBalloonRemote
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::PopBalloonRemote)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "PopBalloonRemote", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnOwnerChangeCb
// Il2CppName: OnOwnerChangeCb
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)(::Photon::Realtime::Player*, ::Photon::Realtime::Player*)>(&GlobalNamespace::BalloonHoldable::OnOwnerChangeCb)> {
  static const MethodInfo* get() {
    static auto* newOwner = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    static auto* prevOwner = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnOwnerChangeCb", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newOwner, prevOwner});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OwnerPopBalloon
// Il2CppName: OwnerPopBalloon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::OwnerPopBalloon)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OwnerPopBalloon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::RunLocalPopSM
// Il2CppName: RunLocalPopSM
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::RunLocalPopSM)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "RunLocalPopSM", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::Grab
// Il2CppName: Grab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::Grab)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "Grab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::Release
// Il2CppName: Release
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::Release)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "Release", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnTriggerEnter
// Il2CppName: OnTriggerEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)(::UnityEngine::Collider*)>(&GlobalNamespace::BalloonHoldable::OnTriggerEnter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnTriggerEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnCollisionEnter
// Il2CppName: OnCollisionEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)(::UnityEngine::Collision*)>(&GlobalNamespace::BalloonHoldable::OnCollisionEnter)> {
  static const MethodInfo* get() {
    static auto* collision = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collision")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnCollisionEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collision});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::IFXContext_get_settings
// Il2CppName: IFXContext.get_settings
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::FXSystemSettings* (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::IFXContext_get_settings)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "IFXContext.get_settings", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::IFXContext_OnPlayFX
// Il2CppName: IFXContext.OnPlayFX
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::IFXContext_OnPlayFX)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "IFXContext.OnPlayFX", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnSpawn
// Il2CppName: OnSpawn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::OnSpawn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnSpawn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnJoinedRoom
// Il2CppName: OnJoinedRoom
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::OnJoinedRoom)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnJoinedRoom", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::PreDisable
// Il2CppName: PreDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::PreDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "PreDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::ResetToDefaultState
// Il2CppName: ResetToDefaultState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::ResetToDefaultState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "ResetToDefaultState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnWorldShareableItemSpawn
// Il2CppName: OnWorldShareableItemSpawn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::OnWorldShareableItemSpawn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnWorldShareableItemSpawn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::ResetToHome
// Il2CppName: ResetToHome
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::ResetToHome)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "ResetToHome", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::PlayDestroyedOrDisabledEffect
// Il2CppName: PlayDestroyedOrDisabledEffect
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::PlayDestroyedOrDisabledEffect)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "PlayDestroyedOrDisabledEffect", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnItemDestroyedOrDisabled
// Il2CppName: OnItemDestroyedOrDisabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::OnItemDestroyedOrDisabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnItemDestroyedOrDisabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::OnOwnershipTransferred
// Il2CppName: OnOwnershipTransferred
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)(::Photon::Realtime::Player*, ::Photon::Realtime::Player*)>(&GlobalNamespace::BalloonHoldable::OnOwnershipTransferred)> {
  static const MethodInfo* get() {
    static auto* newOwner = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    static auto* prevOwner = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "OnOwnershipTransferred", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newOwner, prevOwner});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::LateUpdateShared
// Il2CppName: LateUpdateShared
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::LateUpdateShared)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "LateUpdateShared", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::LateUpdateReplicated
// Il2CppName: LateUpdateReplicated
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonHoldable::*)()>(&GlobalNamespace::BalloonHoldable::LateUpdateReplicated)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonHoldable*), "LateUpdateReplicated", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonHoldable::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
