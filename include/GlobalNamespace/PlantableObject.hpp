// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: TransferrableObject
#include "GlobalNamespace/TransferrableObject.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Skipping declaration: AppliedColors because it is already included!
  // Forward declaring type: PlantablePoint
  class PlantablePoint;
  // Forward declaring type: InteractionPoint
  class InteractionPoint;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: SkinnedMeshRenderer
  class SkinnedMeshRenderer;
  // Forward declaring type: MaterialPropertyBlock
  class MaterialPropertyBlock;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: GameObject
  class GameObject;
}
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: PlantableObject
  class PlantableObject;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::PlantableObject);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::PlantableObject*, "", "PlantableObject");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: PlantableObject
  // [TokenAttribute] Offset: FFFFFFFF
  class PlantableObject : public ::GlobalNamespace::TransferrableObject {
    public:
    // Nested type: ::GlobalNamespace::PlantableObject::AppliedColors
    struct AppliedColors;
    // Nested type: ::GlobalNamespace::PlantableObject::$$c__DisplayClass41_0
    class $$c__DisplayClass41_0;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: PlantableObject/AppliedColors
    // [TokenAttribute] Offset: FFFFFFFF
    struct AppliedColors/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: AppliedColors
      constexpr AppliedColors(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public PlantableObject/AppliedColors None
      static constexpr const int None = 0;
      // Get static field: static public PlantableObject/AppliedColors None
      static ::GlobalNamespace::PlantableObject::AppliedColors _get_None();
      // Set static field: static public PlantableObject/AppliedColors None
      static void _set_None(::GlobalNamespace::PlantableObject::AppliedColors value);
      // static field const value: static public PlantableObject/AppliedColors Red
      static constexpr const int Red = 1;
      // Get static field: static public PlantableObject/AppliedColors Red
      static ::GlobalNamespace::PlantableObject::AppliedColors _get_Red();
      // Set static field: static public PlantableObject/AppliedColors Red
      static void _set_Red(::GlobalNamespace::PlantableObject::AppliedColors value);
      // static field const value: static public PlantableObject/AppliedColors Green
      static constexpr const int Green = 2;
      // Get static field: static public PlantableObject/AppliedColors Green
      static ::GlobalNamespace::PlantableObject::AppliedColors _get_Green();
      // Set static field: static public PlantableObject/AppliedColors Green
      static void _set_Green(::GlobalNamespace::PlantableObject::AppliedColors value);
      // static field const value: static public PlantableObject/AppliedColors Blue
      static constexpr const int Blue = 3;
      // Get static field: static public PlantableObject/AppliedColors Blue
      static ::GlobalNamespace::PlantableObject::AppliedColors _get_Blue();
      // Set static field: static public PlantableObject/AppliedColors Blue
      static void _set_Blue(::GlobalNamespace::PlantableObject::AppliedColors value);
      // static field const value: static public PlantableObject/AppliedColors Black
      static constexpr const int Black = 4;
      // Get static field: static public PlantableObject/AppliedColors Black
      static ::GlobalNamespace::PlantableObject::AppliedColors _get_Black();
      // Set static field: static public PlantableObject/AppliedColors Black
      static void _set_Black(::GlobalNamespace::PlantableObject::AppliedColors value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // PlantableObject/AppliedColors
    #pragma pack(pop)
    static check_size<sizeof(PlantableObject::AppliedColors), 0 + sizeof(int)> __GlobalNamespace_PlantableObject_AppliedColorsSizeCheck;
    static_assert(sizeof(PlantableObject::AppliedColors) == 0x4);
    public:
    // public PlantablePoint point
    // Size: 0x8
    // Offset: 0x2D0
    ::GlobalNamespace::PlantablePoint* point;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::PlantablePoint*) == 0x8);
    // public System.Single respawnAfterDuration
    // Size: 0x4
    // Offset: 0x2D8
    float respawnAfterDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single respawnAtTimestamp
    // Size: 0x4
    // Offset: 0x2DC
    float respawnAtTimestamp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.SkinnedMeshRenderer flagRenderer
    // Size: 0x8
    // Offset: 0x2E0
    ::UnityEngine::SkinnedMeshRenderer* flagRenderer;
    // Field size check
    static_assert(sizeof(::UnityEngine::SkinnedMeshRenderer*) == 0x8);
    // private System.Int32 colorRShaderPropID
    // Size: 0x4
    // Offset: 0x2E8
    int colorRShaderPropID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 colorGShaderPropID
    // Size: 0x4
    // Offset: 0x2EC
    int colorGShaderPropID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 colorBShaderPropID
    // Size: 0x4
    // Offset: 0x2F0
    int colorBShaderPropID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.MaterialPropertyBlock materialPropertyBlock
    // Size: 0x8
    // Offset: 0x2F8
    ::UnityEngine::MaterialPropertyBlock* materialPropertyBlock;
    // Field size check
    static_assert(sizeof(::UnityEngine::MaterialPropertyBlock*) == 0x8);
    // private UnityEngine.Color _colorR
    // Size: 0x10
    // Offset: 0x300
    ::UnityEngine::Color colorR;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private UnityEngine.Color _colorG
    // Size: 0x10
    // Offset: 0x310
    ::UnityEngine::Color colorG;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private System.Boolean <planted>k__BackingField
    // Size: 0x1
    // Offset: 0x320
    bool planted;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public UnityEngine.Transform flagTip
    // Size: 0x8
    // Offset: 0x328
    ::UnityEngine::Transform* flagTip;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public PlantableObject/AppliedColors[] dippedColors
    // Size: 0x8
    // Offset: 0x330
    ::ArrayW<::GlobalNamespace::PlantableObject::AppliedColors> dippedColors;
    // Field size check
    static_assert(sizeof(::ArrayW<::GlobalNamespace::PlantableObject::AppliedColors>) == 0x8);
    // public System.Int32 currentDipIndex
    // Size: 0x4
    // Offset: 0x338
    int currentDipIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // Get instance field reference: public PlantablePoint point
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::PlantablePoint*& dyn_point();
    // Get instance field reference: public System.Single respawnAfterDuration
    [[deprecated("Use field access instead!")]] float& dyn_respawnAfterDuration();
    // Get instance field reference: private System.Single respawnAtTimestamp
    [[deprecated("Use field access instead!")]] float& dyn_respawnAtTimestamp();
    // Get instance field reference: public UnityEngine.SkinnedMeshRenderer flagRenderer
    [[deprecated("Use field access instead!")]] ::UnityEngine::SkinnedMeshRenderer*& dyn_flagRenderer();
    // Get instance field reference: private System.Int32 colorRShaderPropID
    [[deprecated("Use field access instead!")]] int& dyn_colorRShaderPropID();
    // Get instance field reference: private System.Int32 colorGShaderPropID
    [[deprecated("Use field access instead!")]] int& dyn_colorGShaderPropID();
    // Get instance field reference: private System.Int32 colorBShaderPropID
    [[deprecated("Use field access instead!")]] int& dyn_colorBShaderPropID();
    // Get instance field reference: private UnityEngine.MaterialPropertyBlock materialPropertyBlock
    [[deprecated("Use field access instead!")]] ::UnityEngine::MaterialPropertyBlock*& dyn_materialPropertyBlock();
    // Get instance field reference: private UnityEngine.Color _colorR
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn__colorR();
    // Get instance field reference: private UnityEngine.Color _colorG
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn__colorG();
    // Get instance field reference: private System.Boolean <planted>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$planted$k__BackingField();
    // Get instance field reference: public UnityEngine.Transform flagTip
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_flagTip();
    // Get instance field reference: public PlantableObject/AppliedColors[] dippedColors
    [[deprecated("Use field access instead!")]] ::ArrayW<::GlobalNamespace::PlantableObject::AppliedColors>& dyn_dippedColors();
    // Get instance field reference: public System.Int32 currentDipIndex
    [[deprecated("Use field access instead!")]] int& dyn_currentDipIndex();
    // private System.Void AssureShaderStuff()
    // Offset: 0x26BC084
    void AssureShaderStuff();
    // public UnityEngine.Color get_colorR()
    // Offset: 0x26BC31C
    ::UnityEngine::Color get_colorR();
    // public System.Void set_colorR(UnityEngine.Color value)
    // Offset: 0x26BC330
    void set_colorR(::UnityEngine::Color value);
    // public UnityEngine.Color get_colorG()
    // Offset: 0x26BC344
    ::UnityEngine::Color get_colorG();
    // public System.Void set_colorG(UnityEngine.Color value)
    // Offset: 0x26BC358
    void set_colorG(::UnityEngine::Color value);
    // public System.Boolean get_planted()
    // Offset: 0x26BC36C
    bool get_planted();
    // private System.Void set_planted(System.Boolean value)
    // Offset: 0x26BC374
    void set_planted(bool value);
    // public System.Void SetPlanted(System.Boolean newPlanted)
    // Offset: 0x26BC380
    void SetPlanted(bool newPlanted);
    // private System.Void AddRed()
    // Offset: 0x26BC404
    void AddRed();
    // private System.Void AddGreen()
    // Offset: 0x26BC454
    void AddGreen();
    // private System.Void AddBlue()
    // Offset: 0x26BC45C
    void AddBlue();
    // private System.Void AddBlack()
    // Offset: 0x26BC464
    void AddBlack();
    // public System.Void AddColor(PlantableObject/AppliedColors color)
    // Offset: 0x26BC40C
    void AddColor(::GlobalNamespace::PlantableObject::AppliedColors color);
    // public System.Void ClearColors()
    // Offset: 0x26BC494
    void ClearColors();
    // public UnityEngine.Color CalculateOutputColor()
    // Offset: 0x26BC4E8
    ::UnityEngine::Color CalculateOutputColor();
    // public System.Void UpdateDisplayedDippedColor()
    // Offset: 0x26BC46C
    void UpdateDisplayedDippedColor();
    // protected override System.Void Awake()
    // Offset: 0x26BB9F8
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::Awake()
    void Awake();
    // public override System.Void OnSpawn()
    // Offset: 0x26BBB14
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnSpawn()
    void OnSpawn();
    // public override System.Void DropItem()
    // Offset: 0x26BC6E8
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::DropItem()
    void DropItem();
    // protected override System.Void LateUpdateLocal()
    // Offset: 0x26BCA58
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateLocal()
    void LateUpdateLocal();
    // protected override System.Void LateUpdateShared()
    // Offset: 0x26BCBBC
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateShared()
    void LateUpdateShared();
    // public override System.Void OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    // Offset: 0x26BCF5C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    void OnGrab(::GlobalNamespace::InteractionPoint* pointGrabbed, ::UnityEngine::GameObject* grabbingHand);
    // public override System.Boolean ShouldBeKinematic()
    // Offset: 0x26BD548
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::ShouldBeKinematic()
    bool ShouldBeKinematic();
    // public override System.Void OnOwnershipTransferred(Photon.Realtime.Player toPlayer, Photon.Realtime.Player fromPlayer)
    // Offset: 0x26BD5BC
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnOwnershipTransferred(Photon.Realtime.Player toPlayer, Photon.Realtime.Player fromPlayer)
    void OnOwnershipTransferred(::Photon::Realtime::Player* toPlayer, ::Photon::Realtime::Player* fromPlayer);
    // public System.Void .ctor()
    // Offset: 0x26BD97C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::.ctor()
    // Base method: System.Void HoldableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static PlantableObject* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::PlantableObject::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<PlantableObject*, creationType>()));
    }
  }; // PlantableObject
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::PlantableObject::AppliedColors, "", "PlantableObject/AppliedColors");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::AssureShaderStuff
// Il2CppName: AssureShaderStuff
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::AssureShaderStuff)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "AssureShaderStuff", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::get_colorR
// Il2CppName: get_colorR
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Color (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::get_colorR)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "get_colorR", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::set_colorR
// Il2CppName: set_colorR
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)(::UnityEngine::Color)>(&GlobalNamespace::PlantableObject::set_colorR)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "set_colorR", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::get_colorG
// Il2CppName: get_colorG
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Color (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::get_colorG)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "get_colorG", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::set_colorG
// Il2CppName: set_colorG
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)(::UnityEngine::Color)>(&GlobalNamespace::PlantableObject::set_colorG)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "set_colorG", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::get_planted
// Il2CppName: get_planted
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::get_planted)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "get_planted", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::set_planted
// Il2CppName: set_planted
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)(bool)>(&GlobalNamespace::PlantableObject::set_planted)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "set_planted", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::SetPlanted
// Il2CppName: SetPlanted
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)(bool)>(&GlobalNamespace::PlantableObject::SetPlanted)> {
  static const MethodInfo* get() {
    static auto* newPlanted = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "SetPlanted", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newPlanted});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::AddRed
// Il2CppName: AddRed
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::AddRed)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "AddRed", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::AddGreen
// Il2CppName: AddGreen
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::AddGreen)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "AddGreen", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::AddBlue
// Il2CppName: AddBlue
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::AddBlue)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "AddBlue", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::AddBlack
// Il2CppName: AddBlack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::AddBlack)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "AddBlack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::AddColor
// Il2CppName: AddColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)(::GlobalNamespace::PlantableObject::AppliedColors)>(&GlobalNamespace::PlantableObject::AddColor)> {
  static const MethodInfo* get() {
    static auto* color = &::il2cpp_utils::GetClassFromName("", "PlantableObject/AppliedColors")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "AddColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{color});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::ClearColors
// Il2CppName: ClearColors
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::ClearColors)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "ClearColors", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::CalculateOutputColor
// Il2CppName: CalculateOutputColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Color (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::CalculateOutputColor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "CalculateOutputColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::UpdateDisplayedDippedColor
// Il2CppName: UpdateDisplayedDippedColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::UpdateDisplayedDippedColor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "UpdateDisplayedDippedColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::OnSpawn
// Il2CppName: OnSpawn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::OnSpawn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "OnSpawn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::DropItem
// Il2CppName: DropItem
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::DropItem)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "DropItem", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::LateUpdateLocal
// Il2CppName: LateUpdateLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::LateUpdateLocal)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "LateUpdateLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::LateUpdateShared
// Il2CppName: LateUpdateShared
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::LateUpdateShared)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "LateUpdateShared", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::OnGrab
// Il2CppName: OnGrab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)(::GlobalNamespace::InteractionPoint*, ::UnityEngine::GameObject*)>(&GlobalNamespace::PlantableObject::OnGrab)> {
  static const MethodInfo* get() {
    static auto* pointGrabbed = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    static auto* grabbingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "OnGrab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointGrabbed, grabbingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::ShouldBeKinematic
// Il2CppName: ShouldBeKinematic
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::PlantableObject::*)()>(&GlobalNamespace::PlantableObject::ShouldBeKinematic)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "ShouldBeKinematic", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::OnOwnershipTransferred
// Il2CppName: OnOwnershipTransferred
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::PlantableObject::*)(::Photon::Realtime::Player*, ::Photon::Realtime::Player*)>(&GlobalNamespace::PlantableObject::OnOwnershipTransferred)> {
  static const MethodInfo* get() {
    static auto* toPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    static auto* fromPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::PlantableObject*), "OnOwnershipTransferred", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{toPlayer, fromPlayer});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::PlantableObject::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
