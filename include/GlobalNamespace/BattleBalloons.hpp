// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: VRRig
  class VRRig;
  // Forward declaring type: GorillaBattleManager
  class GorillaBattleManager;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: MaterialPropertyBlock
  class MaterialPropertyBlock;
  // Forward declaring type: Renderer
  class Renderer;
}
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: BattleBalloons
  class BattleBalloons;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::BattleBalloons);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::BattleBalloons*, "", "BattleBalloons");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0xB8
  #pragma pack(push, 1)
  // Autogenerated type: BattleBalloons
  // [TokenAttribute] Offset: FFFFFFFF
  class BattleBalloons : public ::UnityEngine::MonoBehaviour {
    public:
    public:
    // public VRRig myRig
    // Size: 0x8
    // Offset: 0x20
    ::GlobalNamespace::VRRig* myRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRRig*) == 0x8);
    // public UnityEngine.GameObject[] balloons
    // Size: 0x8
    // Offset: 0x28
    ::ArrayW<::UnityEngine::GameObject*> balloons;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::GameObject*>) == 0x8);
    // public UnityEngine.Color orangeColor
    // Size: 0x10
    // Offset: 0x30
    ::UnityEngine::Color orangeColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.Color blueColor
    // Size: 0x10
    // Offset: 0x40
    ::UnityEngine::Color blueColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.Color defaultColor
    // Size: 0x10
    // Offset: 0x50
    ::UnityEngine::Color defaultColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.Color lastColor
    // Size: 0x10
    // Offset: 0x60
    ::UnityEngine::Color lastColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.GameObject balloonPopFXPrefab
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::GameObject* balloonPopFXPrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public GorillaBattleManager bMgr
    // Size: 0x8
    // Offset: 0x78
    ::GlobalNamespace::GorillaBattleManager* bMgr;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GorillaBattleManager*) == 0x8);
    // public Photon.Realtime.Player myPlayer
    // Size: 0x8
    // Offset: 0x80
    ::Photon::Realtime::Player* myPlayer;
    // Field size check
    static_assert(sizeof(::Photon::Realtime::Player*) == 0x8);
    // private System.Int32 colorShaderPropID
    // Size: 0x4
    // Offset: 0x88
    int colorShaderPropID;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: colorShaderPropID and: matPropBlock
    char __padding9[0x4] = {};
    // private UnityEngine.MaterialPropertyBlock matPropBlock
    // Size: 0x8
    // Offset: 0x90
    ::UnityEngine::MaterialPropertyBlock* matPropBlock;
    // Field size check
    static_assert(sizeof(::UnityEngine::MaterialPropertyBlock*) == 0x8);
    // private System.Boolean[] balloonsCachedActiveState
    // Size: 0x8
    // Offset: 0x98
    ::ArrayW<bool> balloonsCachedActiveState;
    // Field size check
    static_assert(sizeof(::ArrayW<bool>) == 0x8);
    // private UnityEngine.Renderer[] renderers
    // Size: 0x8
    // Offset: 0xA0
    ::ArrayW<::UnityEngine::Renderer*> renderers;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Renderer*>) == 0x8);
    // private UnityEngine.Color teamColor
    // Size: 0x10
    // Offset: 0xA8
    ::UnityEngine::Color teamColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    public:
    // Get instance field reference: public VRRig myRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRRig*& dyn_myRig();
    // Get instance field reference: public UnityEngine.GameObject[] balloons
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::GameObject*>& dyn_balloons();
    // Get instance field reference: public UnityEngine.Color orangeColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_orangeColor();
    // Get instance field reference: public UnityEngine.Color blueColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_blueColor();
    // Get instance field reference: public UnityEngine.Color defaultColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_defaultColor();
    // Get instance field reference: public UnityEngine.Color lastColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_lastColor();
    // Get instance field reference: public UnityEngine.GameObject balloonPopFXPrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_balloonPopFXPrefab();
    // Get instance field reference: public GorillaBattleManager bMgr
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GorillaBattleManager*& dyn_bMgr();
    // Get instance field reference: public Photon.Realtime.Player myPlayer
    [[deprecated("Use field access instead!")]] ::Photon::Realtime::Player*& dyn_myPlayer();
    // Get instance field reference: private System.Int32 colorShaderPropID
    [[deprecated("Use field access instead!")]] int& dyn_colorShaderPropID();
    // Get instance field reference: private UnityEngine.MaterialPropertyBlock matPropBlock
    [[deprecated("Use field access instead!")]] ::UnityEngine::MaterialPropertyBlock*& dyn_matPropBlock();
    // Get instance field reference: private System.Boolean[] balloonsCachedActiveState
    [[deprecated("Use field access instead!")]] ::ArrayW<bool>& dyn_balloonsCachedActiveState();
    // Get instance field reference: private UnityEngine.Renderer[] renderers
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Renderer*>& dyn_renderers();
    // Get instance field reference: private UnityEngine.Color teamColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_teamColor();
    // protected System.Void Awake()
    // Offset: 0x2966C90
    void Awake();
    // protected System.Void OnEnable()
    // Offset: 0x2966E9C
    void OnEnable();
    // protected System.Void LateUpdate()
    // Offset: 0x29670F8
    void LateUpdate();
    // private System.Void PopBalloon(System.Int32 i)
    // Offset: 0x2967378
    void PopBalloon(int i);
    // public System.Void UpdateBalloonColors()
    // Offset: 0x2966EA0
    void UpdateBalloonColors();
    // public System.Void .ctor()
    // Offset: 0x29674C8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static BattleBalloons* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::BattleBalloons::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<BattleBalloons*, creationType>()));
    }
  }; // BattleBalloons
  #pragma pack(pop)
  static check_size<sizeof(BattleBalloons), 168 + sizeof(::UnityEngine::Color)> __GlobalNamespace_BattleBalloonsSizeCheck;
  static_assert(sizeof(BattleBalloons) == 0xB8);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::BattleBalloons::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BattleBalloons::*)()>(&GlobalNamespace::BattleBalloons::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BattleBalloons*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BattleBalloons::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BattleBalloons::*)()>(&GlobalNamespace::BattleBalloons::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BattleBalloons*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BattleBalloons::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BattleBalloons::*)()>(&GlobalNamespace::BattleBalloons::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BattleBalloons*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BattleBalloons::PopBalloon
// Il2CppName: PopBalloon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BattleBalloons::*)(int)>(&GlobalNamespace::BattleBalloons::PopBalloon)> {
  static const MethodInfo* get() {
    static auto* i = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BattleBalloons*), "PopBalloon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{i});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BattleBalloons::UpdateBalloonColors
// Il2CppName: UpdateBalloonColors
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BattleBalloons::*)()>(&GlobalNamespace::BattleBalloons::UpdateBalloonColors)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BattleBalloons*), "UpdateBalloonColors", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BattleBalloons::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
