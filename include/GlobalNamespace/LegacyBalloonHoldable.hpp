// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: LegacyTransferrableObject
#include "GlobalNamespace/LegacyTransferrableObject.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: MeshRenderer
  class MeshRenderer;
  // Forward declaring type: LineRenderer
  class LineRenderer;
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: Collision
  class Collision;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: BalloonDynamics
  class BalloonDynamics;
}
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: LegacyBalloonHoldable
  class LegacyBalloonHoldable;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::LegacyBalloonHoldable);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::LegacyBalloonHoldable*, "", "LegacyBalloonHoldable");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x19C
  #pragma pack(push, 1)
  // Autogenerated type: LegacyBalloonHoldable
  // [TokenAttribute] Offset: FFFFFFFF
  class LegacyBalloonHoldable : public ::GlobalNamespace::LegacyTransferrableObject {
    public:
    // Nested type: ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates
    struct BalloonStates;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: LegacyBalloonHoldable/BalloonStates
    // [TokenAttribute] Offset: FFFFFFFF
    struct BalloonStates/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: BalloonStates
      constexpr BalloonStates(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public LegacyBalloonHoldable/BalloonStates Normal
      static constexpr const int Normal = 0;
      // Get static field: static public LegacyBalloonHoldable/BalloonStates Normal
      static ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates _get_Normal();
      // Set static field: static public LegacyBalloonHoldable/BalloonStates Normal
      static void _set_Normal(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates value);
      // static field const value: static public LegacyBalloonHoldable/BalloonStates Pop
      static constexpr const int Pop = 1;
      // Get static field: static public LegacyBalloonHoldable/BalloonStates Pop
      static ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates _get_Pop();
      // Set static field: static public LegacyBalloonHoldable/BalloonStates Pop
      static void _set_Pop(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates value);
      // static field const value: static public LegacyBalloonHoldable/BalloonStates Waiting
      static constexpr const int Waiting = 2;
      // Get static field: static public LegacyBalloonHoldable/BalloonStates Waiting
      static ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates _get_Waiting();
      // Set static field: static public LegacyBalloonHoldable/BalloonStates Waiting
      static void _set_Waiting(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates value);
      // static field const value: static public LegacyBalloonHoldable/BalloonStates WaitForOwnershipTransfer
      static constexpr const int WaitForOwnershipTransfer = 3;
      // Get static field: static public LegacyBalloonHoldable/BalloonStates WaitForOwnershipTransfer
      static ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates _get_WaitForOwnershipTransfer();
      // Set static field: static public LegacyBalloonHoldable/BalloonStates WaitForOwnershipTransfer
      static void _set_WaitForOwnershipTransfer(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates value);
      // static field const value: static public LegacyBalloonHoldable/BalloonStates WaitForReDock
      static constexpr const int WaitForReDock = 4;
      // Get static field: static public LegacyBalloonHoldable/BalloonStates WaitForReDock
      static ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates _get_WaitForReDock();
      // Set static field: static public LegacyBalloonHoldable/BalloonStates WaitForReDock
      static void _set_WaitForReDock(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates value);
      // static field const value: static public LegacyBalloonHoldable/BalloonStates Refilling
      static constexpr const int Refilling = 5;
      // Get static field: static public LegacyBalloonHoldable/BalloonStates Refilling
      static ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates _get_Refilling();
      // Set static field: static public LegacyBalloonHoldable/BalloonStates Refilling
      static void _set_Refilling(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // LegacyBalloonHoldable/BalloonStates
    #pragma pack(pop)
    static check_size<sizeof(LegacyBalloonHoldable::BalloonStates), 0 + sizeof(int)> __GlobalNamespace_LegacyBalloonHoldable_BalloonStatesSizeCheck;
    static_assert(sizeof(LegacyBalloonHoldable::BalloonStates) == 0x4);
    public:
    // private BalloonDynamics balloonDynamics
    // Size: 0x8
    // Offset: 0x110
    ::GlobalNamespace::BalloonDynamics* balloonDynamics;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::BalloonDynamics*) == 0x8);
    // private UnityEngine.MeshRenderer mesh
    // Size: 0x8
    // Offset: 0x118
    ::UnityEngine::MeshRenderer* mesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::MeshRenderer*) == 0x8);
    // private UnityEngine.LineRenderer lineRenderer
    // Size: 0x8
    // Offset: 0x120
    ::UnityEngine::LineRenderer* lineRenderer;
    // Field size check
    static_assert(sizeof(::UnityEngine::LineRenderer*) == 0x8);
    // private UnityEngine.Rigidbody rb
    // Size: 0x8
    // Offset: 0x128
    ::UnityEngine::Rigidbody* rb;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // private Photon.Realtime.Player originalOwner
    // Size: 0x8
    // Offset: 0x130
    ::Photon::Realtime::Player* originalOwner;
    // Field size check
    static_assert(sizeof(::Photon::Realtime::Player*) == 0x8);
    // public UnityEngine.GameObject balloonPopFXPrefab
    // Size: 0x8
    // Offset: 0x138
    ::UnityEngine::GameObject* balloonPopFXPrefab;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.Color balloonPopFXColor
    // Size: 0x10
    // Offset: 0x140
    ::UnityEngine::Color balloonPopFXColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private System.Single timer
    // Size: 0x4
    // Offset: 0x150
    float timer;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single scaleTimerLength
    // Size: 0x4
    // Offset: 0x154
    float scaleTimerLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single poppedTimerLength
    // Size: 0x4
    // Offset: 0x158
    float poppedTimerLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single beginScale
    // Size: 0x4
    // Offset: 0x15C
    float beginScale;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single bopSpeed
    // Size: 0x4
    // Offset: 0x160
    float bopSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 localScale
    // Size: 0xC
    // Offset: 0x164
    ::UnityEngine::Vector3 localScale;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.AudioSource balloonBopSource
    // Size: 0x8
    // Offset: 0x170
    ::UnityEngine::AudioSource* balloonBopSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // public UnityEngine.AudioSource balloonInflatSource
    // Size: 0x8
    // Offset: 0x178
    ::UnityEngine::AudioSource* balloonInflatSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.Vector3 forceAppliedAsRemote
    // Size: 0xC
    // Offset: 0x180
    ::UnityEngine::Vector3 forceAppliedAsRemote;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 collisionPtAsRemote
    // Size: 0xC
    // Offset: 0x18C
    ::UnityEngine::Vector3 collisionPtAsRemote;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private LegacyBalloonHoldable/BalloonStates balloonState
    // Size: 0x4
    // Offset: 0x198
    ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates balloonState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates) == 0x4);
    public:
    // Get instance field reference: private BalloonDynamics balloonDynamics
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::BalloonDynamics*& dyn_balloonDynamics();
    // Get instance field reference: private UnityEngine.MeshRenderer mesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::MeshRenderer*& dyn_mesh();
    // Get instance field reference: private UnityEngine.LineRenderer lineRenderer
    [[deprecated("Use field access instead!")]] ::UnityEngine::LineRenderer*& dyn_lineRenderer();
    // Get instance field reference: private UnityEngine.Rigidbody rb
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_rb();
    // Get instance field reference: private Photon.Realtime.Player originalOwner
    [[deprecated("Use field access instead!")]] ::Photon::Realtime::Player*& dyn_originalOwner();
    // Get instance field reference: public UnityEngine.GameObject balloonPopFXPrefab
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_balloonPopFXPrefab();
    // Get instance field reference: public UnityEngine.Color balloonPopFXColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_balloonPopFXColor();
    // Get instance field reference: private System.Single timer
    [[deprecated("Use field access instead!")]] float& dyn_timer();
    // Get instance field reference: public System.Single scaleTimerLength
    [[deprecated("Use field access instead!")]] float& dyn_scaleTimerLength();
    // Get instance field reference: public System.Single poppedTimerLength
    [[deprecated("Use field access instead!")]] float& dyn_poppedTimerLength();
    // Get instance field reference: public System.Single beginScale
    [[deprecated("Use field access instead!")]] float& dyn_beginScale();
    // Get instance field reference: public System.Single bopSpeed
    [[deprecated("Use field access instead!")]] float& dyn_bopSpeed();
    // Get instance field reference: private UnityEngine.Vector3 localScale
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_localScale();
    // Get instance field reference: public UnityEngine.AudioSource balloonBopSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_balloonBopSource();
    // Get instance field reference: public UnityEngine.AudioSource balloonInflatSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_balloonInflatSource();
    // Get instance field reference: private UnityEngine.Vector3 forceAppliedAsRemote
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_forceAppliedAsRemote();
    // Get instance field reference: private UnityEngine.Vector3 collisionPtAsRemote
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_collisionPtAsRemote();
    // Get instance field reference: private LegacyBalloonHoldable/BalloonStates balloonState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::LegacyBalloonHoldable::BalloonStates& dyn_balloonState();
    // private System.Boolean ShouldSimulate()
    // Offset: 0x296B14C
    bool ShouldSimulate();
    // private System.Void PlayPopBalloonFX()
    // Offset: 0x296B580
    void PlayPopBalloonFX();
    // private System.Void EnableDynamics(System.Boolean enable, System.Boolean forceKinematicOn)
    // Offset: 0x296AE0C
    void EnableDynamics(bool enable, bool forceKinematicOn);
    // private System.Void PopBalloon()
    // Offset: 0x296B858
    void PopBalloon();
    // public System.Void PopBalloonRemote()
    // Offset: 0x296BB38
    void PopBalloonRemote();
    // public System.Void OnOwnerChangeCb(Photon.Realtime.Player newOwner, Photon.Realtime.Player prevOwner)
    // Offset: 0x296BB44
    void OnOwnerChangeCb(::Photon::Realtime::Player* newOwner, ::Photon::Realtime::Player* prevOwner);
    // private System.Void OwnerPopBalloon()
    // Offset: 0x296B71C
    void OwnerPopBalloon();
    // private System.Void RunLocalPopSM()
    // Offset: 0x296BCAC
    void RunLocalPopSM();
    // private System.Void Grab()
    // Offset: 0x296AFF0
    void Grab();
    // private System.Void Release()
    // Offset: 0x296B0A0
    void Release();
    // public System.Void OnTriggerEnter(UnityEngine.Collider other)
    // Offset: 0x296C184
    void OnTriggerEnter(::UnityEngine::Collider* other);
    // public System.Void OnCollisionEnter(UnityEngine.Collision collision)
    // Offset: 0x296C760
    void OnCollisionEnter(::UnityEngine::Collision* collision);
    // protected override System.Void Awake()
    // Offset: 0x296ACE0
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::Awake()
    void Awake();
    // protected override System.Void Start()
    // Offset: 0x296ADE8
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::Start()
    void Start();
    // public override System.Void OnEnable()
    // Offset: 0x296AF64
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::OnEnable()
    void OnEnable();
    // public override System.Void OnDisable()
    // Offset: 0x296B18C
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::OnDisable()
    void OnDisable();
    // protected override System.Void OnWorldShareableItemSpawn()
    // Offset: 0x296B1C8
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::OnWorldShareableItemSpawn()
    void OnWorldShareableItemSpawn();
    // protected override System.Void OnWorldShareableItemDeallocated(Photon.Realtime.Player player)
    // Offset: 0x296B340
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::OnWorldShareableItemDeallocated(Photon.Realtime.Player player)
    void OnWorldShareableItemDeallocated(::Photon::Realtime::Player* player);
    // protected override System.Void LateUpdateShared()
    // Offset: 0x296BF94
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::LateUpdateShared()
    void LateUpdateShared();
    // protected override System.Void LateUpdateReplicated()
    // Offset: 0x296C17C
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::LateUpdateReplicated()
    void LateUpdateReplicated();
    // public System.Void .ctor()
    // Offset: 0x296C870
    // Implemented from: LegacyTransferrableObject
    // Base method: System.Void LegacyTransferrableObject::.ctor()
    // Base method: System.Void HoldableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static LegacyBalloonHoldable* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::LegacyBalloonHoldable::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<LegacyBalloonHoldable*, creationType>()));
    }
  }; // LegacyBalloonHoldable
  #pragma pack(pop)
  static check_size<sizeof(LegacyBalloonHoldable), 408 + sizeof(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates)> __GlobalNamespace_LegacyBalloonHoldableSizeCheck;
  static_assert(sizeof(LegacyBalloonHoldable) == 0x19C);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::LegacyBalloonHoldable::BalloonStates, "", "LegacyBalloonHoldable/BalloonStates");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::ShouldSimulate
// Il2CppName: ShouldSimulate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::ShouldSimulate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "ShouldSimulate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::PlayPopBalloonFX
// Il2CppName: PlayPopBalloonFX
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::PlayPopBalloonFX)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "PlayPopBalloonFX", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::EnableDynamics
// Il2CppName: EnableDynamics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)(bool, bool)>(&GlobalNamespace::LegacyBalloonHoldable::EnableDynamics)> {
  static const MethodInfo* get() {
    static auto* enable = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* forceKinematicOn = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "EnableDynamics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{enable, forceKinematicOn});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::PopBalloon
// Il2CppName: PopBalloon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::PopBalloon)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "PopBalloon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::PopBalloonRemote
// Il2CppName: PopBalloonRemote
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::PopBalloonRemote)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "PopBalloonRemote", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OnOwnerChangeCb
// Il2CppName: OnOwnerChangeCb
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)(::Photon::Realtime::Player*, ::Photon::Realtime::Player*)>(&GlobalNamespace::LegacyBalloonHoldable::OnOwnerChangeCb)> {
  static const MethodInfo* get() {
    static auto* newOwner = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    static auto* prevOwner = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OnOwnerChangeCb", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{newOwner, prevOwner});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OwnerPopBalloon
// Il2CppName: OwnerPopBalloon
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::OwnerPopBalloon)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OwnerPopBalloon", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::RunLocalPopSM
// Il2CppName: RunLocalPopSM
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::RunLocalPopSM)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "RunLocalPopSM", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::Grab
// Il2CppName: Grab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::Grab)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "Grab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::Release
// Il2CppName: Release
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::Release)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "Release", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OnTriggerEnter
// Il2CppName: OnTriggerEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)(::UnityEngine::Collider*)>(&GlobalNamespace::LegacyBalloonHoldable::OnTriggerEnter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OnTriggerEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OnCollisionEnter
// Il2CppName: OnCollisionEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)(::UnityEngine::Collision*)>(&GlobalNamespace::LegacyBalloonHoldable::OnCollisionEnter)> {
  static const MethodInfo* get() {
    static auto* collision = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collision")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OnCollisionEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{collision});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OnWorldShareableItemSpawn
// Il2CppName: OnWorldShareableItemSpawn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::OnWorldShareableItemSpawn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OnWorldShareableItemSpawn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::OnWorldShareableItemDeallocated
// Il2CppName: OnWorldShareableItemDeallocated
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)(::Photon::Realtime::Player*)>(&GlobalNamespace::LegacyBalloonHoldable::OnWorldShareableItemDeallocated)> {
  static const MethodInfo* get() {
    static auto* player = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "OnWorldShareableItemDeallocated", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{player});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::LateUpdateShared
// Il2CppName: LateUpdateShared
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::LateUpdateShared)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "LateUpdateShared", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::LateUpdateReplicated
// Il2CppName: LateUpdateReplicated
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::LegacyBalloonHoldable::*)()>(&GlobalNamespace::LegacyBalloonHoldable::LateUpdateReplicated)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::LegacyBalloonHoldable*), "LateUpdateReplicated", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::LegacyBalloonHoldable::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
