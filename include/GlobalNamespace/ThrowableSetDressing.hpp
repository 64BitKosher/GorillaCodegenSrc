// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: TransferrableObject
#include "GlobalNamespace/TransferrableObject.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: MagicIngredientType
  class MagicIngredientType;
  // Forward declaring type: InteractionPoint
  class InteractionPoint;
  // Forward declaring type: DropZone
  class DropZone;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: CapsuleCollider
  class CapsuleCollider;
  // Forward declaring type: Coroutine
  class Coroutine;
  // Forward declaring type: GameObject
  class GameObject;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: ThrowableSetDressing
  class ThrowableSetDressing;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::ThrowableSetDressing);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::ThrowableSetDressing*, "", "ThrowableSetDressing");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: ThrowableSetDressing
  // [TokenAttribute] Offset: FFFFFFFF
  class ThrowableSetDressing : public ::GlobalNamespace::TransferrableObject {
    public:
    // Nested type: ::GlobalNamespace::ThrowableSetDressing::$RespawnTimerCoroutine$d__19
    class $RespawnTimerCoroutine$d__19;
    public:
    // public System.Single respawnTimerDuration
    // Size: 0x4
    // Offset: 0x2CC
    float respawnTimerDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean <inInitialPose>k__BackingField
    // Size: 0x1
    // Offset: 0x2D0
    bool inInitialPose;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public MagicIngredientType IngredientTypeSO
    // Size: 0x8
    // Offset: 0x2D8
    ::GlobalNamespace::MagicIngredientType* IngredientTypeSO;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::MagicIngredientType*) == 0x8);
    // private System.Single _respawnTimestamp
    // Size: 0x4
    // Offset: 0x2E0
    float respawnTimestamp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.CapsuleCollider capsuleCollider
    // Size: 0x8
    // Offset: 0x2E8
    ::UnityEngine::CapsuleCollider* capsuleCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::CapsuleCollider*) == 0x8);
    // private UnityEngine.Vector3 respawnAtPos
    // Size: 0xC
    // Offset: 0x2F0
    ::UnityEngine::Vector3 respawnAtPos;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion respawnAtRot
    // Size: 0x10
    // Offset: 0x2FC
    ::UnityEngine::Quaternion respawnAtRot;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Coroutine respawnTimer
    // Size: 0x8
    // Offset: 0x310
    ::UnityEngine::Coroutine* respawnTimer;
    // Field size check
    static_assert(sizeof(::UnityEngine::Coroutine*) == 0x8);
    public:
    // Get instance field reference: public System.Single respawnTimerDuration
    [[deprecated("Use field access instead!")]] float& dyn_respawnTimerDuration();
    // Get instance field reference: private System.Boolean <inInitialPose>k__BackingField
    [[deprecated("Use field access instead!")]] bool& dyn_$inInitialPose$k__BackingField();
    // Get instance field reference: public MagicIngredientType IngredientTypeSO
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::MagicIngredientType*& dyn_IngredientTypeSO();
    // Get instance field reference: private System.Single _respawnTimestamp
    [[deprecated("Use field access instead!")]] float& dyn__respawnTimestamp();
    // Get instance field reference: private UnityEngine.CapsuleCollider capsuleCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::CapsuleCollider*& dyn_capsuleCollider();
    // Get instance field reference: private UnityEngine.Vector3 respawnAtPos
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_respawnAtPos();
    // Get instance field reference: private UnityEngine.Quaternion respawnAtRot
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_respawnAtRot();
    // Get instance field reference: private UnityEngine.Coroutine respawnTimer
    [[deprecated("Use field access instead!")]] ::UnityEngine::Coroutine*& dyn_respawnTimer();
    // public System.Boolean get_inInitialPose()
    // Offset: 0x27A56C4
    bool get_inInitialPose();
    // private System.Void set_inInitialPose(System.Boolean value)
    // Offset: 0x27A56CC
    void set_inInitialPose(bool value);
    // private System.Void StopRespawnTimer()
    // Offset: 0x27A5780
    void StopRespawnTimer();
    // public System.Void SetWillTeleport()
    // Offset: 0x27A5918
    void SetWillTeleport();
    // public System.Void StartRespawnTimer(System.Single overrideTimer)
    // Offset: 0x27A57FC
    void StartRespawnTimer(float overrideTimer);
    // private System.Collections.IEnumerator RespawnTimerCoroutine(System.Single timerDuration)
    // Offset: 0x27A5934
    ::System::Collections::IEnumerator* RespawnTimerCoroutine(float timerDuration);
    // public override System.Boolean ShouldBeKinematic()
    // Offset: 0x27A56D8
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::ShouldBeKinematic()
    bool ShouldBeKinematic();
    // protected override System.Void Start()
    // Offset: 0x27A56F0
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::Start()
    void Start();
    // public override System.Void OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    // Offset: 0x27A5760
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    void OnGrab(::GlobalNamespace::InteractionPoint* pointGrabbed, ::UnityEngine::GameObject* grabbingHand);
    // public override System.Boolean OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    // Offset: 0x27A57C4
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    bool OnRelease(::GlobalNamespace::DropZone* zoneReleased, ::UnityEngine::GameObject* releasingHand);
    // public override System.Void DropItem()
    // Offset: 0x27A58F8
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::DropItem()
    void DropItem();
    // public System.Void .ctor()
    // Offset: 0x27A59D8
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::.ctor()
    // Base method: System.Void HoldableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static ThrowableSetDressing* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::ThrowableSetDressing::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<ThrowableSetDressing*, creationType>()));
    }
  }; // ThrowableSetDressing
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::get_inInitialPose
// Il2CppName: get_inInitialPose
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::ThrowableSetDressing::*)()>(&GlobalNamespace::ThrowableSetDressing::get_inInitialPose)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "get_inInitialPose", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::set_inInitialPose
// Il2CppName: set_inInitialPose
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ThrowableSetDressing::*)(bool)>(&GlobalNamespace::ThrowableSetDressing::set_inInitialPose)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "set_inInitialPose", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::StopRespawnTimer
// Il2CppName: StopRespawnTimer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ThrowableSetDressing::*)()>(&GlobalNamespace::ThrowableSetDressing::StopRespawnTimer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "StopRespawnTimer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::SetWillTeleport
// Il2CppName: SetWillTeleport
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ThrowableSetDressing::*)()>(&GlobalNamespace::ThrowableSetDressing::SetWillTeleport)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "SetWillTeleport", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::StartRespawnTimer
// Il2CppName: StartRespawnTimer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ThrowableSetDressing::*)(float)>(&GlobalNamespace::ThrowableSetDressing::StartRespawnTimer)> {
  static const MethodInfo* get() {
    static auto* overrideTimer = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "StartRespawnTimer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{overrideTimer});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::RespawnTimerCoroutine
// Il2CppName: RespawnTimerCoroutine
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::ThrowableSetDressing::*)(float)>(&GlobalNamespace::ThrowableSetDressing::RespawnTimerCoroutine)> {
  static const MethodInfo* get() {
    static auto* timerDuration = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "RespawnTimerCoroutine", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{timerDuration});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::ShouldBeKinematic
// Il2CppName: ShouldBeKinematic
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::ThrowableSetDressing::*)()>(&GlobalNamespace::ThrowableSetDressing::ShouldBeKinematic)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "ShouldBeKinematic", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ThrowableSetDressing::*)()>(&GlobalNamespace::ThrowableSetDressing::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::OnGrab
// Il2CppName: OnGrab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ThrowableSetDressing::*)(::GlobalNamespace::InteractionPoint*, ::UnityEngine::GameObject*)>(&GlobalNamespace::ThrowableSetDressing::OnGrab)> {
  static const MethodInfo* get() {
    static auto* pointGrabbed = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    static auto* grabbingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "OnGrab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointGrabbed, grabbingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::OnRelease
// Il2CppName: OnRelease
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::ThrowableSetDressing::*)(::GlobalNamespace::DropZone*, ::UnityEngine::GameObject*)>(&GlobalNamespace::ThrowableSetDressing::OnRelease)> {
  static const MethodInfo* get() {
    static auto* zoneReleased = &::il2cpp_utils::GetClassFromName("", "DropZone")->byval_arg;
    static auto* releasingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "OnRelease", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{zoneReleased, releasingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::DropItem
// Il2CppName: DropItem
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ThrowableSetDressing::*)()>(&GlobalNamespace::ThrowableSetDressing::DropItem)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ThrowableSetDressing*), "DropItem", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ThrowableSetDressing::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
