// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: TransferrableObject
#include "GlobalNamespace/TransferrableObject.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GorillaTag
namespace GorillaTag {
  // Forward declaring type: IResettableItem
  class IResettableItem;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: InteractionPoint
  class InteractionPoint;
  // Forward declaring type: DropZone
  class DropZone;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: AudioClip
  class AudioClip;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: AudioSource
  class AudioSource;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: EdibleHoldable
  class EdibleHoldable;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::EdibleHoldable);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::EdibleHoldable*, "", "EdibleHoldable");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: EdibleHoldable
  // [TokenAttribute] Offset: FFFFFFFF
  class EdibleHoldable : public ::GlobalNamespace::TransferrableObject {
    public:
    // Nested type: ::GlobalNamespace::EdibleHoldable::EdibleHoldableStates
    struct EdibleHoldableStates;
    // Nested type: ::GlobalNamespace::EdibleHoldable::BiteEvent
    class BiteEvent;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: EdibleHoldable/EdibleHoldableStates
    // [TokenAttribute] Offset: FFFFFFFF
    struct EdibleHoldableStates/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: EdibleHoldableStates
      constexpr EdibleHoldableStates(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public EdibleHoldable/EdibleHoldableStates EatingState0
      static constexpr const int EatingState0 = 1;
      // Get static field: static public EdibleHoldable/EdibleHoldableStates EatingState0
      static ::GlobalNamespace::EdibleHoldable::EdibleHoldableStates _get_EatingState0();
      // Set static field: static public EdibleHoldable/EdibleHoldableStates EatingState0
      static void _set_EatingState0(::GlobalNamespace::EdibleHoldable::EdibleHoldableStates value);
      // static field const value: static public EdibleHoldable/EdibleHoldableStates EatingState1
      static constexpr const int EatingState1 = 2;
      // Get static field: static public EdibleHoldable/EdibleHoldableStates EatingState1
      static ::GlobalNamespace::EdibleHoldable::EdibleHoldableStates _get_EatingState1();
      // Set static field: static public EdibleHoldable/EdibleHoldableStates EatingState1
      static void _set_EatingState1(::GlobalNamespace::EdibleHoldable::EdibleHoldableStates value);
      // static field const value: static public EdibleHoldable/EdibleHoldableStates EatingState2
      static constexpr const int EatingState2 = 4;
      // Get static field: static public EdibleHoldable/EdibleHoldableStates EatingState2
      static ::GlobalNamespace::EdibleHoldable::EdibleHoldableStates _get_EatingState2();
      // Set static field: static public EdibleHoldable/EdibleHoldableStates EatingState2
      static void _set_EatingState2(::GlobalNamespace::EdibleHoldable::EdibleHoldableStates value);
      // static field const value: static public EdibleHoldable/EdibleHoldableStates EatingState3
      static constexpr const int EatingState3 = 8;
      // Get static field: static public EdibleHoldable/EdibleHoldableStates EatingState3
      static ::GlobalNamespace::EdibleHoldable::EdibleHoldableStates _get_EatingState3();
      // Set static field: static public EdibleHoldable/EdibleHoldableStates EatingState3
      static void _set_EatingState3(::GlobalNamespace::EdibleHoldable::EdibleHoldableStates value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // EdibleHoldable/EdibleHoldableStates
    #pragma pack(pop)
    static check_size<sizeof(EdibleHoldable::EdibleHoldableStates), 0 + sizeof(int)> __GlobalNamespace_EdibleHoldable_EdibleHoldableStatesSizeCheck;
    static_assert(sizeof(EdibleHoldable::EdibleHoldableStates) == 0x4);
    public:
    // public UnityEngine.AudioClip[] eatSounds
    // Size: 0x8
    // Offset: 0x2D0
    ::ArrayW<::UnityEngine::AudioClip*> eatSounds;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::AudioClip*>) == 0x8);
    // public UnityEngine.GameObject[] edibleMeshObjects
    // Size: 0x8
    // Offset: 0x2D8
    ::ArrayW<::UnityEngine::GameObject*> edibleMeshObjects;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::GameObject*>) == 0x8);
    // public EdibleHoldable/BiteEvent onBiteView
    // Size: 0x8
    // Offset: 0x2E0
    ::GlobalNamespace::EdibleHoldable::BiteEvent* onBiteView;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::EdibleHoldable::BiteEvent*) == 0x8);
    // public EdibleHoldable/BiteEvent onBiteWorld
    // Size: 0x8
    // Offset: 0x2E8
    ::GlobalNamespace::EdibleHoldable::BiteEvent* onBiteWorld;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::EdibleHoldable::BiteEvent*) == 0x8);
    // public System.Single lastEatTime
    // Size: 0x4
    // Offset: 0x2F0
    float lastEatTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single lastFullyEatenTime
    // Size: 0x4
    // Offset: 0x2F4
    float lastFullyEatenTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single eatMinimumCooldown
    // Size: 0x4
    // Offset: 0x2F8
    float eatMinimumCooldown;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single respawnTime
    // Size: 0x4
    // Offset: 0x2FC
    float respawnTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single biteDistance
    // Size: 0x4
    // Offset: 0x300
    float biteDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Vector3 biteOffset
    // Size: 0xC
    // Offset: 0x304
    ::UnityEngine::Vector3 biteOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Transform biteSpot
    // Size: 0x8
    // Offset: 0x310
    ::UnityEngine::Transform* biteSpot;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.Boolean inBiteZone
    // Size: 0x1
    // Offset: 0x318
    bool inBiteZone;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public UnityEngine.AudioSource eatSoundSource
    // Size: 0x8
    // Offset: 0x320
    ::UnityEngine::AudioSource* eatSoundSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private EdibleHoldable/EdibleHoldableStates previousEdibleState
    // Size: 0x4
    // Offset: 0x328
    ::GlobalNamespace::EdibleHoldable::EdibleHoldableStates previousEdibleState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::EdibleHoldable::EdibleHoldableStates) == 0x4);
    // private GorillaTag.IResettableItem[] iResettableItems
    // Size: 0x8
    // Offset: 0x330
    ::ArrayW<::GorillaTag::IResettableItem*> iResettableItems;
    // Field size check
    static_assert(sizeof(::ArrayW<::GorillaTag::IResettableItem*>) == 0x8);
    public:
    // Get instance field reference: public UnityEngine.AudioClip[] eatSounds
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::AudioClip*>& dyn_eatSounds();
    // Get instance field reference: public UnityEngine.GameObject[] edibleMeshObjects
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::GameObject*>& dyn_edibleMeshObjects();
    // Get instance field reference: public EdibleHoldable/BiteEvent onBiteView
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::EdibleHoldable::BiteEvent*& dyn_onBiteView();
    // Get instance field reference: public EdibleHoldable/BiteEvent onBiteWorld
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::EdibleHoldable::BiteEvent*& dyn_onBiteWorld();
    // Get instance field reference: public System.Single lastEatTime
    [[deprecated("Use field access instead!")]] float& dyn_lastEatTime();
    // Get instance field reference: public System.Single lastFullyEatenTime
    [[deprecated("Use field access instead!")]] float& dyn_lastFullyEatenTime();
    // Get instance field reference: public System.Single eatMinimumCooldown
    [[deprecated("Use field access instead!")]] float& dyn_eatMinimumCooldown();
    // Get instance field reference: public System.Single respawnTime
    [[deprecated("Use field access instead!")]] float& dyn_respawnTime();
    // Get instance field reference: public System.Single biteDistance
    [[deprecated("Use field access instead!")]] float& dyn_biteDistance();
    // Get instance field reference: public UnityEngine.Vector3 biteOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_biteOffset();
    // Get instance field reference: public UnityEngine.Transform biteSpot
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_biteSpot();
    // Get instance field reference: public System.Boolean inBiteZone
    [[deprecated("Use field access instead!")]] bool& dyn_inBiteZone();
    // Get instance field reference: public UnityEngine.AudioSource eatSoundSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_eatSoundSource();
    // Get instance field reference: private EdibleHoldable/EdibleHoldableStates previousEdibleState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::EdibleHoldable::EdibleHoldableStates& dyn_previousEdibleState();
    // Get instance field reference: private GorillaTag.IResettableItem[] iResettableItems
    [[deprecated("Use field access instead!")]] ::ArrayW<::GorillaTag::IResettableItem*>& dyn_iResettableItems();
    // protected System.Void OnEdibleHoldableStateChange()
    // Offset: 0x26B321C
    void OnEdibleHoldableStateChange();
    // protected override System.Void Start()
    // Offset: 0x26B2C80
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::Start()
    void Start();
    // public override System.Void OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    // Offset: 0x26B2D00
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    void OnGrab(::GlobalNamespace::InteractionPoint* pointGrabbed, ::UnityEngine::GameObject* grabbingHand);
    // public override System.Void OnActivate()
    // Offset: 0x26B2D2C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnActivate()
    void OnActivate();
    // public override System.Void OnEnable()
    // Offset: 0x26B2D34
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnEnable()
    void OnEnable();
    // public override System.Void OnDisable()
    // Offset: 0x26B2D3C
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::OnDisable()
    void OnDisable();
    // public override System.Void ResetToDefaultState()
    // Offset: 0x26B2D44
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::ResetToDefaultState()
    void ResetToDefaultState();
    // public override System.Boolean OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    // Offset: 0x26B2D4C
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    bool OnRelease(::GlobalNamespace::DropZone* zoneReleased, ::UnityEngine::GameObject* releasingHand);
    // protected override System.Void LateUpdateLocal()
    // Offset: 0x26B2D88
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateLocal()
    void LateUpdateLocal();
    // protected override System.Void LateUpdateShared()
    // Offset: 0x26B31D4
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::LateUpdateShared()
    void LateUpdateShared();
    // public override System.Boolean CanActivate()
    // Offset: 0x26B3784
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::CanActivate()
    bool CanActivate();
    // public override System.Boolean CanDeactivate()
    // Offset: 0x26B378C
    // Implemented from: TransferrableObject
    // Base method: System.Boolean TransferrableObject::CanDeactivate()
    bool CanDeactivate();
    // public System.Void .ctor()
    // Offset: 0x26B3794
    // Implemented from: TransferrableObject
    // Base method: System.Void TransferrableObject::.ctor()
    // Base method: System.Void HoldableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static EdibleHoldable* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::EdibleHoldable::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<EdibleHoldable*, creationType>()));
    }
  }; // EdibleHoldable
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::EdibleHoldable::EdibleHoldableStates, "", "EdibleHoldable/EdibleHoldableStates");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::OnEdibleHoldableStateChange
// Il2CppName: OnEdibleHoldableStateChange
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::OnEdibleHoldableStateChange)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "OnEdibleHoldableStateChange", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::OnGrab
// Il2CppName: OnGrab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)(::GlobalNamespace::InteractionPoint*, ::UnityEngine::GameObject*)>(&GlobalNamespace::EdibleHoldable::OnGrab)> {
  static const MethodInfo* get() {
    static auto* pointGrabbed = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    static auto* grabbingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "OnGrab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointGrabbed, grabbingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::OnActivate
// Il2CppName: OnActivate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::OnActivate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "OnActivate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::ResetToDefaultState
// Il2CppName: ResetToDefaultState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::ResetToDefaultState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "ResetToDefaultState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::OnRelease
// Il2CppName: OnRelease
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::EdibleHoldable::*)(::GlobalNamespace::DropZone*, ::UnityEngine::GameObject*)>(&GlobalNamespace::EdibleHoldable::OnRelease)> {
  static const MethodInfo* get() {
    static auto* zoneReleased = &::il2cpp_utils::GetClassFromName("", "DropZone")->byval_arg;
    static auto* releasingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "OnRelease", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{zoneReleased, releasingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::LateUpdateLocal
// Il2CppName: LateUpdateLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::LateUpdateLocal)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "LateUpdateLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::LateUpdateShared
// Il2CppName: LateUpdateShared
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::LateUpdateShared)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "LateUpdateShared", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::CanActivate
// Il2CppName: CanActivate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::CanActivate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "CanActivate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::CanDeactivate
// Il2CppName: CanDeactivate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::EdibleHoldable::*)()>(&GlobalNamespace::EdibleHoldable::CanDeactivate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::EdibleHoldable*), "CanDeactivate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::EdibleHoldable::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
