// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: OVROverlay/OverlayType
#include "GlobalNamespace/OVROverlay.hpp"
// Including type: UnityEngine.Vector4
#include "UnityEngine/Vector4.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: OVRPlugin/InsightPassthroughColorMapType
#include "GlobalNamespace/OVRPlugin_InsightPassthroughColorMapType.hpp"
// Including type: UnityEngine.Matrix4x4
#include "UnityEngine/Matrix4x4.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Texture2D
  class Texture2D;
  // Forward declaring type: Gradient
  class Gradient;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: MeshFilter
  class MeshFilter;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: OVRCameraRig
  class OVRCameraRig;
  // Forward declaring type: OVRPassthroughColorLut
  class OVRPassthroughColorLut;
  // Skipping declaration: ColorMapEditorType because it is already included!
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: OVRPassthroughLayer
  class OVRPassthroughLayer;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::OVRPassthroughLayer);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer*, "", "OVRPassthroughLayer");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x118
  #pragma pack(push, 1)
  // Autogenerated type: OVRPassthroughLayer
  // [TokenAttribute] Offset: FFFFFFFF
  // [HelpURLAttribute] Offset: FFFFFFFF
  class OVRPassthroughLayer : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType
    struct ProjectionSurfaceType;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType
    struct ColorMapEditorType;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::Settings
    struct Settings;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance
    struct PassthroughMeshInstance;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::SerializedSurfaceGeometry
    struct SerializedSurfaceGeometry;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition
    struct DeferredPassthroughMeshAddition;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::IStyleHandler
    class IStyleHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::StylesHandler
    class StylesHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::NoneStyleHandler
    class NoneStyleHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::BaseGeneratedStyleHandler
    class BaseGeneratedStyleHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::MonoToRgbaStyleHandler
    class MonoToRgbaStyleHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::MonoToMonoStyleHandler
    class MonoToMonoStyleHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::BCSStyleHandler
    class BCSStyleHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::ColorLutHandler
    class ColorLutHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::InterpolatedColorLutHandler
    class InterpolatedColorLutHandler;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::$$c__DisplayClass10_0
    class $$c__DisplayClass10_0;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::$$c__DisplayClass9_0
    class $$c__DisplayClass9_0;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: OVRPassthroughLayer/ProjectionSurfaceType
    // [TokenAttribute] Offset: FFFFFFFF
    struct ProjectionSurfaceType/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: ProjectionSurfaceType
      constexpr ProjectionSurfaceType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public OVRPassthroughLayer/ProjectionSurfaceType Reconstructed
      static constexpr const int Reconstructed = 0;
      // Get static field: static public OVRPassthroughLayer/ProjectionSurfaceType Reconstructed
      static ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType _get_Reconstructed();
      // Set static field: static public OVRPassthroughLayer/ProjectionSurfaceType Reconstructed
      static void _set_Reconstructed(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType value);
      // static field const value: static public OVRPassthroughLayer/ProjectionSurfaceType UserDefined
      static constexpr const int UserDefined = 1;
      // Get static field: static public OVRPassthroughLayer/ProjectionSurfaceType UserDefined
      static ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType _get_UserDefined();
      // Set static field: static public OVRPassthroughLayer/ProjectionSurfaceType UserDefined
      static void _set_UserDefined(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // OVRPassthroughLayer/ProjectionSurfaceType
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::ProjectionSurfaceType), 0 + sizeof(int)> __GlobalNamespace_OVRPassthroughLayer_ProjectionSurfaceTypeSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::ProjectionSurfaceType) == 0x4);
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: OVRPassthroughLayer/ColorMapEditorType
    // [TokenAttribute] Offset: FFFFFFFF
    struct ColorMapEditorType/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: ColorMapEditorType
      constexpr ColorMapEditorType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType None
      static constexpr const int None = 0;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType None
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_None();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType None
      static void _set_None(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType GrayscaleToColor
      static constexpr const int GrayscaleToColor = 1;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType GrayscaleToColor
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_GrayscaleToColor();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType GrayscaleToColor
      static void _set_GrayscaleToColor(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType Controls
      static constexpr const int Controls = 1;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType Controls
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_Controls();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType Controls
      static void _set_Controls(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType Custom
      static constexpr const int Custom = 2;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType Custom
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_Custom();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType Custom
      static void _set_Custom(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType Grayscale
      static constexpr const int Grayscale = 3;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType Grayscale
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_Grayscale();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType Grayscale
      static void _set_Grayscale(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType ColorAdjustment
      static constexpr const int ColorAdjustment = 4;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType ColorAdjustment
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_ColorAdjustment();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType ColorAdjustment
      static void _set_ColorAdjustment(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType ColorLut
      static constexpr const int ColorLut = 5;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType ColorLut
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_ColorLut();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType ColorLut
      static void _set_ColorLut(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType InterpolatedColorLut
      static constexpr const int InterpolatedColorLut = 6;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType InterpolatedColorLut
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_InterpolatedColorLut();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType InterpolatedColorLut
      static void _set_InterpolatedColorLut(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // OVRPassthroughLayer/ColorMapEditorType
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::ColorMapEditorType), 0 + sizeof(int)> __GlobalNamespace_OVRPassthroughLayer_ColorMapEditorTypeSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::ColorMapEditorType) == 0x4);
    // Size: 0x2D
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: OVRPassthroughLayer/Settings
    // [TokenAttribute] Offset: FFFFFFFF
    struct Settings/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.Texture2D colorLutTargetTexture
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::Texture2D* colorLutTargetTexture;
      // Field size check
      static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
      // public UnityEngine.Texture2D colorLutSourceTexture
      // Size: 0x8
      // Offset: 0x8
      ::UnityEngine::Texture2D* colorLutSourceTexture;
      // Field size check
      static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
      // public System.Single saturation
      // Size: 0x4
      // Offset: 0x10
      float saturation;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single posterize
      // Size: 0x4
      // Offset: 0x14
      float posterize;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single brightness
      // Size: 0x4
      // Offset: 0x18
      float brightness;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Single contrast
      // Size: 0x4
      // Offset: 0x1C
      float contrast;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public UnityEngine.Gradient gradient
      // Size: 0x8
      // Offset: 0x20
      ::UnityEngine::Gradient* gradient;
      // Field size check
      static_assert(sizeof(::UnityEngine::Gradient*) == 0x8);
      // public System.Single lutWeight
      // Size: 0x4
      // Offset: 0x28
      float lutWeight;
      // Field size check
      static_assert(sizeof(float) == 0x4);
      // public System.Boolean flipLutY
      // Size: 0x1
      // Offset: 0x2C
      bool flipLutY;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: Settings
      constexpr Settings(::UnityEngine::Texture2D* colorLutTargetTexture_ = {}, ::UnityEngine::Texture2D* colorLutSourceTexture_ = {}, float saturation_ = {}, float posterize_ = {}, float brightness_ = {}, float contrast_ = {}, ::UnityEngine::Gradient* gradient_ = {}, float lutWeight_ = {}, bool flipLutY_ = {}) noexcept : colorLutTargetTexture{colorLutTargetTexture_}, colorLutSourceTexture{colorLutSourceTexture_}, saturation{saturation_}, posterize{posterize_}, brightness{brightness_}, contrast{contrast_}, gradient{gradient_}, lutWeight{lutWeight_}, flipLutY{flipLutY_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.Texture2D colorLutTargetTexture
      [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn_colorLutTargetTexture();
      // Get instance field reference: public UnityEngine.Texture2D colorLutSourceTexture
      [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn_colorLutSourceTexture();
      // Get instance field reference: public System.Single saturation
      [[deprecated("Use field access instead!")]] float& dyn_saturation();
      // Get instance field reference: public System.Single posterize
      [[deprecated("Use field access instead!")]] float& dyn_posterize();
      // Get instance field reference: public System.Single brightness
      [[deprecated("Use field access instead!")]] float& dyn_brightness();
      // Get instance field reference: public System.Single contrast
      [[deprecated("Use field access instead!")]] float& dyn_contrast();
      // Get instance field reference: public UnityEngine.Gradient gradient
      [[deprecated("Use field access instead!")]] ::UnityEngine::Gradient*& dyn_gradient();
      // Get instance field reference: public System.Single lutWeight
      [[deprecated("Use field access instead!")]] float& dyn_lutWeight();
      // Get instance field reference: public System.Boolean flipLutY
      [[deprecated("Use field access instead!")]] bool& dyn_flipLutY();
      // public System.Void .ctor(UnityEngine.Texture2D colorLutTargetTexture, UnityEngine.Texture2D colorLutSourceTexture, System.Single saturation, System.Single posterize, System.Single brightness, System.Single contrast, UnityEngine.Gradient gradient, System.Single lutWeight, System.Boolean flipLutY)
      // Offset: 0x48EB864
      // ABORTED: conflicts with another method.  Settings(::UnityEngine::Texture2D* colorLutTargetTexture, ::UnityEngine::Texture2D* colorLutSourceTexture, float saturation, float posterize, float brightness, float contrast, ::UnityEngine::Gradient* gradient, float lutWeight, bool flipLutY);
    }; // OVRPassthroughLayer/Settings
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::Settings), 44 + sizeof(bool)> __GlobalNamespace_OVRPassthroughLayer_SettingsSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::Settings) == 0x2D);
    // Size: 0x54
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: OVRPassthroughLayer/PassthroughMeshInstance
    // [TokenAttribute] Offset: FFFFFFFF
    struct PassthroughMeshInstance/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.UInt64 meshHandle
      // Size: 0x8
      // Offset: 0x0
      uint64_t meshHandle;
      // Field size check
      static_assert(sizeof(uint64_t) == 0x8);
      // public System.UInt64 instanceHandle
      // Size: 0x8
      // Offset: 0x8
      uint64_t instanceHandle;
      // Field size check
      static_assert(sizeof(uint64_t) == 0x8);
      // public System.Boolean updateTransform
      // Size: 0x1
      // Offset: 0x10
      bool updateTransform;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // Padding between fields: updateTransform and: localToWorld
      char __padding2[0x3] = {};
      // public UnityEngine.Matrix4x4 localToWorld
      // Size: 0x40
      // Offset: 0x14
      ::UnityEngine::Matrix4x4 localToWorld;
      // Field size check
      static_assert(sizeof(::UnityEngine::Matrix4x4) == 0x40);
      public:
      // Creating value type constructor for type: PassthroughMeshInstance
      constexpr PassthroughMeshInstance(uint64_t meshHandle_ = {}, uint64_t instanceHandle_ = {}, bool updateTransform_ = {}, ::UnityEngine::Matrix4x4 localToWorld_ = {}) noexcept : meshHandle{meshHandle_}, instanceHandle{instanceHandle_}, updateTransform{updateTransform_}, localToWorld{localToWorld_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.UInt64 meshHandle
      [[deprecated("Use field access instead!")]] uint64_t& dyn_meshHandle();
      // Get instance field reference: public System.UInt64 instanceHandle
      [[deprecated("Use field access instead!")]] uint64_t& dyn_instanceHandle();
      // Get instance field reference: public System.Boolean updateTransform
      [[deprecated("Use field access instead!")]] bool& dyn_updateTransform();
      // Get instance field reference: public UnityEngine.Matrix4x4 localToWorld
      [[deprecated("Use field access instead!")]] ::UnityEngine::Matrix4x4& dyn_localToWorld();
    }; // OVRPassthroughLayer/PassthroughMeshInstance
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::PassthroughMeshInstance), 20 + sizeof(::UnityEngine::Matrix4x4)> __GlobalNamespace_OVRPassthroughLayer_PassthroughMeshInstanceSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::PassthroughMeshInstance) == 0x54);
    // Size: 0x9
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: OVRPassthroughLayer/SerializedSurfaceGeometry
    // [TokenAttribute] Offset: FFFFFFFF
    struct SerializedSurfaceGeometry/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.MeshFilter meshFilter
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::MeshFilter* meshFilter;
      // Field size check
      static_assert(sizeof(::UnityEngine::MeshFilter*) == 0x8);
      // public System.Boolean updateTransform
      // Size: 0x1
      // Offset: 0x8
      bool updateTransform;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: SerializedSurfaceGeometry
      constexpr SerializedSurfaceGeometry(::UnityEngine::MeshFilter* meshFilter_ = {}, bool updateTransform_ = {}) noexcept : meshFilter{meshFilter_}, updateTransform{updateTransform_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.MeshFilter meshFilter
      [[deprecated("Use field access instead!")]] ::UnityEngine::MeshFilter*& dyn_meshFilter();
      // Get instance field reference: public System.Boolean updateTransform
      [[deprecated("Use field access instead!")]] bool& dyn_updateTransform();
    }; // OVRPassthroughLayer/SerializedSurfaceGeometry
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::SerializedSurfaceGeometry), 8 + sizeof(bool)> __GlobalNamespace_OVRPassthroughLayer_SerializedSurfaceGeometrySizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::SerializedSurfaceGeometry) == 0x9);
    // Size: 0x9
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: OVRPassthroughLayer/DeferredPassthroughMeshAddition
    // [TokenAttribute] Offset: FFFFFFFF
    struct DeferredPassthroughMeshAddition/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.GameObject gameObject
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::GameObject* gameObject;
      // Field size check
      static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
      // public System.Boolean updateTransform
      // Size: 0x1
      // Offset: 0x8
      bool updateTransform;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: DeferredPassthroughMeshAddition
      constexpr DeferredPassthroughMeshAddition(::UnityEngine::GameObject* gameObject_ = {}, bool updateTransform_ = {}) noexcept : gameObject{gameObject_}, updateTransform{updateTransform_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.GameObject gameObject
      [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_gameObject();
      // Get instance field reference: public System.Boolean updateTransform
      [[deprecated("Use field access instead!")]] bool& dyn_updateTransform();
    }; // OVRPassthroughLayer/DeferredPassthroughMeshAddition
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::DeferredPassthroughMeshAddition), 8 + sizeof(bool)> __GlobalNamespace_OVRPassthroughLayer_DeferredPassthroughMeshAdditionSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::DeferredPassthroughMeshAddition) == 0x9);
    public:
    // public OVRPassthroughLayer/ProjectionSurfaceType projectionSurfaceType
    // Size: 0x4
    // Offset: 0x20
    ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType projectionSurfaceType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType) == 0x4);
    // public OVROverlay/OverlayType overlayType
    // Size: 0x4
    // Offset: 0x24
    ::GlobalNamespace::OVROverlay::OverlayType overlayType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay::OverlayType) == 0x4);
    // public System.Int32 compositionDepth
    // Size: 0x4
    // Offset: 0x28
    int compositionDepth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean hidden
    // Size: 0x1
    // Offset: 0x2C
    bool hidden;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean overridePerLayerColorScaleAndOffset
    // Size: 0x1
    // Offset: 0x2D
    bool overridePerLayerColorScaleAndOffset;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overridePerLayerColorScaleAndOffset and: colorScale
    char __padding4[0x2] = {};
    // public UnityEngine.Vector4 colorScale
    // Size: 0x10
    // Offset: 0x30
    ::UnityEngine::Vector4 colorScale;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
    // public UnityEngine.Vector4 colorOffset
    // Size: 0x10
    // Offset: 0x40
    ::UnityEngine::Vector4 colorOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
    // OVRPassthroughLayer/ColorMapEditorType colorMapEditorType_
    // Size: 0x4
    // Offset: 0x50
    ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType colorMapEditorType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType) == 0x4);
    // Padding between fields: colorMapEditorType and: colorMapEditorGradient
    char __padding7[0x4] = {};
    // public UnityEngine.Gradient colorMapEditorGradient
    // Size: 0x8
    // Offset: 0x58
    ::UnityEngine::Gradient* colorMapEditorGradient;
    // Field size check
    static_assert(sizeof(::UnityEngine::Gradient*) == 0x8);
    // public System.Single colorMapEditorContrast
    // Size: 0x4
    // Offset: 0x60
    float colorMapEditorContrast;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single colorMapEditorBrightness
    // Size: 0x4
    // Offset: 0x64
    float colorMapEditorBrightness;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single colorMapEditorPosterize
    // Size: 0x4
    // Offset: 0x68
    float colorMapEditorPosterize;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single colorMapEditorSaturation
    // Size: 0x4
    // Offset: 0x6C
    float colorMapEditorSaturation;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // UnityEngine.Texture2D _colorLutSourceTexture
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::Texture2D* colorLutSourceTexture;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // UnityEngine.Texture2D _colorLutTargetTexture
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::Texture2D* colorLutTargetTexture;
    // Field size check
    static_assert(sizeof(::UnityEngine::Texture2D*) == 0x8);
    // System.Single _lutWeight
    // Size: 0x4
    // Offset: 0x80
    float lutWeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // System.Boolean _flipLutY
    // Size: 0x1
    // Offset: 0x84
    bool flipLutY;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: flipLutY and: settings
    char __padding16[0x3] = {};
    // private OVRPassthroughLayer/Settings _settings
    // Size: 0x2D
    // Offset: 0x88
    ::GlobalNamespace::OVRPassthroughLayer::Settings settings;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPassthroughLayer::Settings) == 0x2D);
    // Padding between fields: settings and: cameraRig
    char __padding17[0x3] = {};
    // private OVRCameraRig cameraRig
    // Size: 0x8
    // Offset: 0xB8
    ::GlobalNamespace::OVRCameraRig* cameraRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRCameraRig*) == 0x8);
    // private System.Boolean cameraRigInitialized
    // Size: 0x1
    // Offset: 0xC0
    bool cameraRigInitialized;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: cameraRigInitialized and: auxGameObject
    char __padding19[0x7] = {};
    // private UnityEngine.GameObject auxGameObject
    // Size: 0x8
    // Offset: 0xC8
    ::UnityEngine::GameObject* auxGameObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private OVROverlay passthroughOverlay
    // Size: 0x8
    // Offset: 0xD0
    ::GlobalNamespace::OVROverlay* passthroughOverlay;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<UnityEngine.GameObject,OVRPassthroughLayer/PassthroughMeshInstance> surfaceGameObjects
    // Size: 0x8
    // Offset: 0xD8
    ::System::Collections::Generic::Dictionary_2<::UnityEngine::GameObject*, ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance>* surfaceGameObjects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::UnityEngine::GameObject*, ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance>*) == 0x8);
    // private System.Collections.Generic.List`1<OVRPassthroughLayer/DeferredPassthroughMeshAddition> deferredSurfaceGameObjects
    // Size: 0x8
    // Offset: 0xE0
    ::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition>* deferredSurfaceGameObjects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition>*) == 0x8);
    // System.Collections.Generic.List`1<OVRPassthroughLayer/SerializedSurfaceGeometry> serializedSurfaceGeometry
    // Size: 0x8
    // Offset: 0xE8
    ::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::SerializedSurfaceGeometry>* serializedSurfaceGeometry;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::SerializedSurfaceGeometry>*) == 0x8);
    // System.Single textureOpacity_
    // Size: 0x4
    // Offset: 0xF0
    float textureOpacity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // System.Boolean edgeRenderingEnabled_
    // Size: 0x1
    // Offset: 0xF4
    bool edgeRenderingEnabled;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: edgeRenderingEnabled and: edgeColor
    char __padding26[0x3] = {};
    // UnityEngine.Color edgeColor_
    // Size: 0x10
    // Offset: 0xF8
    ::UnityEngine::Color edgeColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private OVRPlugin/InsightPassthroughColorMapType colorMapType
    // Size: 0x4
    // Offset: 0x108
    ::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType colorMapType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType) == 0x4);
    // private System.Boolean styleDirty
    // Size: 0x1
    // Offset: 0x10C
    bool styleDirty;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: styleDirty and: stylesHandler
    char __padding29[0x3] = {};
    // private OVRPassthroughLayer/StylesHandler _stylesHandler
    // Size: 0x8
    // Offset: 0x110
    ::GlobalNamespace::OVRPassthroughLayer::StylesHandler* stylesHandler;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPassthroughLayer::StylesHandler*) == 0x8);
    public:
    // Get static field: static private System.Collections.Generic.Dictionary`2<OVRPassthroughLayer/ColorMapEditorType,OVRPlugin/InsightPassthroughColorMapType> _editorToColorMapType
    static ::System::Collections::Generic::Dictionary_2<::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType, ::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType>* _get__editorToColorMapType();
    // Set static field: static private System.Collections.Generic.Dictionary`2<OVRPassthroughLayer/ColorMapEditorType,OVRPlugin/InsightPassthroughColorMapType> _editorToColorMapType
    static void _set__editorToColorMapType(::System::Collections::Generic::Dictionary_2<::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType, ::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType>* value);
    // Get static field: static private readonly UnityEngine.Gradient colorMapNeutralGradient
    static ::UnityEngine::Gradient* _get_colorMapNeutralGradient();
    // Set static field: static private readonly UnityEngine.Gradient colorMapNeutralGradient
    static void _set_colorMapNeutralGradient(::UnityEngine::Gradient* value);
    // Get instance field reference: public OVRPassthroughLayer/ProjectionSurfaceType projectionSurfaceType
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType& dyn_projectionSurfaceType();
    // Get instance field reference: public OVROverlay/OverlayType overlayType
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVROverlay::OverlayType& dyn_overlayType();
    // Get instance field reference: public System.Int32 compositionDepth
    [[deprecated("Use field access instead!")]] int& dyn_compositionDepth();
    // Get instance field reference: public System.Boolean hidden
    [[deprecated("Use field access instead!")]] bool& dyn_hidden();
    // Get instance field reference: public System.Boolean overridePerLayerColorScaleAndOffset
    [[deprecated("Use field access instead!")]] bool& dyn_overridePerLayerColorScaleAndOffset();
    // Get instance field reference: public UnityEngine.Vector4 colorScale
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_colorScale();
    // Get instance field reference: public UnityEngine.Vector4 colorOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector4& dyn_colorOffset();
    // Get instance field reference: OVRPassthroughLayer/ColorMapEditorType colorMapEditorType_
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType& dyn_colorMapEditorType_();
    // Get instance field reference: public UnityEngine.Gradient colorMapEditorGradient
    [[deprecated("Use field access instead!")]] ::UnityEngine::Gradient*& dyn_colorMapEditorGradient();
    // Get instance field reference: public System.Single colorMapEditorContrast
    [[deprecated("Use field access instead!")]] float& dyn_colorMapEditorContrast();
    // Get instance field reference: public System.Single colorMapEditorBrightness
    [[deprecated("Use field access instead!")]] float& dyn_colorMapEditorBrightness();
    // Get instance field reference: public System.Single colorMapEditorPosterize
    [[deprecated("Use field access instead!")]] float& dyn_colorMapEditorPosterize();
    // Get instance field reference: public System.Single colorMapEditorSaturation
    [[deprecated("Use field access instead!")]] float& dyn_colorMapEditorSaturation();
    // Get instance field reference: UnityEngine.Texture2D _colorLutSourceTexture
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn__colorLutSourceTexture();
    // Get instance field reference: UnityEngine.Texture2D _colorLutTargetTexture
    [[deprecated("Use field access instead!")]] ::UnityEngine::Texture2D*& dyn__colorLutTargetTexture();
    // Get instance field reference: System.Single _lutWeight
    [[deprecated("Use field access instead!")]] float& dyn__lutWeight();
    // Get instance field reference: System.Boolean _flipLutY
    [[deprecated("Use field access instead!")]] bool& dyn__flipLutY();
    // Get instance field reference: private OVRPassthroughLayer/Settings _settings
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPassthroughLayer::Settings& dyn__settings();
    // Get instance field reference: private OVRCameraRig cameraRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRCameraRig*& dyn_cameraRig();
    // Get instance field reference: private System.Boolean cameraRigInitialized
    [[deprecated("Use field access instead!")]] bool& dyn_cameraRigInitialized();
    // Get instance field reference: private UnityEngine.GameObject auxGameObject
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_auxGameObject();
    // Get instance field reference: private OVROverlay passthroughOverlay
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVROverlay*& dyn_passthroughOverlay();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<UnityEngine.GameObject,OVRPassthroughLayer/PassthroughMeshInstance> surfaceGameObjects
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Dictionary_2<::UnityEngine::GameObject*, ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance>*& dyn_surfaceGameObjects();
    // Get instance field reference: private System.Collections.Generic.List`1<OVRPassthroughLayer/DeferredPassthroughMeshAddition> deferredSurfaceGameObjects
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition>*& dyn_deferredSurfaceGameObjects();
    // Get instance field reference: System.Collections.Generic.List`1<OVRPassthroughLayer/SerializedSurfaceGeometry> serializedSurfaceGeometry
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::SerializedSurfaceGeometry>*& dyn_serializedSurfaceGeometry();
    // Get instance field reference: System.Single textureOpacity_
    [[deprecated("Use field access instead!")]] float& dyn_textureOpacity_();
    // Get instance field reference: System.Boolean edgeRenderingEnabled_
    [[deprecated("Use field access instead!")]] bool& dyn_edgeRenderingEnabled_();
    // Get instance field reference: UnityEngine.Color edgeColor_
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_edgeColor_();
    // Get instance field reference: private OVRPlugin/InsightPassthroughColorMapType colorMapType
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType& dyn_colorMapType();
    // Get instance field reference: private System.Boolean styleDirty
    [[deprecated("Use field access instead!")]] bool& dyn_styleDirty();
    // Get instance field reference: private OVRPassthroughLayer/StylesHandler _stylesHandler
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPassthroughLayer::StylesHandler*& dyn__stylesHandler();
    // public System.Void AddSurfaceGeometry(UnityEngine.GameObject obj, System.Boolean updateTransform)
    // Offset: 0x48E7F14
    void AddSurfaceGeometry(::UnityEngine::GameObject* obj, bool updateTransform);
    // public System.Void RemoveSurfaceGeometry(UnityEngine.GameObject obj)
    // Offset: 0x48E8128
    void RemoveSurfaceGeometry(::UnityEngine::GameObject* obj);
    // public System.Boolean IsSurfaceGeometry(UnityEngine.GameObject obj)
    // Offset: 0x48E84F0
    bool IsSurfaceGeometry(::UnityEngine::GameObject* obj);
    // public System.Single get_textureOpacity()
    // Offset: 0x48E8620
    float get_textureOpacity();
    // public System.Void set_textureOpacity(System.Single value)
    // Offset: 0x48E8628
    void set_textureOpacity(float value);
    // public System.Boolean get_edgeRenderingEnabled()
    // Offset: 0x48E865C
    bool get_edgeRenderingEnabled();
    // public System.Void set_edgeRenderingEnabled(System.Boolean value)
    // Offset: 0x48E8664
    void set_edgeRenderingEnabled(bool value);
    // public UnityEngine.Color get_edgeColor()
    // Offset: 0x48E8684
    ::UnityEngine::Color get_edgeColor();
    // public System.Void set_edgeColor(UnityEngine.Color value)
    // Offset: 0x48E8694
    void set_edgeColor(::UnityEngine::Color value);
    // public System.Void SetColorMap(UnityEngine.Color[] values)
    // Offset: 0x48E86F4
    void SetColorMap(::ArrayW<::UnityEngine::Color> values);
    // public System.Void SetColorLut(OVRPassthroughColorLut lut, System.Single weight)
    // Offset: 0x48E889C
    void SetColorLut(::GlobalNamespace::OVRPassthroughColorLut* lut, float weight);
    // public System.Void SetColorLut(OVRPassthroughColorLut lutSource, OVRPassthroughColorLut lutTarget, System.Single weight)
    // Offset: 0x48E8AA4
    void SetColorLut(::GlobalNamespace::OVRPassthroughColorLut* lutSource, ::GlobalNamespace::OVRPassthroughColorLut* lutTarget, float weight);
    // public System.Void SetColorMapControls(System.Single contrast, System.Single brightness, System.Single posterize, UnityEngine.Gradient gradient, OVRPassthroughLayer/ColorMapEditorType colorMapType)
    // Offset: 0x48E8C1C
    void SetColorMapControls(float contrast, float brightness, float posterize, ::UnityEngine::Gradient* gradient, ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType colorMapType);
    // public System.Void SetColorMapMonochromatic(System.Byte[] values)
    // Offset: 0x48E8FB0
    void SetColorMapMonochromatic(::ArrayW<uint8_t> values);
    // public System.Void SetBrightnessContrastSaturation(System.Single brightness, System.Single contrast, System.Single saturation)
    // Offset: 0x48E90AC
    void SetBrightnessContrastSaturation(float brightness, float contrast, float saturation);
    // public System.Void DisableColorMap()
    // Offset: 0x48E93C0
    void DisableColorMap();
    // public OVRPassthroughLayer/ColorMapEditorType get_colorMapEditorType()
    // Offset: 0x48E93C8
    ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType get_colorMapEditorType();
    // public System.Void set_colorMapEditorType(OVRPassthroughLayer/ColorMapEditorType value)
    // Offset: 0x48E8790
    void set_colorMapEditorType(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
    // public System.Void SetStyleDirty()
    // Offset: 0x48E94A8
    void SetStyleDirty();
    // private System.Void AddDeferredSurfaceGeometries()
    // Offset: 0x48E94B4
    void AddDeferredSurfaceGeometries();
    // private UnityEngine.Matrix4x4 GetTransformMatrixForPassthroughSurfaceObject(UnityEngine.Matrix4x4 worldFromObj)
    // Offset: 0x48E99B8
    ::UnityEngine::Matrix4x4 GetTransformMatrixForPassthroughSurfaceObject(::UnityEngine::Matrix4x4 worldFromObj);
    // private System.Boolean CreateAndAddMesh(UnityEngine.GameObject obj, out System.UInt64 meshHandle, out System.UInt64 instanceHandle, out UnityEngine.Matrix4x4 localToWorld)
    // Offset: 0x48E96FC
    bool CreateAndAddMesh(::UnityEngine::GameObject* obj, ByRef<uint64_t> meshHandle, ByRef<uint64_t> instanceHandle, ByRef<::UnityEngine::Matrix4x4> localToWorld);
    // private System.Void DestroySurfaceGeometries(System.Boolean addBackToDeferredQueue)
    // Offset: 0x48E9FA0
    void DestroySurfaceGeometries(bool addBackToDeferredQueue);
    // private System.Void UpdateSurfaceGeometryTransforms()
    // Offset: 0x48EA248
    void UpdateSurfaceGeometryTransforms();
    // private System.Void UpdateSurfaceGeometryTransform(System.UInt64 instanceHandle, UnityEngine.Matrix4x4 localToWorld)
    // Offset: 0x48EA548
    void UpdateSurfaceGeometryTransform(uint64_t instanceHandle, ::UnityEngine::Matrix4x4 localToWorld);
    // static private UnityEngine.Gradient CreateNeutralColorMapGradient()
    // Offset: 0x48E8DE0
    static ::UnityEngine::Gradient* CreateNeutralColorMapGradient();
    // private System.Boolean HasControlsBasedColorMap()
    // Offset: 0x48EA7F8
    bool HasControlsBasedColorMap();
    // private System.Void UpdateColorMapFromControls(System.Boolean forceUpdate)
    // Offset: 0x48E90F8
    void UpdateColorMapFromControls(bool forceUpdate);
    // private System.Void SyncToOverlay()
    // Offset: 0x48EA820
    void SyncToOverlay();
    // private System.Boolean IsUserDefinedAndDoesNotContainSurfaceGeometry()
    // Offset: 0x48EAB4C
    bool IsUserDefinedAndDoesNotContainSurfaceGeometry();
    // static private System.Single ClampWeight(System.Single weight)
    // Offset: 0x48E89A0
    static float ClampWeight(float weight);
    // private OVROverlay/OverlayShape get_overlayShape()
    // Offset: 0x48EABD8
    ::GlobalNamespace::OVROverlay::OverlayShape get_overlayShape();
    // private System.Void Awake()
    // Offset: 0x48EABEC
    void Awake();
    // private System.Void Update()
    // Offset: 0x48EAE38
    void Update();
    // private System.Void LateUpdate()
    // Offset: 0x48EAE3C
    void LateUpdate();
    // private OVRPlugin/InsightPassthroughStyle2 CreateOvrPluginStyleObject()
    // Offset: 0x48EAFA4
    ::GlobalNamespace::OVRPlugin::InsightPassthroughStyle2 CreateOvrPluginStyleObject();
    // private System.Void OnEnable()
    // Offset: 0x48EB2E0
    void OnEnable();
    // private System.Void OnDisable()
    // Offset: 0x48EB49C
    void OnDisable();
    // private System.Void OnDestroy()
    // Offset: 0x48EB5A0
    void OnDestroy();
    // public System.Void .ctor()
    // Offset: 0x48EB5A8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static OVRPassthroughLayer* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::OVRPassthroughLayer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<OVRPassthroughLayer*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0x48EBAE4
    static void _cctor();
  }; // OVRPassthroughLayer
  #pragma pack(pop)
  static check_size<sizeof(OVRPassthroughLayer), 272 + sizeof(::GlobalNamespace::OVRPassthroughLayer::StylesHandler*)> __GlobalNamespace_OVRPassthroughLayerSizeCheck;
  static_assert(sizeof(OVRPassthroughLayer) == 0x118);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition, "", "OVRPassthroughLayer/DeferredPassthroughMeshAddition");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::SerializedSurfaceGeometry, "", "OVRPassthroughLayer/SerializedSurfaceGeometry");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance, "", "OVRPassthroughLayer/PassthroughMeshInstance");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::Settings, "", "OVRPassthroughLayer/Settings");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType, "", "OVRPassthroughLayer/ColorMapEditorType");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType, "", "OVRPassthroughLayer/ProjectionSurfaceType");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::AddSurfaceGeometry
// Il2CppName: AddSurfaceGeometry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*, bool)>(&GlobalNamespace::OVRPassthroughLayer::AddSurfaceGeometry)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* updateTransform = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "AddSurfaceGeometry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj, updateTransform});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::RemoveSurfaceGeometry
// Il2CppName: RemoveSurfaceGeometry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::OVRPassthroughLayer::RemoveSurfaceGeometry)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "RemoveSurfaceGeometry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::IsSurfaceGeometry
// Il2CppName: IsSurfaceGeometry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::OVRPassthroughLayer::IsSurfaceGeometry)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "IsSurfaceGeometry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_textureOpacity
// Il2CppName: get_textureOpacity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_textureOpacity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_textureOpacity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_textureOpacity
// Il2CppName: set_textureOpacity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(float)>(&GlobalNamespace::OVRPassthroughLayer::set_textureOpacity)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_textureOpacity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_edgeRenderingEnabled
// Il2CppName: get_edgeRenderingEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_edgeRenderingEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_edgeRenderingEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_edgeRenderingEnabled
// Il2CppName: set_edgeRenderingEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(bool)>(&GlobalNamespace::OVRPassthroughLayer::set_edgeRenderingEnabled)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_edgeRenderingEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_edgeColor
// Il2CppName: get_edgeColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Color (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_edgeColor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_edgeColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_edgeColor
// Il2CppName: set_edgeColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::Color)>(&GlobalNamespace::OVRPassthroughLayer::set_edgeColor)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_edgeColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorMap
// Il2CppName: SetColorMap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::ArrayW<::UnityEngine::Color>)>(&GlobalNamespace::OVRPassthroughLayer::SetColorMap)> {
  static const MethodInfo* get() {
    static auto* values = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Color"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorMap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{values});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorLut
// Il2CppName: SetColorLut
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::GlobalNamespace::OVRPassthroughColorLut*, float)>(&GlobalNamespace::OVRPassthroughLayer::SetColorLut)> {
  static const MethodInfo* get() {
    static auto* lut = &::il2cpp_utils::GetClassFromName("", "OVRPassthroughColorLut")->byval_arg;
    static auto* weight = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorLut", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{lut, weight});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorLut
// Il2CppName: SetColorLut
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::GlobalNamespace::OVRPassthroughColorLut*, ::GlobalNamespace::OVRPassthroughColorLut*, float)>(&GlobalNamespace::OVRPassthroughLayer::SetColorLut)> {
  static const MethodInfo* get() {
    static auto* lutSource = &::il2cpp_utils::GetClassFromName("", "OVRPassthroughColorLut")->byval_arg;
    static auto* lutTarget = &::il2cpp_utils::GetClassFromName("", "OVRPassthroughColorLut")->byval_arg;
    static auto* weight = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorLut", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{lutSource, lutTarget, weight});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorMapControls
// Il2CppName: SetColorMapControls
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(float, float, float, ::UnityEngine::Gradient*, ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType)>(&GlobalNamespace::OVRPassthroughLayer::SetColorMapControls)> {
  static const MethodInfo* get() {
    static auto* contrast = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* brightness = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* posterize = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* gradient = &::il2cpp_utils::GetClassFromName("UnityEngine", "Gradient")->byval_arg;
    static auto* colorMapType = &::il2cpp_utils::GetClassFromName("", "OVRPassthroughLayer/ColorMapEditorType")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorMapControls", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contrast, brightness, posterize, gradient, colorMapType});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorMapMonochromatic
// Il2CppName: SetColorMapMonochromatic
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::ArrayW<uint8_t>)>(&GlobalNamespace::OVRPassthroughLayer::SetColorMapMonochromatic)> {
  static const MethodInfo* get() {
    static auto* values = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorMapMonochromatic", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{values});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetBrightnessContrastSaturation
// Il2CppName: SetBrightnessContrastSaturation
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(float, float, float)>(&GlobalNamespace::OVRPassthroughLayer::SetBrightnessContrastSaturation)> {
  static const MethodInfo* get() {
    static auto* brightness = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* contrast = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* saturation = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetBrightnessContrastSaturation", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{brightness, contrast, saturation});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::DisableColorMap
// Il2CppName: DisableColorMap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::DisableColorMap)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "DisableColorMap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_colorMapEditorType
// Il2CppName: get_colorMapEditorType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_colorMapEditorType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_colorMapEditorType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_colorMapEditorType
// Il2CppName: set_colorMapEditorType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType)>(&GlobalNamespace::OVRPassthroughLayer::set_colorMapEditorType)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("", "OVRPassthroughLayer/ColorMapEditorType")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_colorMapEditorType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetStyleDirty
// Il2CppName: SetStyleDirty
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::SetStyleDirty)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetStyleDirty", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::AddDeferredSurfaceGeometries
// Il2CppName: AddDeferredSurfaceGeometries
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::AddDeferredSurfaceGeometries)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "AddDeferredSurfaceGeometries", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::GetTransformMatrixForPassthroughSurfaceObject
// Il2CppName: GetTransformMatrixForPassthroughSurfaceObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Matrix4x4 (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::Matrix4x4)>(&GlobalNamespace::OVRPassthroughLayer::GetTransformMatrixForPassthroughSurfaceObject)> {
  static const MethodInfo* get() {
    static auto* worldFromObj = &::il2cpp_utils::GetClassFromName("UnityEngine", "Matrix4x4")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "GetTransformMatrixForPassthroughSurfaceObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{worldFromObj});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::CreateAndAddMesh
// Il2CppName: CreateAndAddMesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*, ByRef<uint64_t>, ByRef<uint64_t>, ByRef<::UnityEngine::Matrix4x4>)>(&GlobalNamespace::OVRPassthroughLayer::CreateAndAddMesh)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* meshHandle = &::il2cpp_utils::GetClassFromName("System", "UInt64")->this_arg;
    static auto* instanceHandle = &::il2cpp_utils::GetClassFromName("System", "UInt64")->this_arg;
    static auto* localToWorld = &::il2cpp_utils::GetClassFromName("UnityEngine", "Matrix4x4")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "CreateAndAddMesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj, meshHandle, instanceHandle, localToWorld});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::DestroySurfaceGeometries
// Il2CppName: DestroySurfaceGeometries
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(bool)>(&GlobalNamespace::OVRPassthroughLayer::DestroySurfaceGeometries)> {
  static const MethodInfo* get() {
    static auto* addBackToDeferredQueue = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "DestroySurfaceGeometries", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{addBackToDeferredQueue});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::UpdateSurfaceGeometryTransforms
// Il2CppName: UpdateSurfaceGeometryTransforms
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::UpdateSurfaceGeometryTransforms)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "UpdateSurfaceGeometryTransforms", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::UpdateSurfaceGeometryTransform
// Il2CppName: UpdateSurfaceGeometryTransform
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(uint64_t, ::UnityEngine::Matrix4x4)>(&GlobalNamespace::OVRPassthroughLayer::UpdateSurfaceGeometryTransform)> {
  static const MethodInfo* get() {
    static auto* instanceHandle = &::il2cpp_utils::GetClassFromName("System", "UInt64")->byval_arg;
    static auto* localToWorld = &::il2cpp_utils::GetClassFromName("UnityEngine", "Matrix4x4")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "UpdateSurfaceGeometryTransform", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{instanceHandle, localToWorld});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::CreateNeutralColorMapGradient
// Il2CppName: CreateNeutralColorMapGradient
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Gradient* (*)()>(&GlobalNamespace::OVRPassthroughLayer::CreateNeutralColorMapGradient)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "CreateNeutralColorMapGradient", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::HasControlsBasedColorMap
// Il2CppName: HasControlsBasedColorMap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::HasControlsBasedColorMap)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "HasControlsBasedColorMap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::UpdateColorMapFromControls
// Il2CppName: UpdateColorMapFromControls
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(bool)>(&GlobalNamespace::OVRPassthroughLayer::UpdateColorMapFromControls)> {
  static const MethodInfo* get() {
    static auto* forceUpdate = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "UpdateColorMapFromControls", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{forceUpdate});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SyncToOverlay
// Il2CppName: SyncToOverlay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::SyncToOverlay)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SyncToOverlay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::IsUserDefinedAndDoesNotContainSurfaceGeometry
// Il2CppName: IsUserDefinedAndDoesNotContainSurfaceGeometry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::IsUserDefinedAndDoesNotContainSurfaceGeometry)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "IsUserDefinedAndDoesNotContainSurfaceGeometry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::ClampWeight
// Il2CppName: ClampWeight
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (*)(float)>(&GlobalNamespace::OVRPassthroughLayer::ClampWeight)> {
  static const MethodInfo* get() {
    static auto* weight = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "ClampWeight", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{weight});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_overlayShape
// Il2CppName: get_overlayShape
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::OVROverlay::OverlayShape (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_overlayShape)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_overlayShape", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::CreateOvrPluginStyleObject
// Il2CppName: CreateOvrPluginStyleObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::OVRPlugin::InsightPassthroughStyle2 (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::CreateOvrPluginStyleObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "CreateOvrPluginStyleObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&GlobalNamespace::OVRPassthroughLayer::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
