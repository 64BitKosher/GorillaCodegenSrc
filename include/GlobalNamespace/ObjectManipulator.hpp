// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: OVRInput/Controller
#include "GlobalNamespace/OVRInput.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: OVRPassthroughLayer
  class OVRPassthroughLayer;
  // Forward declaring type: GrabObject
  class GrabObject;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: LineRenderer
  class LineRenderer;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: TextMesh
  class TextMesh;
  // Forward declaring type: Vector2
  struct Vector2;
}
// Forward declaring namespace: UnityEngine::UI
namespace UnityEngine::UI {
  // Forward declaring type: Image
  class Image;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: ObjectManipulator
  class ObjectManipulator;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::ObjectManipulator);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::ObjectManipulator*, "", "ObjectManipulator");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0xD8
  #pragma pack(push, 1)
  // Autogenerated type: ObjectManipulator
  // [TokenAttribute] Offset: FFFFFFFF
  class ObjectManipulator : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::ObjectManipulator::$StartDemo$d__23
    class $StartDemo$d__23;
    public:
    // private OVRInput/Controller controller
    // Size: 0x4
    // Offset: 0x20
    ::GlobalNamespace::OVRInput::Controller controller;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRInput::Controller) == 0x4);
    // Padding between fields: controller and: hoverObject
    char __padding0[0x4] = {};
    // private UnityEngine.GameObject hoverObject
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::GameObject* hoverObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.GameObject grabObject
    // Size: 0x8
    // Offset: 0x30
    ::UnityEngine::GameObject* grabObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private System.Single grabTime
    // Size: 0x4
    // Offset: 0x38
    float grabTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 localGrabOffset
    // Size: 0xC
    // Offset: 0x3C
    ::UnityEngine::Vector3 localGrabOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion localGrabRotation
    // Size: 0x10
    // Offset: 0x48
    ::UnityEngine::Quaternion localGrabRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Vector3 camGrabPosition
    // Size: 0xC
    // Offset: 0x58
    ::UnityEngine::Vector3 camGrabPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion camGrabRotation
    // Size: 0x10
    // Offset: 0x64
    ::UnityEngine::Quaternion camGrabRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Vector3 handGrabPosition
    // Size: 0xC
    // Offset: 0x74
    ::UnityEngine::Vector3 handGrabPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion handGrabRotation
    // Size: 0x10
    // Offset: 0x80
    ::UnityEngine::Quaternion handGrabRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Vector3 cursorPosition
    // Size: 0xC
    // Offset: 0x90
    ::UnityEngine::Vector3 cursorPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single rotationOffset
    // Size: 0x4
    // Offset: 0x9C
    float rotationOffset;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.LineRenderer laser
    // Size: 0x8
    // Offset: 0xA0
    ::UnityEngine::LineRenderer* laser;
    // Field size check
    static_assert(sizeof(::UnityEngine::LineRenderer*) == 0x8);
    // public UnityEngine.Transform objectInfo
    // Size: 0x8
    // Offset: 0xA8
    ::UnityEngine::Transform* objectInfo;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public UnityEngine.TextMesh objectNameLabel
    // Size: 0x8
    // Offset: 0xB0
    ::UnityEngine::TextMesh* objectNameLabel;
    // Field size check
    static_assert(sizeof(::UnityEngine::TextMesh*) == 0x8);
    // public UnityEngine.TextMesh objectInstructionsLabel
    // Size: 0x8
    // Offset: 0xB8
    ::UnityEngine::TextMesh* objectInstructionsLabel;
    // Field size check
    static_assert(sizeof(::UnityEngine::TextMesh*) == 0x8);
    // public UnityEngine.UI.Image objectInfoBG
    // Size: 0x8
    // Offset: 0xC0
    ::UnityEngine::UI::Image* objectInfoBG;
    // Field size check
    static_assert(sizeof(::UnityEngine::UI::Image*) == 0x8);
    // public UnityEngine.GameObject demoObjects
    // Size: 0x8
    // Offset: 0xC8
    ::UnityEngine::GameObject* demoObjects;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public OVRPassthroughLayer passthrough
    // Size: 0x8
    // Offset: 0xD0
    ::GlobalNamespace::OVRPassthroughLayer* passthrough;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPassthroughLayer*) == 0x8);
    public:
    // Get instance field reference: private OVRInput/Controller controller
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRInput::Controller& dyn_controller();
    // Get instance field reference: private UnityEngine.GameObject hoverObject
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_hoverObject();
    // Get instance field reference: private UnityEngine.GameObject grabObject
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_grabObject();
    // Get instance field reference: private System.Single grabTime
    [[deprecated("Use field access instead!")]] float& dyn_grabTime();
    // Get instance field reference: private UnityEngine.Vector3 localGrabOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_localGrabOffset();
    // Get instance field reference: private UnityEngine.Quaternion localGrabRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_localGrabRotation();
    // Get instance field reference: private UnityEngine.Vector3 camGrabPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_camGrabPosition();
    // Get instance field reference: private UnityEngine.Quaternion camGrabRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_camGrabRotation();
    // Get instance field reference: private UnityEngine.Vector3 handGrabPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_handGrabPosition();
    // Get instance field reference: private UnityEngine.Quaternion handGrabRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_handGrabRotation();
    // Get instance field reference: private UnityEngine.Vector3 cursorPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_cursorPosition();
    // Get instance field reference: private System.Single rotationOffset
    [[deprecated("Use field access instead!")]] float& dyn_rotationOffset();
    // Get instance field reference: public UnityEngine.LineRenderer laser
    [[deprecated("Use field access instead!")]] ::UnityEngine::LineRenderer*& dyn_laser();
    // Get instance field reference: public UnityEngine.Transform objectInfo
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_objectInfo();
    // Get instance field reference: public UnityEngine.TextMesh objectNameLabel
    [[deprecated("Use field access instead!")]] ::UnityEngine::TextMesh*& dyn_objectNameLabel();
    // Get instance field reference: public UnityEngine.TextMesh objectInstructionsLabel
    [[deprecated("Use field access instead!")]] ::UnityEngine::TextMesh*& dyn_objectInstructionsLabel();
    // Get instance field reference: public UnityEngine.UI.Image objectInfoBG
    [[deprecated("Use field access instead!")]] ::UnityEngine::UI::Image*& dyn_objectInfoBG();
    // Get instance field reference: public UnityEngine.GameObject demoObjects
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_demoObjects();
    // Get instance field reference: public OVRPassthroughLayer passthrough
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::OVRPassthroughLayer*& dyn_passthrough();
    // private System.Void Start()
    // Offset: 0x2937650
    void Start();
    // private System.Void Update()
    // Offset: 0x2937840
    void Update();
    // private System.Void GrabHoverObject(UnityEngine.GameObject grbObj, UnityEngine.Vector3 controllerPos, UnityEngine.Quaternion controllerRot)
    // Offset: 0x2938804
    void GrabHoverObject(::UnityEngine::GameObject* grbObj, ::UnityEngine::Vector3 controllerPos, ::UnityEngine::Quaternion controllerRot);
    // private System.Void ReleaseObject()
    // Offset: 0x2939594
    void ReleaseObject();
    // private System.Collections.IEnumerator StartDemo()
    // Offset: 0x29377D4
    ::System::Collections::IEnumerator* StartDemo();
    // private System.Void FindHoverObject(UnityEngine.Vector3 controllerPos, UnityEngine.Quaternion controllerRot)
    // Offset: 0x2937A90
    void FindHoverObject(::UnityEngine::Vector3 controllerPos, ::UnityEngine::Quaternion controllerRot);
    // private System.Void ManipulateObject(UnityEngine.GameObject obj, UnityEngine.Vector3 controllerPos, UnityEngine.Quaternion controllerRot)
    // Offset: 0x2938AF4
    void ManipulateObject(::UnityEngine::GameObject* obj, ::UnityEngine::Vector3 controllerPos, ::UnityEngine::Quaternion controllerRot);
    // private System.Void ClampGrabOffset(ref UnityEngine.Vector3 localOffset, System.Single thumbY)
    // Offset: 0x29398C8
    void ClampGrabOffset(ByRef<::UnityEngine::Vector3> localOffset, float thumbY);
    // private UnityEngine.Vector3 ClampScale(UnityEngine.Vector3 localScale, UnityEngine.Vector2 thumb)
    // Offset: 0x293997C
    ::UnityEngine::Vector3 ClampScale(::UnityEngine::Vector3 localScale, ::UnityEngine::Vector2 thumb);
    // private System.Void CheckForDominantHand()
    // Offset: 0x29399AC
    void CheckForDominantHand();
    // private System.Void AssignInstructions(GrabObject targetObject)
    // Offset: 0x2939784
    void AssignInstructions(::GlobalNamespace::GrabObject* targetObject);
    // public System.Void .ctor()
    // Offset: 0x2939A9C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static ObjectManipulator* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::ObjectManipulator::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<ObjectManipulator*, creationType>()));
    }
  }; // ObjectManipulator
  #pragma pack(pop)
  static check_size<sizeof(ObjectManipulator), 208 + sizeof(::GlobalNamespace::OVRPassthroughLayer*)> __GlobalNamespace_ObjectManipulatorSizeCheck;
  static_assert(sizeof(ObjectManipulator) == 0xD8);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)()>(&GlobalNamespace::ObjectManipulator::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)()>(&GlobalNamespace::ObjectManipulator::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::GrabHoverObject
// Il2CppName: GrabHoverObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)(::UnityEngine::GameObject*, ::UnityEngine::Vector3, ::UnityEngine::Quaternion)>(&GlobalNamespace::ObjectManipulator::GrabHoverObject)> {
  static const MethodInfo* get() {
    static auto* grbObj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* controllerPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* controllerRot = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "GrabHoverObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{grbObj, controllerPos, controllerRot});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::ReleaseObject
// Il2CppName: ReleaseObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)()>(&GlobalNamespace::ObjectManipulator::ReleaseObject)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "ReleaseObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::StartDemo
// Il2CppName: StartDemo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::ObjectManipulator::*)()>(&GlobalNamespace::ObjectManipulator::StartDemo)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "StartDemo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::FindHoverObject
// Il2CppName: FindHoverObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)(::UnityEngine::Vector3, ::UnityEngine::Quaternion)>(&GlobalNamespace::ObjectManipulator::FindHoverObject)> {
  static const MethodInfo* get() {
    static auto* controllerPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* controllerRot = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "FindHoverObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{controllerPos, controllerRot});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::ManipulateObject
// Il2CppName: ManipulateObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)(::UnityEngine::GameObject*, ::UnityEngine::Vector3, ::UnityEngine::Quaternion)>(&GlobalNamespace::ObjectManipulator::ManipulateObject)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* controllerPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* controllerRot = &::il2cpp_utils::GetClassFromName("UnityEngine", "Quaternion")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "ManipulateObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj, controllerPos, controllerRot});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::ClampGrabOffset
// Il2CppName: ClampGrabOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)(ByRef<::UnityEngine::Vector3>, float)>(&GlobalNamespace::ObjectManipulator::ClampGrabOffset)> {
  static const MethodInfo* get() {
    static auto* localOffset = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* thumbY = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "ClampGrabOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{localOffset, thumbY});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::ClampScale
// Il2CppName: ClampScale
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::ObjectManipulator::*)(::UnityEngine::Vector3, ::UnityEngine::Vector2)>(&GlobalNamespace::ObjectManipulator::ClampScale)> {
  static const MethodInfo* get() {
    static auto* localScale = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* thumb = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector2")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "ClampScale", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{localScale, thumb});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::CheckForDominantHand
// Il2CppName: CheckForDominantHand
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)()>(&GlobalNamespace::ObjectManipulator::CheckForDominantHand)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "CheckForDominantHand", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::AssignInstructions
// Il2CppName: AssignInstructions
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::ObjectManipulator::*)(::GlobalNamespace::GrabObject*)>(&GlobalNamespace::ObjectManipulator::AssignInstructions)> {
  static const MethodInfo* get() {
    static auto* targetObject = &::il2cpp_utils::GetClassFromName("", "GrabObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::ObjectManipulator*), "AssignInstructions", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{targetObject});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::ObjectManipulator::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
