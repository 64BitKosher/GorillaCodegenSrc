// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: ITetheredObjectBehavior
#include "GlobalNamespace/ITetheredObjectBehavior.hpp"
// Including type: UnityEngine.Bounds
#include "UnityEngine/Bounds.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Transform
  class Transform;
  // Skipping declaration: Vector3 because it is already included!
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: BalloonDynamics
  class BalloonDynamics;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::BalloonDynamics);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::BalloonDynamics*, "", "BalloonDynamics");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0xA0
  #pragma pack(push, 1)
  // Autogenerated type: BalloonDynamics
  // [TokenAttribute] Offset: FFFFFFFF
  class BalloonDynamics : public ::UnityEngine::MonoBehaviour/*, public ::GlobalNamespace::ITetheredObjectBehavior*/ {
    public:
    public:
    // private UnityEngine.Rigidbody rb
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::Rigidbody* rb;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // private UnityEngine.Collider balloonCollider
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Collider* balloonCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::Collider*) == 0x8);
    // private UnityEngine.Bounds bounds
    // Size: 0x18
    // Offset: 0x30
    ::UnityEngine::Bounds bounds;
    // Field size check
    static_assert(sizeof(::UnityEngine::Bounds) == 0x18);
    // public System.Single bouyancyForce
    // Size: 0x4
    // Offset: 0x48
    float bouyancyForce;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single bouyancyMinHeight
    // Size: 0x4
    // Offset: 0x4C
    float bouyancyMinHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single bouyancyMaxHeight
    // Size: 0x4
    // Offset: 0x50
    float bouyancyMaxHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single bouyancyActualHeight
    // Size: 0x4
    // Offset: 0x54
    float bouyancyActualHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single varianceMaxheight
    // Size: 0x4
    // Offset: 0x58
    float varianceMaxheight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single airResistance
    // Size: 0x4
    // Offset: 0x5C
    float airResistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.GameObject knot
    // Size: 0x8
    // Offset: 0x60
    ::UnityEngine::GameObject* knot;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.Rigidbody knotRb
    // Size: 0x8
    // Offset: 0x68
    ::UnityEngine::Rigidbody* knotRb;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // public UnityEngine.Transform grabPt
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::Transform* grabPt;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private UnityEngine.Transform grabPtInitParent
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::Transform* grabPtInitParent;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // public System.Single stringLength
    // Size: 0x4
    // Offset: 0x80
    float stringLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single stringStrength
    // Size: 0x4
    // Offset: 0x84
    float stringStrength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single stringStretch
    // Size: 0x4
    // Offset: 0x88
    float stringStretch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single maximumVelocity
    // Size: 0x4
    // Offset: 0x8C
    float maximumVelocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single upRightTorque
    // Size: 0x4
    // Offset: 0x90
    float upRightTorque;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean enableDynamics
    // Size: 0x1
    // Offset: 0x94
    bool enableDynamics;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean enableDistanceConstraints
    // Size: 0x1
    // Offset: 0x95
    bool enableDistanceConstraints;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: enableDistanceConstraints and: balloonScale
    char __padding19[0x2] = {};
    // public System.Single balloonScale
    // Size: 0x4
    // Offset: 0x98
    float balloonScale;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single bopSpeed
    // Size: 0x4
    // Offset: 0x9C
    float bopSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    public:
    // Creating interface conversion operator: operator ::GlobalNamespace::ITetheredObjectBehavior
    operator ::GlobalNamespace::ITetheredObjectBehavior() noexcept {
      return *reinterpret_cast<::GlobalNamespace::ITetheredObjectBehavior*>(this);
    }
    // Get instance field reference: private UnityEngine.Rigidbody rb
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_rb();
    // Get instance field reference: private UnityEngine.Collider balloonCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::Collider*& dyn_balloonCollider();
    // Get instance field reference: private UnityEngine.Bounds bounds
    [[deprecated("Use field access instead!")]] ::UnityEngine::Bounds& dyn_bounds();
    // Get instance field reference: public System.Single bouyancyForce
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyForce();
    // Get instance field reference: public System.Single bouyancyMinHeight
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyMinHeight();
    // Get instance field reference: public System.Single bouyancyMaxHeight
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyMaxHeight();
    // Get instance field reference: private System.Single bouyancyActualHeight
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyActualHeight();
    // Get instance field reference: public System.Single varianceMaxheight
    [[deprecated("Use field access instead!")]] float& dyn_varianceMaxheight();
    // Get instance field reference: public System.Single airResistance
    [[deprecated("Use field access instead!")]] float& dyn_airResistance();
    // Get instance field reference: public UnityEngine.GameObject knot
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_knot();
    // Get instance field reference: private UnityEngine.Rigidbody knotRb
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_knotRb();
    // Get instance field reference: public UnityEngine.Transform grabPt
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_grabPt();
    // Get instance field reference: private UnityEngine.Transform grabPtInitParent
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_grabPtInitParent();
    // Get instance field reference: public System.Single stringLength
    [[deprecated("Use field access instead!")]] float& dyn_stringLength();
    // Get instance field reference: public System.Single stringStrength
    [[deprecated("Use field access instead!")]] float& dyn_stringStrength();
    // Get instance field reference: public System.Single stringStretch
    [[deprecated("Use field access instead!")]] float& dyn_stringStretch();
    // Get instance field reference: public System.Single maximumVelocity
    [[deprecated("Use field access instead!")]] float& dyn_maximumVelocity();
    // Get instance field reference: public System.Single upRightTorque
    [[deprecated("Use field access instead!")]] float& dyn_upRightTorque();
    // Get instance field reference: private System.Boolean enableDynamics
    [[deprecated("Use field access instead!")]] bool& dyn_enableDynamics();
    // Get instance field reference: private System.Boolean enableDistanceConstraints
    [[deprecated("Use field access instead!")]] bool& dyn_enableDistanceConstraints();
    // Get instance field reference: public System.Single balloonScale
    [[deprecated("Use field access instead!")]] float& dyn_balloonScale();
    // Get instance field reference: public System.Single bopSpeed
    [[deprecated("Use field access instead!")]] float& dyn_bopSpeed();
    // private System.Void Awake()
    // Offset: 0x2963434
    void Awake();
    // private System.Void Start()
    // Offset: 0x2963528
    void Start();
    // public System.Void ReParent()
    // Offset: 0x2963568
    void ReParent();
    // private System.Void ApplyBouyancyForce()
    // Offset: 0x2963620
    void ApplyBouyancyForce();
    // private System.Void ApplyUpRightForce()
    // Offset: 0x29636AC
    void ApplyUpRightForce();
    // private System.Void ApplyAirResistance()
    // Offset: 0x2963780
    void ApplyAirResistance();
    // private System.Void ApplyDistanceConstraint()
    // Offset: 0x29637D0
    void ApplyDistanceConstraint();
    // public System.Void EnableDynamics(System.Boolean enable, System.Boolean kinematic)
    // Offset: 0x2963AEC
    void EnableDynamics(bool enable, bool kinematic);
    // public System.Void EnableDistanceConstraints(System.Boolean enable, System.Single scale)
    // Offset: 0x2963C64
    void EnableDistanceConstraints(bool enable, float scale);
    // public System.Boolean get_ColliderEnabled()
    // Offset: 0x2963C74
    bool get_ColliderEnabled();
    // private System.Void FixedUpdate()
    // Offset: 0x2963CF8
    void FixedUpdate();
    // private System.Void ITetheredObjectBehavior.DbgClear()
    // Offset: 0x2963EAC
    void ITetheredObjectBehavior_DbgClear();
    // private System.Boolean ITetheredObjectBehavior.IsEnabled()
    // Offset: 0x2963EE4
    bool ITetheredObjectBehavior_IsEnabled();
    // private System.Void ITetheredObjectBehavior.TriggerEnter(UnityEngine.Collider other, ref UnityEngine.Vector3 force, ref UnityEngine.Vector3 collisionPt, ref System.Boolean transferOwnership)
    // Offset: 0x2963EEC
    void ITetheredObjectBehavior_TriggerEnter(::UnityEngine::Collider* other, ByRef<::UnityEngine::Vector3> force, ByRef<::UnityEngine::Vector3> collisionPt, ByRef<bool> transferOwnership);
    // public System.Boolean ReturnStep()
    // Offset: 0x2964308
    bool ReturnStep();
    // public System.Void .ctor()
    // Offset: 0x2964310
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static BalloonDynamics* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::BalloonDynamics::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<BalloonDynamics*, creationType>()));
    }
  }; // BalloonDynamics
  #pragma pack(pop)
  static check_size<sizeof(BalloonDynamics), 156 + sizeof(float)> __GlobalNamespace_BalloonDynamicsSizeCheck;
  static_assert(sizeof(BalloonDynamics) == 0xA0);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ReParent
// Il2CppName: ReParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ReParent)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ReParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ApplyBouyancyForce
// Il2CppName: ApplyBouyancyForce
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ApplyBouyancyForce)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ApplyBouyancyForce", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ApplyUpRightForce
// Il2CppName: ApplyUpRightForce
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ApplyUpRightForce)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ApplyUpRightForce", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ApplyAirResistance
// Il2CppName: ApplyAirResistance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ApplyAirResistance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ApplyAirResistance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ApplyDistanceConstraint
// Il2CppName: ApplyDistanceConstraint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ApplyDistanceConstraint)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ApplyDistanceConstraint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::EnableDynamics
// Il2CppName: EnableDynamics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)(bool, bool)>(&GlobalNamespace::BalloonDynamics::EnableDynamics)> {
  static const MethodInfo* get() {
    static auto* enable = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* kinematic = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "EnableDynamics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{enable, kinematic});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::EnableDistanceConstraints
// Il2CppName: EnableDistanceConstraints
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)(bool, float)>(&GlobalNamespace::BalloonDynamics::EnableDistanceConstraints)> {
  static const MethodInfo* get() {
    static auto* enable = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* scale = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "EnableDistanceConstraints", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{enable, scale});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::get_ColliderEnabled
// Il2CppName: get_ColliderEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::get_ColliderEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "get_ColliderEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ITetheredObjectBehavior_DbgClear
// Il2CppName: ITetheredObjectBehavior.DbgClear
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ITetheredObjectBehavior_DbgClear)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ITetheredObjectBehavior.DbgClear", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ITetheredObjectBehavior_IsEnabled
// Il2CppName: ITetheredObjectBehavior.IsEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ITetheredObjectBehavior_IsEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ITetheredObjectBehavior.IsEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ITetheredObjectBehavior_TriggerEnter
// Il2CppName: ITetheredObjectBehavior.TriggerEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::BalloonDynamics::*)(::UnityEngine::Collider*, ByRef<::UnityEngine::Vector3>, ByRef<::UnityEngine::Vector3>, ByRef<bool>)>(&GlobalNamespace::BalloonDynamics::ITetheredObjectBehavior_TriggerEnter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    static auto* force = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* collisionPt = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* transferOwnership = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ITetheredObjectBehavior.TriggerEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other, force, collisionPt, transferOwnership});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::ReturnStep
// Il2CppName: ReturnStep
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::BalloonDynamics::*)()>(&GlobalNamespace::BalloonDynamics::ReturnStep)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::BalloonDynamics*), "ReturnStep", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::BalloonDynamics::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
