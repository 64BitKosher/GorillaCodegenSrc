// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: UnityEngine.RaycastHit
#include "UnityEngine/RaycastHit.hpp"
// Including type: UnityEngine.LayerMask
#include "UnityEngine/LayerMask.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: MonkeyeAI_ReplState
#include "GlobalNamespace/MonkeyeAI_ReplState.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: MaterialPropertyBlock
  class MaterialPropertyBlock;
  // Forward declaring type: Renderer
  class Renderer;
  // Forward declaring type: Animator
  class Animator;
  // Forward declaring type: SkinnedMeshRenderer
  class SkinnedMeshRenderer;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: AudioClip
  class AudioClip;
}
// Forward declaring namespace: Pathfinding
namespace Pathfinding {
  // Forward declaring type: AIDestinationSetter
  class AIDestinationSetter;
  // Forward declaring type: AIPath
  class AIPath;
  // Forward declaring type: AILerp
  class AILerp;
  // Forward declaring type: Seeker
  class Seeker;
  // Forward declaring type: Path
  class Path;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: Monkeye_LazerFX
  class Monkeye_LazerFX;
  // Forward declaring type: MazePlayerCollection
  class MazePlayerCollection;
  // Forward declaring type: PlayerCollection
  class PlayerCollection;
  // Forward declaring type: VRRig
  class VRRig;
}
// Forward declaring namespace: Photon::Pun
namespace Photon::Pun {
  // Forward declaring type: PhotonView
  class PhotonView;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: MonkeyeAI
  class MonkeyeAI;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::MonkeyeAI);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::MonkeyeAI*, "", "MonkeyeAI");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0x1F5
  #pragma pack(push, 1)
  // Autogenerated type: MonkeyeAI
  // [TokenAttribute] Offset: FFFFFFFF
  class MonkeyeAI : public ::UnityEngine::MonoBehaviour {
    public:
    public:
    // public System.Collections.Generic.List`1<UnityEngine.Transform> patrolPts
    // Size: 0x8
    // Offset: 0x20
    ::System::Collections::Generic::List_1<::UnityEngine::Transform*>* patrolPts;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::UnityEngine::Transform*>*) == 0x8);
    // public UnityEngine.Transform sleepPt
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Transform* sleepPt;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Int32 patrolIdx
    // Size: 0x4
    // Offset: 0x30
    int patrolIdx;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 patrolCount
    // Size: 0x4
    // Offset: 0x34
    int patrolCount;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Vector3 targetPosition
    // Size: 0xC
    // Offset: 0x38
    ::UnityEngine::Vector3 targetPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // Padding between fields: targetPosition and: portalMatPropBlock
    char __padding4[0x4] = {};
    // private UnityEngine.MaterialPropertyBlock portalMatPropBlock
    // Size: 0x8
    // Offset: 0x48
    ::UnityEngine::MaterialPropertyBlock* portalMatPropBlock;
    // Field size check
    static_assert(sizeof(::UnityEngine::MaterialPropertyBlock*) == 0x8);
    // private UnityEngine.MaterialPropertyBlock monkEyeMatPropBlock
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::MaterialPropertyBlock* monkEyeMatPropBlock;
    // Field size check
    static_assert(sizeof(::UnityEngine::MaterialPropertyBlock*) == 0x8);
    // private UnityEngine.Renderer renderer
    // Size: 0x8
    // Offset: 0x58
    ::UnityEngine::Renderer* renderer;
    // Field size check
    static_assert(sizeof(::UnityEngine::Renderer*) == 0x8);
    // private Pathfinding.AIDestinationSetter aiDest
    // Size: 0x8
    // Offset: 0x60
    ::Pathfinding::AIDestinationSetter* aiDest;
    // Field size check
    static_assert(sizeof(::Pathfinding::AIDestinationSetter*) == 0x8);
    // private Pathfinding.AIPath aiPath
    // Size: 0x8
    // Offset: 0x68
    ::Pathfinding::AIPath* aiPath;
    // Field size check
    static_assert(sizeof(::Pathfinding::AIPath*) == 0x8);
    // private Pathfinding.AILerp aiLerp
    // Size: 0x8
    // Offset: 0x70
    ::Pathfinding::AILerp* aiLerp;
    // Field size check
    static_assert(sizeof(::Pathfinding::AILerp*) == 0x8);
    // private Pathfinding.Seeker seeker
    // Size: 0x8
    // Offset: 0x78
    ::Pathfinding::Seeker* seeker;
    // Field size check
    static_assert(sizeof(::Pathfinding::Seeker*) == 0x8);
    // private Pathfinding.Path path
    // Size: 0x8
    // Offset: 0x80
    ::Pathfinding::Path* path;
    // Field size check
    static_assert(sizeof(::Pathfinding::Path*) == 0x8);
    // private System.Int32 currentWaypoint
    // Size: 0x4
    // Offset: 0x88
    int currentWaypoint;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Single nextWaypointDistance
    // Size: 0x4
    // Offset: 0x8C
    float nextWaypointDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean reachedEndOfPath
    // Size: 0x1
    // Offset: 0x90
    bool reachedEndOfPath;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean calculatingPath
    // Size: 0x1
    // Offset: 0x91
    bool calculatingPath;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: calculatingPath and: lazerFx
    char __padding16[0x6] = {};
    // private Monkeye_LazerFX lazerFx
    // Size: 0x8
    // Offset: 0x98
    ::GlobalNamespace::Monkeye_LazerFX* lazerFx;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::Monkeye_LazerFX*) == 0x8);
    // private UnityEngine.Animator animController
    // Size: 0x8
    // Offset: 0xA0
    ::UnityEngine::Animator* animController;
    // Field size check
    static_assert(sizeof(::UnityEngine::Animator*) == 0x8);
    // private UnityEngine.RaycastHit[] rayResults
    // Size: 0x8
    // Offset: 0xA8
    ::ArrayW<::UnityEngine::RaycastHit> rayResults;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::RaycastHit>) == 0x8);
    // private UnityEngine.LayerMask layerMask
    // Size: 0x4
    // Offset: 0xB0
    ::UnityEngine::LayerMask layerMask;
    // Field size check
    static_assert(sizeof(::UnityEngine::LayerMask) == 0x4);
    // private System.Boolean wasConnectedToRoom
    // Size: 0x1
    // Offset: 0xB4
    bool wasConnectedToRoom;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: wasConnectedToRoom and: skinnedMeshRenderer
    char __padding21[0x3] = {};
    // public UnityEngine.SkinnedMeshRenderer skinnedMeshRenderer
    // Size: 0x8
    // Offset: 0xB8
    ::UnityEngine::SkinnedMeshRenderer* skinnedMeshRenderer;
    // Field size check
    static_assert(sizeof(::UnityEngine::SkinnedMeshRenderer*) == 0x8);
    // public MazePlayerCollection playerCollection
    // Size: 0x8
    // Offset: 0xC0
    ::GlobalNamespace::MazePlayerCollection* playerCollection;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::MazePlayerCollection*) == 0x8);
    // public PlayerCollection playersInRoomCollection
    // Size: 0x8
    // Offset: 0xC8
    ::GlobalNamespace::PlayerCollection* playersInRoomCollection;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::PlayerCollection*) == 0x8);
    // private System.Collections.Generic.List`1<VRRig> validRigs
    // Size: 0x8
    // Offset: 0xD0
    ::System::Collections::Generic::List_1<::GlobalNamespace::VRRig*>* validRigs;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::GlobalNamespace::VRRig*>*) == 0x8);
    // public UnityEngine.GameObject portalFx
    // Size: 0x8
    // Offset: 0xD8
    ::UnityEngine::GameObject* portalFx;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // public UnityEngine.Transform[] eyeBones
    // Size: 0x8
    // Offset: 0xE0
    ::ArrayW<::UnityEngine::Transform*> eyeBones;
    // Field size check
    static_assert(sizeof(::ArrayW<::UnityEngine::Transform*>) == 0x8);
    // public System.Single speed
    // Size: 0x4
    // Offset: 0xE8
    float speed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single rotationSpeed
    // Size: 0x4
    // Offset: 0xEC
    float rotationSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single wakeDistance
    // Size: 0x4
    // Offset: 0xF0
    float wakeDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single chaseDistance
    // Size: 0x4
    // Offset: 0xF4
    float chaseDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single sleepDuration
    // Size: 0x4
    // Offset: 0xF8
    float sleepDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single attackDistance
    // Size: 0x4
    // Offset: 0xFC
    float attackDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single beginAttackTime
    // Size: 0x4
    // Offset: 0x100
    float beginAttackTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single openFloorTime
    // Size: 0x4
    // Offset: 0x104
    float openFloorTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single dropPlayerTime
    // Size: 0x4
    // Offset: 0x108
    float dropPlayerTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single closeFloorTime
    // Size: 0x4
    // Offset: 0x10C
    float closeFloorTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Color portalColor
    // Size: 0x10
    // Offset: 0x110
    ::UnityEngine::Color portalColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.Color gorillaPortalColor
    // Size: 0x10
    // Offset: 0x120
    ::UnityEngine::Color gorillaPortalColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.Color monkEyeColor
    // Size: 0x10
    // Offset: 0x130
    ::UnityEngine::Color monkEyeColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.Color monkEyeEyeColorNormal
    // Size: 0x10
    // Offset: 0x140
    ::UnityEngine::Color monkEyeEyeColorNormal;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public UnityEngine.Color monkEyeEyeColorAttacking
    // Size: 0x10
    // Offset: 0x150
    ::UnityEngine::Color monkEyeEyeColorAttacking;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // public System.Int32 maxPatrols
    // Size: 0x4
    // Offset: 0x160
    int maxPatrols;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: maxPatrols and: targetRig
    char __padding43[0x4] = {};
    // private VRRig targetRig
    // Size: 0x8
    // Offset: 0x168
    ::GlobalNamespace::VRRig* targetRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRRig*) == 0x8);
    // public MonkeyeAI_ReplState replState
    // Size: 0x8
    // Offset: 0x170
    ::GlobalNamespace::MonkeyeAI_ReplState* replState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::MonkeyeAI_ReplState*) == 0x8);
    // private System.Int32 layerBase
    // Size: 0x4
    // Offset: 0x178
    int layerBase;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 layerForward
    // Size: 0x4
    // Offset: 0x17C
    int layerForward;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 layerLeft
    // Size: 0x4
    // Offset: 0x180
    int layerLeft;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 layerRight
    // Size: 0x4
    // Offset: 0x184
    int layerRight;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private UnityEngine.Vector3 prevPosition
    // Size: 0xC
    // Offset: 0x188
    ::UnityEngine::Vector3 prevPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 velocity
    // Size: 0xC
    // Offset: 0x194
    ::UnityEngine::Vector3 velocity;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // public UnityEngine.AudioSource audioSource
    // Size: 0x8
    // Offset: 0x1A0
    ::UnityEngine::AudioSource* audioSource;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // public UnityEngine.AudioClip sleepLoopSound
    // Size: 0x8
    // Offset: 0x1A8
    ::UnityEngine::AudioClip* sleepLoopSound;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioClip*) == 0x8);
    // public System.Single sleepLoopVolume
    // Size: 0x4
    // Offset: 0x1B0
    float sleepLoopVolume;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: sleepLoopVolume and: patrolLoopSound
    char __padding54[0x4] = {};
    // public UnityEngine.AudioClip patrolLoopSound
    // Size: 0x8
    // Offset: 0x1B8
    ::UnityEngine::AudioClip* patrolLoopSound;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioClip*) == 0x8);
    // public System.Single patrolLoopVolume
    // Size: 0x4
    // Offset: 0x1C0
    float patrolLoopVolume;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single patrolLoopFadeInTime
    // Size: 0x4
    // Offset: 0x1C4
    float patrolLoopFadeInTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.AudioClip chaseLoopSound
    // Size: 0x8
    // Offset: 0x1C8
    ::UnityEngine::AudioClip* chaseLoopSound;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioClip*) == 0x8);
    // public System.Single chaseLoopVolume
    // Size: 0x4
    // Offset: 0x1D0
    float chaseLoopVolume;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single chaseLoopFadeInTime
    // Size: 0x4
    // Offset: 0x1D4
    float chaseLoopFadeInTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.AudioClip attackSound
    // Size: 0x8
    // Offset: 0x1D8
    ::UnityEngine::AudioClip* attackSound;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioClip*) == 0x8);
    // public System.Single attackVolume
    // Size: 0x4
    // Offset: 0x1E0
    float attackVolume;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // Padding between fields: attackVolume and: view
    char __padding62[0x4] = {};
    // private Photon.Pun.PhotonView _view
    // Size: 0x8
    // Offset: 0x1E8
    ::Photon::Pun::PhotonView* view;
    // Field size check
    static_assert(sizeof(::Photon::Pun::PhotonView*) == 0x8);
    // public System.Single overlapRadius
    // Size: 0x4
    // Offset: 0x1F0
    float overlapRadius;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean lockedOn
    // Size: 0x1
    // Offset: 0x1F4
    bool lockedOn;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Get static field: static private readonly System.Int32 EmissionColorShaderProp
    static int _get_EmissionColorShaderProp();
    // Set static field: static private readonly System.Int32 EmissionColorShaderProp
    static void _set_EmissionColorShaderProp(int value);
    // Get static field: static private readonly System.Int32 ColorShaderProp
    static int _get_ColorShaderProp();
    // Set static field: static private readonly System.Int32 ColorShaderProp
    static void _set_ColorShaderProp(int value);
    // Get static field: static private readonly System.Int32 EyeColorShaderProp
    static int _get_EyeColorShaderProp();
    // Set static field: static private readonly System.Int32 EyeColorShaderProp
    static void _set_EyeColorShaderProp(int value);
    // Get static field: static private readonly System.Int32 tintColorShaderProp
    static int _get_tintColorShaderProp();
    // Set static field: static private readonly System.Int32 tintColorShaderProp
    static void _set_tintColorShaderProp(int value);
    // Get static field: static private readonly System.Int32 animStateID
    static int _get_animStateID();
    // Set static field: static private readonly System.Int32 animStateID
    static void _set_animStateID(int value);
    // Get instance field reference: public System.Collections.Generic.List`1<UnityEngine.Transform> patrolPts
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::UnityEngine::Transform*>*& dyn_patrolPts();
    // Get instance field reference: public UnityEngine.Transform sleepPt
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_sleepPt();
    // Get instance field reference: private System.Int32 patrolIdx
    [[deprecated("Use field access instead!")]] int& dyn_patrolIdx();
    // Get instance field reference: private System.Int32 patrolCount
    [[deprecated("Use field access instead!")]] int& dyn_patrolCount();
    // Get instance field reference: private UnityEngine.Vector3 targetPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_targetPosition();
    // Get instance field reference: private UnityEngine.MaterialPropertyBlock portalMatPropBlock
    [[deprecated("Use field access instead!")]] ::UnityEngine::MaterialPropertyBlock*& dyn_portalMatPropBlock();
    // Get instance field reference: private UnityEngine.MaterialPropertyBlock monkEyeMatPropBlock
    [[deprecated("Use field access instead!")]] ::UnityEngine::MaterialPropertyBlock*& dyn_monkEyeMatPropBlock();
    // Get instance field reference: private UnityEngine.Renderer renderer
    [[deprecated("Use field access instead!")]] ::UnityEngine::Renderer*& dyn_renderer();
    // Get instance field reference: private Pathfinding.AIDestinationSetter aiDest
    [[deprecated("Use field access instead!")]] ::Pathfinding::AIDestinationSetter*& dyn_aiDest();
    // Get instance field reference: private Pathfinding.AIPath aiPath
    [[deprecated("Use field access instead!")]] ::Pathfinding::AIPath*& dyn_aiPath();
    // Get instance field reference: private Pathfinding.AILerp aiLerp
    [[deprecated("Use field access instead!")]] ::Pathfinding::AILerp*& dyn_aiLerp();
    // Get instance field reference: private Pathfinding.Seeker seeker
    [[deprecated("Use field access instead!")]] ::Pathfinding::Seeker*& dyn_seeker();
    // Get instance field reference: private Pathfinding.Path path
    [[deprecated("Use field access instead!")]] ::Pathfinding::Path*& dyn_path();
    // Get instance field reference: private System.Int32 currentWaypoint
    [[deprecated("Use field access instead!")]] int& dyn_currentWaypoint();
    // Get instance field reference: private System.Single nextWaypointDistance
    [[deprecated("Use field access instead!")]] float& dyn_nextWaypointDistance();
    // Get instance field reference: private System.Boolean reachedEndOfPath
    [[deprecated("Use field access instead!")]] bool& dyn_reachedEndOfPath();
    // Get instance field reference: private System.Boolean calculatingPath
    [[deprecated("Use field access instead!")]] bool& dyn_calculatingPath();
    // Get instance field reference: private Monkeye_LazerFX lazerFx
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::Monkeye_LazerFX*& dyn_lazerFx();
    // Get instance field reference: private UnityEngine.Animator animController
    [[deprecated("Use field access instead!")]] ::UnityEngine::Animator*& dyn_animController();
    // Get instance field reference: private UnityEngine.RaycastHit[] rayResults
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::RaycastHit>& dyn_rayResults();
    // Get instance field reference: private UnityEngine.LayerMask layerMask
    [[deprecated("Use field access instead!")]] ::UnityEngine::LayerMask& dyn_layerMask();
    // Get instance field reference: private System.Boolean wasConnectedToRoom
    [[deprecated("Use field access instead!")]] bool& dyn_wasConnectedToRoom();
    // Get instance field reference: public UnityEngine.SkinnedMeshRenderer skinnedMeshRenderer
    [[deprecated("Use field access instead!")]] ::UnityEngine::SkinnedMeshRenderer*& dyn_skinnedMeshRenderer();
    // Get instance field reference: public MazePlayerCollection playerCollection
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::MazePlayerCollection*& dyn_playerCollection();
    // Get instance field reference: public PlayerCollection playersInRoomCollection
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::PlayerCollection*& dyn_playersInRoomCollection();
    // Get instance field reference: private System.Collections.Generic.List`1<VRRig> validRigs
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::GlobalNamespace::VRRig*>*& dyn_validRigs();
    // Get instance field reference: public UnityEngine.GameObject portalFx
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_portalFx();
    // Get instance field reference: public UnityEngine.Transform[] eyeBones
    [[deprecated("Use field access instead!")]] ::ArrayW<::UnityEngine::Transform*>& dyn_eyeBones();
    // Get instance field reference: public System.Single speed
    [[deprecated("Use field access instead!")]] float& dyn_speed();
    // Get instance field reference: public System.Single rotationSpeed
    [[deprecated("Use field access instead!")]] float& dyn_rotationSpeed();
    // Get instance field reference: public System.Single wakeDistance
    [[deprecated("Use field access instead!")]] float& dyn_wakeDistance();
    // Get instance field reference: public System.Single chaseDistance
    [[deprecated("Use field access instead!")]] float& dyn_chaseDistance();
    // Get instance field reference: public System.Single sleepDuration
    [[deprecated("Use field access instead!")]] float& dyn_sleepDuration();
    // Get instance field reference: public System.Single attackDistance
    [[deprecated("Use field access instead!")]] float& dyn_attackDistance();
    // Get instance field reference: public System.Single beginAttackTime
    [[deprecated("Use field access instead!")]] float& dyn_beginAttackTime();
    // Get instance field reference: public System.Single openFloorTime
    [[deprecated("Use field access instead!")]] float& dyn_openFloorTime();
    // Get instance field reference: public System.Single dropPlayerTime
    [[deprecated("Use field access instead!")]] float& dyn_dropPlayerTime();
    // Get instance field reference: public System.Single closeFloorTime
    [[deprecated("Use field access instead!")]] float& dyn_closeFloorTime();
    // Get instance field reference: public UnityEngine.Color portalColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_portalColor();
    // Get instance field reference: public UnityEngine.Color gorillaPortalColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_gorillaPortalColor();
    // Get instance field reference: public UnityEngine.Color monkEyeColor
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_monkEyeColor();
    // Get instance field reference: public UnityEngine.Color monkEyeEyeColorNormal
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_monkEyeEyeColorNormal();
    // Get instance field reference: public UnityEngine.Color monkEyeEyeColorAttacking
    [[deprecated("Use field access instead!")]] ::UnityEngine::Color& dyn_monkEyeEyeColorAttacking();
    // Get instance field reference: public System.Int32 maxPatrols
    [[deprecated("Use field access instead!")]] int& dyn_maxPatrols();
    // Get instance field reference: private VRRig targetRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRRig*& dyn_targetRig();
    // Get instance field reference: public MonkeyeAI_ReplState replState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::MonkeyeAI_ReplState*& dyn_replState();
    // Get instance field reference: private System.Int32 layerBase
    [[deprecated("Use field access instead!")]] int& dyn_layerBase();
    // Get instance field reference: private System.Int32 layerForward
    [[deprecated("Use field access instead!")]] int& dyn_layerForward();
    // Get instance field reference: private System.Int32 layerLeft
    [[deprecated("Use field access instead!")]] int& dyn_layerLeft();
    // Get instance field reference: private System.Int32 layerRight
    [[deprecated("Use field access instead!")]] int& dyn_layerRight();
    // Get instance field reference: private UnityEngine.Vector3 prevPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_prevPosition();
    // Get instance field reference: private UnityEngine.Vector3 velocity
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_velocity();
    // Get instance field reference: public UnityEngine.AudioSource audioSource
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_audioSource();
    // Get instance field reference: public UnityEngine.AudioClip sleepLoopSound
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioClip*& dyn_sleepLoopSound();
    // Get instance field reference: public System.Single sleepLoopVolume
    [[deprecated("Use field access instead!")]] float& dyn_sleepLoopVolume();
    // Get instance field reference: public UnityEngine.AudioClip patrolLoopSound
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioClip*& dyn_patrolLoopSound();
    // Get instance field reference: public System.Single patrolLoopVolume
    [[deprecated("Use field access instead!")]] float& dyn_patrolLoopVolume();
    // Get instance field reference: public System.Single patrolLoopFadeInTime
    [[deprecated("Use field access instead!")]] float& dyn_patrolLoopFadeInTime();
    // Get instance field reference: public UnityEngine.AudioClip chaseLoopSound
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioClip*& dyn_chaseLoopSound();
    // Get instance field reference: public System.Single chaseLoopVolume
    [[deprecated("Use field access instead!")]] float& dyn_chaseLoopVolume();
    // Get instance field reference: public System.Single chaseLoopFadeInTime
    [[deprecated("Use field access instead!")]] float& dyn_chaseLoopFadeInTime();
    // Get instance field reference: public UnityEngine.AudioClip attackSound
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioClip*& dyn_attackSound();
    // Get instance field reference: public System.Single attackVolume
    [[deprecated("Use field access instead!")]] float& dyn_attackVolume();
    // Get instance field reference: private Photon.Pun.PhotonView _view
    [[deprecated("Use field access instead!")]] ::Photon::Pun::PhotonView*& dyn__view();
    // Get instance field reference: public System.Single overlapRadius
    [[deprecated("Use field access instead!")]] float& dyn_overlapRadius();
    // Get instance field reference: private System.Boolean lockedOn
    [[deprecated("Use field access instead!")]] bool& dyn_lockedOn();
    // private System.String UserIdFromRig(VRRig rig)
    // Offset: 0x268F97C
    ::StringW UserIdFromRig(::GlobalNamespace::VRRig* rig);
    // private VRRig GetRig(System.String userId)
    // Offset: 0x268FB44
    ::GlobalNamespace::VRRig* GetRig(::StringW userId);
    // private System.Single Distance2D(UnityEngine.Vector3 a, UnityEngine.Vector3 b)
    // Offset: 0x2690104
    float Distance2D(::UnityEngine::Vector3 a, ::UnityEngine::Vector3 b);
    // private UnityEngine.Transform PickRandomPatrolPoint()
    // Offset: 0x2690180
    ::UnityEngine::Transform* PickRandomPatrolPoint();
    // private System.Void PickNewPath(System.Boolean pathFinished)
    // Offset: 0x2690208
    void PickNewPath(bool pathFinished);
    // private System.Void Awake()
    // Offset: 0x269099C
    void Awake();
    // private System.Void OnPathComplete(Pathfinding.Path path_)
    // Offset: 0x2690DC8
    void OnPathComplete(::Pathfinding::Path* path_);
    // private System.Void FollowPath()
    // Offset: 0x2690F34
    void FollowPath();
    // private System.Boolean PlayerNear(VRRig rig, System.Single dist, out System.Single playerDist)
    // Offset: 0x269136C
    bool PlayerNear(::GlobalNamespace::VRRig* rig, float dist, ByRef<float> playerDist);
    // private System.Void Sleeping()
    // Offset: 0x269162C
    void Sleeping();
    // private System.Boolean ClosestPlayer(in UnityEngine.Vector3 myPos, out VRRig outRig)
    // Offset: 0x26906FC
    bool ClosestPlayer(ByRef<::UnityEngine::Vector3> myPos, ByRef<::GlobalNamespace::VRRig*> outRig);
    // private System.Boolean CheckForChase()
    // Offset: 0x26916D4
    bool CheckForChase();
    // public System.Void SetChasePlayer(VRRig rig)
    // Offset: 0x269186C
    void SetChasePlayer(::GlobalNamespace::VRRig* rig);
    // public System.Void SetSleep()
    // Offset: 0x2691904
    void SetSleep();
    // private System.Void Patrolling()
    // Offset: 0x2691938
    void Patrolling();
    // private System.Void Chasing()
    // Offset: 0x26919E4
    void Chasing();
    // private System.Void ReturnToSleepPt()
    // Offset: 0x2691B3C
    void ReturnToSleepPt();
    // private System.Void UpdateClientState()
    // Offset: 0x2691C00
    void UpdateClientState();
    // private System.Void SetDefaultState()
    // Offset: 0x26920D4
    void SetDefaultState();
    // private System.Void SetDefaultAttackState()
    // Offset: 0x2690D2C
    void SetDefaultAttackState();
    // private System.Void ExitAttackState()
    // Offset: 0x26920F0
    void ExitAttackState();
    // private System.Void BeginAttack()
    // Offset: 0x269210C
    void BeginAttack();
    // private System.Void OpenFloor()
    // Offset: 0x269219C
    void OpenFloor();
    // private System.Void DropPlayer()
    // Offset: 0x269220C
    void DropPlayer();
    // private System.Void CloseFloor()
    // Offset: 0x269224C
    void CloseFloor();
    // private System.Void ValidateChasingRig()
    // Offset: 0x2692288
    void ValidateChasingRig();
    // public System.Void SetState(MonkeyeAI_ReplState/EStates state_)
    // Offset: 0x2690488
    void SetState(::GlobalNamespace::MonkeyeAI_ReplState::EStates state_);
    // private System.Void setEyeColor(UnityEngine.Color c)
    // Offset: 0x2692478
    void setEyeColor(::UnityEngine::Color c);
    // public System.Collections.Generic.List`1<VRRig> GetValidChoosableRigs()
    // Offset: 0x268FE68
    ::System::Collections::Generic::List_1<::GlobalNamespace::VRRig*>* GetValidChoosableRigs();
    // private System.Void Update()
    // Offset: 0x2692548
    void Update();
    // protected System.Void LateUpdate()
    // Offset: 0x2692A04
    void LateUpdate();
    // private System.Void AntiOverlapAssurance()
    // Offset: 0x2692A64
    void AntiOverlapAssurance();
    // private System.Void SetTargetPlayer(VRRig rig)
    // Offset: 0x26908B0
    void SetTargetPlayer(::GlobalNamespace::VRRig* rig);
    // public System.Void .ctor()
    // Offset: 0x2692E40
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static MonkeyeAI* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::MonkeyeAI::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<MonkeyeAI*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0x2692F64
    static void _cctor();
  }; // MonkeyeAI
  #pragma pack(pop)
  static check_size<sizeof(MonkeyeAI), 500 + sizeof(bool)> __GlobalNamespace_MonkeyeAISizeCheck;
  static_assert(sizeof(MonkeyeAI) == 0x1F5);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::UserIdFromRig
// Il2CppName: UserIdFromRig
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (GlobalNamespace::MonkeyeAI::*)(::GlobalNamespace::VRRig*)>(&GlobalNamespace::MonkeyeAI::UserIdFromRig)> {
  static const MethodInfo* get() {
    static auto* rig = &::il2cpp_utils::GetClassFromName("", "VRRig")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "UserIdFromRig", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{rig});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::GetRig
// Il2CppName: GetRig
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::VRRig* (GlobalNamespace::MonkeyeAI::*)(::StringW)>(&GlobalNamespace::MonkeyeAI::GetRig)> {
  static const MethodInfo* get() {
    static auto* userId = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "GetRig", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{userId});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::Distance2D
// Il2CppName: Distance2D
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GlobalNamespace::MonkeyeAI::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&GlobalNamespace::MonkeyeAI::Distance2D)> {
  static const MethodInfo* get() {
    static auto* a = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* b = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "Distance2D", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, b});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::PickRandomPatrolPoint
// Il2CppName: PickRandomPatrolPoint
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Transform* (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::PickRandomPatrolPoint)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "PickRandomPatrolPoint", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::PickNewPath
// Il2CppName: PickNewPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)(bool)>(&GlobalNamespace::MonkeyeAI::PickNewPath)> {
  static const MethodInfo* get() {
    static auto* pathFinished = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "PickNewPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pathFinished});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::OnPathComplete
// Il2CppName: OnPathComplete
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)(::Pathfinding::Path*)>(&GlobalNamespace::MonkeyeAI::OnPathComplete)> {
  static const MethodInfo* get() {
    static auto* path_ = &::il2cpp_utils::GetClassFromName("Pathfinding", "Path")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "OnPathComplete", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{path_});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::FollowPath
// Il2CppName: FollowPath
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::FollowPath)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "FollowPath", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::PlayerNear
// Il2CppName: PlayerNear
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::MonkeyeAI::*)(::GlobalNamespace::VRRig*, float, ByRef<float>)>(&GlobalNamespace::MonkeyeAI::PlayerNear)> {
  static const MethodInfo* get() {
    static auto* rig = &::il2cpp_utils::GetClassFromName("", "VRRig")->byval_arg;
    static auto* dist = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* playerDist = &::il2cpp_utils::GetClassFromName("System", "Single")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "PlayerNear", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{rig, dist, playerDist});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::Sleeping
// Il2CppName: Sleeping
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::Sleeping)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "Sleeping", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::ClosestPlayer
// Il2CppName: ClosestPlayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::MonkeyeAI::*)(ByRef<::UnityEngine::Vector3>, ByRef<::GlobalNamespace::VRRig*>)>(&GlobalNamespace::MonkeyeAI::ClosestPlayer)> {
  static const MethodInfo* get() {
    static auto* myPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* outRig = &::il2cpp_utils::GetClassFromName("", "VRRig")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "ClosestPlayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{myPos, outRig});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::CheckForChase
// Il2CppName: CheckForChase
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::CheckForChase)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "CheckForChase", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::SetChasePlayer
// Il2CppName: SetChasePlayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)(::GlobalNamespace::VRRig*)>(&GlobalNamespace::MonkeyeAI::SetChasePlayer)> {
  static const MethodInfo* get() {
    static auto* rig = &::il2cpp_utils::GetClassFromName("", "VRRig")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "SetChasePlayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{rig});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::SetSleep
// Il2CppName: SetSleep
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::SetSleep)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "SetSleep", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::Patrolling
// Il2CppName: Patrolling
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::Patrolling)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "Patrolling", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::Chasing
// Il2CppName: Chasing
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::Chasing)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "Chasing", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::ReturnToSleepPt
// Il2CppName: ReturnToSleepPt
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::ReturnToSleepPt)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "ReturnToSleepPt", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::UpdateClientState
// Il2CppName: UpdateClientState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::UpdateClientState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "UpdateClientState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::SetDefaultState
// Il2CppName: SetDefaultState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::SetDefaultState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "SetDefaultState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::SetDefaultAttackState
// Il2CppName: SetDefaultAttackState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::SetDefaultAttackState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "SetDefaultAttackState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::ExitAttackState
// Il2CppName: ExitAttackState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::ExitAttackState)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "ExitAttackState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::BeginAttack
// Il2CppName: BeginAttack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::BeginAttack)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "BeginAttack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::OpenFloor
// Il2CppName: OpenFloor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::OpenFloor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "OpenFloor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::DropPlayer
// Il2CppName: DropPlayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::DropPlayer)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "DropPlayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::CloseFloor
// Il2CppName: CloseFloor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::CloseFloor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "CloseFloor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::ValidateChasingRig
// Il2CppName: ValidateChasingRig
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::ValidateChasingRig)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "ValidateChasingRig", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::SetState
// Il2CppName: SetState
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)(::GlobalNamespace::MonkeyeAI_ReplState::EStates)>(&GlobalNamespace::MonkeyeAI::SetState)> {
  static const MethodInfo* get() {
    static auto* state_ = &::il2cpp_utils::GetClassFromName("", "MonkeyeAI_ReplState/EStates")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "SetState", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{state_});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::setEyeColor
// Il2CppName: setEyeColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)(::UnityEngine::Color)>(&GlobalNamespace::MonkeyeAI::setEyeColor)> {
  static const MethodInfo* get() {
    static auto* c = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "setEyeColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{c});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::GetValidChoosableRigs
// Il2CppName: GetValidChoosableRigs
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::Generic::List_1<::GlobalNamespace::VRRig*>* (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::GetValidChoosableRigs)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "GetValidChoosableRigs", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::AntiOverlapAssurance
// Il2CppName: AntiOverlapAssurance
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)()>(&GlobalNamespace::MonkeyeAI::AntiOverlapAssurance)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "AntiOverlapAssurance", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::SetTargetPlayer
// Il2CppName: SetTargetPlayer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::MonkeyeAI::*)(::GlobalNamespace::VRRig*)>(&GlobalNamespace::MonkeyeAI::SetTargetPlayer)> {
  static const MethodInfo* get() {
    static auto* rig = &::il2cpp_utils::GetClassFromName("", "VRRig")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), "SetTargetPlayer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{rig});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::MonkeyeAI::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&GlobalNamespace::MonkeyeAI::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::MonkeyeAI*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
