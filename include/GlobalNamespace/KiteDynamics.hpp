// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: ITetheredObjectBehavior
#include "GlobalNamespace/ITetheredObjectBehavior.hpp"
// Including type: UnityEngine.Bounds
#include "UnityEngine/Bounds.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: Collider
  class Collider;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Transform
  class Transform;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: KiteDynamics
  class KiteDynamics;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::KiteDynamics);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::KiteDynamics*, "", "KiteDynamics");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0xC0
  #pragma pack(push, 1)
  // Autogenerated type: KiteDynamics
  // [TokenAttribute] Offset: FFFFFFFF
  class KiteDynamics : public ::UnityEngine::MonoBehaviour/*, public ::GlobalNamespace::ITetheredObjectBehavior*/ {
    public:
    public:
    // private UnityEngine.Rigidbody rb
    // Size: 0x8
    // Offset: 0x20
    ::UnityEngine::Rigidbody* rb;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // private UnityEngine.Collider balloonCollider
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Collider* balloonCollider;
    // Field size check
    static_assert(sizeof(::UnityEngine::Collider*) == 0x8);
    // private UnityEngine.Bounds bounds
    // Size: 0x18
    // Offset: 0x30
    ::UnityEngine::Bounds bounds;
    // Field size check
    static_assert(sizeof(::UnityEngine::Bounds) == 0x18);
    // private System.Single bouyancyForce
    // Size: 0x4
    // Offset: 0x48
    float bouyancyForce;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single bouyancyMinHeight
    // Size: 0x4
    // Offset: 0x4C
    float bouyancyMinHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single bouyancyMaxHeight
    // Size: 0x4
    // Offset: 0x50
    float bouyancyMaxHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single bouyancyActualHeight
    // Size: 0x4
    // Offset: 0x54
    float bouyancyActualHeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single varianceMaxheight
    // Size: 0x4
    // Offset: 0x58
    float varianceMaxheight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single airResistance
    // Size: 0x4
    // Offset: 0x5C
    float airResistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.GameObject knot
    // Size: 0x8
    // Offset: 0x60
    ::UnityEngine::GameObject* knot;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private UnityEngine.Rigidbody knotRb
    // Size: 0x8
    // Offset: 0x68
    ::UnityEngine::Rigidbody* knotRb;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // public UnityEngine.Transform grabPt
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::Transform* grabPt;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private UnityEngine.Transform grabPtInitParent
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::Transform* grabPtInitParent;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Single stringLength
    // Size: 0x4
    // Offset: 0x80
    float stringLength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single stringStrength
    // Size: 0x4
    // Offset: 0x84
    float stringStrength;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single stringStretch
    // Size: 0x4
    // Offset: 0x88
    float stringStretch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single maximumVelocity
    // Size: 0x4
    // Offset: 0x8C
    float maximumVelocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single upRightTorque
    // Size: 0x4
    // Offset: 0x90
    float upRightTorque;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean enableDynamics
    // Size: 0x1
    // Offset: 0x94
    bool enableDynamics;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean held
    // Size: 0x1
    // Offset: 0x95
    bool held;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: held and: balloonScale
    char __padding19[0x2] = {};
    // private System.Single balloonScale
    // Size: 0x4
    // Offset: 0x98
    float balloonScale;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single bopSpeed
    // Size: 0x4
    // Offset: 0x9C
    float bopSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 grabPtPosition
    // Size: 0xC
    // Offset: 0xA0
    ::UnityEngine::Vector3 grabPtPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion ctrlRotation
    // Size: 0x10
    // Offset: 0xAC
    ::UnityEngine::Quaternion ctrlRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private System.Single returnSpeed
    // Size: 0x4
    // Offset: 0xBC
    float returnSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    public:
    // Creating interface conversion operator: operator ::GlobalNamespace::ITetheredObjectBehavior
    operator ::GlobalNamespace::ITetheredObjectBehavior() noexcept {
      return *reinterpret_cast<::GlobalNamespace::ITetheredObjectBehavior*>(this);
    }
    // Get instance field reference: private UnityEngine.Rigidbody rb
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_rb();
    // Get instance field reference: private UnityEngine.Collider balloonCollider
    [[deprecated("Use field access instead!")]] ::UnityEngine::Collider*& dyn_balloonCollider();
    // Get instance field reference: private UnityEngine.Bounds bounds
    [[deprecated("Use field access instead!")]] ::UnityEngine::Bounds& dyn_bounds();
    // Get instance field reference: private System.Single bouyancyForce
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyForce();
    // Get instance field reference: private System.Single bouyancyMinHeight
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyMinHeight();
    // Get instance field reference: private System.Single bouyancyMaxHeight
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyMaxHeight();
    // Get instance field reference: private System.Single bouyancyActualHeight
    [[deprecated("Use field access instead!")]] float& dyn_bouyancyActualHeight();
    // Get instance field reference: private System.Single varianceMaxheight
    [[deprecated("Use field access instead!")]] float& dyn_varianceMaxheight();
    // Get instance field reference: private System.Single airResistance
    [[deprecated("Use field access instead!")]] float& dyn_airResistance();
    // Get instance field reference: public UnityEngine.GameObject knot
    [[deprecated("Use field access instead!")]] ::UnityEngine::GameObject*& dyn_knot();
    // Get instance field reference: private UnityEngine.Rigidbody knotRb
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_knotRb();
    // Get instance field reference: public UnityEngine.Transform grabPt
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_grabPt();
    // Get instance field reference: private UnityEngine.Transform grabPtInitParent
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_grabPtInitParent();
    // Get instance field reference: private System.Single stringLength
    [[deprecated("Use field access instead!")]] float& dyn_stringLength();
    // Get instance field reference: private System.Single stringStrength
    [[deprecated("Use field access instead!")]] float& dyn_stringStrength();
    // Get instance field reference: private System.Single stringStretch
    [[deprecated("Use field access instead!")]] float& dyn_stringStretch();
    // Get instance field reference: private System.Single maximumVelocity
    [[deprecated("Use field access instead!")]] float& dyn_maximumVelocity();
    // Get instance field reference: private System.Single upRightTorque
    [[deprecated("Use field access instead!")]] float& dyn_upRightTorque();
    // Get instance field reference: private System.Boolean enableDynamics
    [[deprecated("Use field access instead!")]] bool& dyn_enableDynamics();
    // Get instance field reference: private System.Boolean held
    [[deprecated("Use field access instead!")]] bool& dyn_held();
    // Get instance field reference: private System.Single balloonScale
    [[deprecated("Use field access instead!")]] float& dyn_balloonScale();
    // Get instance field reference: private System.Single bopSpeed
    [[deprecated("Use field access instead!")]] float& dyn_bopSpeed();
    // Get instance field reference: private UnityEngine.Vector3 grabPtPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_grabPtPosition();
    // Get instance field reference: private UnityEngine.Quaternion ctrlRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_ctrlRotation();
    // Get instance field reference: private System.Single returnSpeed
    [[deprecated("Use field access instead!")]] float& dyn_returnSpeed();
    // private System.Void Awake()
    // Offset: 0x296A364
    void Awake();
    // private System.Void Start()
    // Offset: 0x296A470
    void Start();
    // public System.Void ReParent()
    // Offset: 0x296A4B0
    void ReParent();
    // public System.Void EnableDynamics(System.Boolean enable, System.Boolean kinematic)
    // Offset: 0x296A568
    void EnableDynamics(bool enable, bool kinematic);
    // public System.Void EnableDistanceConstraints(System.Boolean enable, System.Single scale)
    // Offset: 0x296A6E0
    void EnableDistanceConstraints(bool enable, float scale);
    // public System.Boolean get_ColliderEnabled()
    // Offset: 0x296A73C
    bool get_ColliderEnabled();
    // private System.Void FixedUpdate()
    // Offset: 0x296A7C0
    void FixedUpdate();
    // private System.Void ITetheredObjectBehavior.DbgClear()
    // Offset: 0x296AA54
    void ITetheredObjectBehavior_DbgClear();
    // private System.Boolean ITetheredObjectBehavior.IsEnabled()
    // Offset: 0x296AA8C
    bool ITetheredObjectBehavior_IsEnabled();
    // private System.Void ITetheredObjectBehavior.TriggerEnter(UnityEngine.Collider other, ref UnityEngine.Vector3 force, ref UnityEngine.Vector3 collisionPt, ref System.Boolean transferOwnership)
    // Offset: 0x296AA94
    void ITetheredObjectBehavior_TriggerEnter(::UnityEngine::Collider* other, ByRef<::UnityEngine::Vector3> force, ByRef<::UnityEngine::Vector3> collisionPt, ByRef<bool> transferOwnership);
    // public System.Boolean ReturnStep()
    // Offset: 0x296AA9C
    bool ReturnStep();
    // public System.Void .ctor()
    // Offset: 0x296AC9C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static KiteDynamics* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::KiteDynamics::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<KiteDynamics*, creationType>()));
    }
  }; // KiteDynamics
  #pragma pack(pop)
  static check_size<sizeof(KiteDynamics), 188 + sizeof(float)> __GlobalNamespace_KiteDynamicsSizeCheck;
  static_assert(sizeof(KiteDynamics) == 0xC0);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::Start
// Il2CppName: Start
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::Start)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "Start", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::ReParent
// Il2CppName: ReParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::ReParent)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "ReParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::EnableDynamics
// Il2CppName: EnableDynamics
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)(bool, bool)>(&GlobalNamespace::KiteDynamics::EnableDynamics)> {
  static const MethodInfo* get() {
    static auto* enable = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* kinematic = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "EnableDynamics", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{enable, kinematic});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::EnableDistanceConstraints
// Il2CppName: EnableDistanceConstraints
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)(bool, float)>(&GlobalNamespace::KiteDynamics::EnableDistanceConstraints)> {
  static const MethodInfo* get() {
    static auto* enable = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* scale = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "EnableDistanceConstraints", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{enable, scale});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::get_ColliderEnabled
// Il2CppName: get_ColliderEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::get_ColliderEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "get_ColliderEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::ITetheredObjectBehavior_DbgClear
// Il2CppName: ITetheredObjectBehavior.DbgClear
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::ITetheredObjectBehavior_DbgClear)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "ITetheredObjectBehavior.DbgClear", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::ITetheredObjectBehavior_IsEnabled
// Il2CppName: ITetheredObjectBehavior.IsEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::ITetheredObjectBehavior_IsEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "ITetheredObjectBehavior.IsEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::ITetheredObjectBehavior_TriggerEnter
// Il2CppName: ITetheredObjectBehavior.TriggerEnter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::KiteDynamics::*)(::UnityEngine::Collider*, ByRef<::UnityEngine::Vector3>, ByRef<::UnityEngine::Vector3>, ByRef<bool>)>(&GlobalNamespace::KiteDynamics::ITetheredObjectBehavior_TriggerEnter)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    static auto* force = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* collisionPt = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* transferOwnership = &::il2cpp_utils::GetClassFromName("System", "Boolean")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "ITetheredObjectBehavior.TriggerEnter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other, force, collisionPt, transferOwnership});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::ReturnStep
// Il2CppName: ReturnStep
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::KiteDynamics::*)()>(&GlobalNamespace::KiteDynamics::ReturnStep)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::KiteDynamics*), "ReturnStep", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::KiteDynamics::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
