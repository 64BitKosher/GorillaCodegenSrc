// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: HoldableObject
#include "GlobalNamespace/HoldableObject.hpp"
// Including type: Photon.Pun.IPunObservable
#include "Photon/Pun/IPunObservable.hpp"
// Including type: IRequestableOwnershipGuardCallbacks
#include "GlobalNamespace/IRequestableOwnershipGuardCallbacks.hpp"
// Including type: UnityEngine.Vector2
#include "UnityEngine/Vector2.hpp"
// Including type: System.Nullable`1
#include "System/Nullable_1.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: VRRig
  class VRRig;
  // Forward declaring type: AverageVector3
  class AverageVector3;
  // Forward declaring type: InteractionPoint
  class InteractionPoint;
  // Forward declaring type: RequestableOwnershipGuard
  class RequestableOwnershipGuard;
  // Forward declaring type: DropZone
  class DropZone;
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Rigidbody
  class Rigidbody;
  // Forward declaring type: Transform
  class Transform;
  // Forward declaring type: AnimationCurve
  class AnimationCurve;
  // Forward declaring type: MeshRenderer
  class MeshRenderer;
  // Forward declaring type: Material
  class Material;
  // Forward declaring type: AudioSource
  class AudioSource;
  // Forward declaring type: Coroutine
  class Coroutine;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Collider
  class Collider;
}
// Forward declaring namespace: Photon::Pun
namespace Photon::Pun {
  // Forward declaring type: PhotonStream
  class PhotonStream;
  // Forward declaring type: PhotonMessageInfo
  struct PhotonMessageInfo;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Forward declaring namespace: Photon::Realtime
namespace Photon::Realtime {
  // Forward declaring type: Player
  class Player;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: GliderHoldable
  class GliderHoldable;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::GliderHoldable);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::GliderHoldable*, "", "GliderHoldable");
// Type namespace: 
namespace GlobalNamespace {
  // WARNING Size may be invalid!
  // Autogenerated type: GliderHoldable
  // [TokenAttribute] Offset: FFFFFFFF
  // [RequireComponent] Offset: FFFFFFFF
  class GliderHoldable : public ::GlobalNamespace::HoldableObject/*, public ::Photon::Pun::IPunObservable, public ::GlobalNamespace::IRequestableOwnershipGuardCallbacks*/ {
    public:
    // Nested type: ::GlobalNamespace::GliderHoldable::GliderState
    struct GliderState;
    // Nested type: ::GlobalNamespace::GliderHoldable::HoldingHand
    struct HoldingHand;
    // Nested type: ::GlobalNamespace::GliderHoldable::SyncedState
    struct SyncedState;
    // Nested type: ::GlobalNamespace::GliderHoldable::CosmeticMaterialOverride
    struct CosmeticMaterialOverride;
    // Nested type: ::GlobalNamespace::GliderHoldable::$ReenableOwnershipRequest$d__169
    class $ReenableOwnershipRequest$d__169;
    // Size: 0x4
    #pragma pack(push, 1)
    // Autogenerated type: GliderHoldable/GliderState
    // [TokenAttribute] Offset: FFFFFFFF
    struct GliderState/*, public ::System::Enum*/ {
      public:
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x0
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: GliderState
      constexpr GliderState(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public GliderHoldable/GliderState LocallyHeld
      static constexpr const int LocallyHeld = 0;
      // Get static field: static public GliderHoldable/GliderState LocallyHeld
      static ::GlobalNamespace::GliderHoldable::GliderState _get_LocallyHeld();
      // Set static field: static public GliderHoldable/GliderState LocallyHeld
      static void _set_LocallyHeld(::GlobalNamespace::GliderHoldable::GliderState value);
      // static field const value: static public GliderHoldable/GliderState LocallyDropped
      static constexpr const int LocallyDropped = 1;
      // Get static field: static public GliderHoldable/GliderState LocallyDropped
      static ::GlobalNamespace::GliderHoldable::GliderState _get_LocallyDropped();
      // Set static field: static public GliderHoldable/GliderState LocallyDropped
      static void _set_LocallyDropped(::GlobalNamespace::GliderHoldable::GliderState value);
      // static field const value: static public GliderHoldable/GliderState RemoteSyncing
      static constexpr const int RemoteSyncing = 2;
      // Get static field: static public GliderHoldable/GliderState RemoteSyncing
      static ::GlobalNamespace::GliderHoldable::GliderState _get_RemoteSyncing();
      // Set static field: static public GliderHoldable/GliderState RemoteSyncing
      static void _set_RemoteSyncing(::GlobalNamespace::GliderHoldable::GliderState value);
      // Get instance field reference: public System.Int32 value__
      [[deprecated("Use field access instead!")]] int& dyn_value__();
    }; // GliderHoldable/GliderState
    #pragma pack(pop)
    static check_size<sizeof(GliderHoldable::GliderState), 0 + sizeof(int)> __GlobalNamespace_GliderHoldable_GliderStateSizeCheck;
    static_assert(sizeof(GliderHoldable::GliderState) == 0x4);
    // Size: 0x38
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: GliderHoldable/HoldingHand
    // [TokenAttribute] Offset: FFFFFFFF
    struct HoldingHand/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Boolean active
      // Size: 0x1
      // Offset: 0x0
      bool active;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // Padding between fields: active and: transform
      char __padding0[0x7] = {};
      // public UnityEngine.Transform transform
      // Size: 0x8
      // Offset: 0x8
      ::UnityEngine::Transform* transform;
      // Field size check
      static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
      // public UnityEngine.Vector3 holdLocalPos
      // Size: 0xC
      // Offset: 0x10
      ::UnityEngine::Vector3 holdLocalPos;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Vector3 handleLocalPos
      // Size: 0xC
      // Offset: 0x1C
      ::UnityEngine::Vector3 handleLocalPos;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Quaternion localHoldRotation
      // Size: 0x10
      // Offset: 0x28
      ::UnityEngine::Quaternion localHoldRotation;
      // Field size check
      static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
      public:
      // Creating value type constructor for type: HoldingHand
      constexpr HoldingHand(bool active_ = {}, ::UnityEngine::Transform* transform_ = {}, ::UnityEngine::Vector3 holdLocalPos_ = {}, ::UnityEngine::Vector3 handleLocalPos_ = {}, ::UnityEngine::Quaternion localHoldRotation_ = {}) noexcept : active{active_}, transform{transform_}, holdLocalPos{holdLocalPos_}, handleLocalPos{handleLocalPos_}, localHoldRotation{localHoldRotation_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Boolean active
      [[deprecated("Use field access instead!")]] bool& dyn_active();
      // Get instance field reference: public UnityEngine.Transform transform
      [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_transform();
      // Get instance field reference: public UnityEngine.Vector3 holdLocalPos
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_holdLocalPos();
      // Get instance field reference: public UnityEngine.Vector3 handleLocalPos
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_handleLocalPos();
      // Get instance field reference: public UnityEngine.Quaternion localHoldRotation
      [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_localHoldRotation();
      // public System.Void Activate(UnityEngine.Transform handTransform, UnityEngine.Transform gliderTransform, UnityEngine.Vector3 worldGrabPoint)
      // Offset: 0x275D230
      void Activate(::UnityEngine::Transform* handTransform, ::UnityEngine::Transform* gliderTransform, ::UnityEngine::Vector3 worldGrabPoint);
      // public System.Void Deactivate()
      // Offset: 0x275D9C0
      void Deactivate();
    }; // GliderHoldable/HoldingHand
    #pragma pack(pop)
    static check_size<sizeof(GliderHoldable::HoldingHand), 40 + sizeof(::UnityEngine::Quaternion)> __GlobalNamespace_GliderHoldable_HoldingHandSizeCheck;
    static_assert(sizeof(GliderHoldable::HoldingHand) == 0x38);
    // Size: 0x24
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: GliderHoldable/SyncedState
    // [TokenAttribute] Offset: FFFFFFFF
    struct SyncedState/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Int32 riderId
      // Size: 0x4
      // Offset: 0x0
      int riderId;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Byte materialIndex
      // Size: 0x1
      // Offset: 0x4
      uint8_t materialIndex;
      // Field size check
      static_assert(sizeof(uint8_t) == 0x1);
      // public System.Byte audioLevel
      // Size: 0x1
      // Offset: 0x5
      uint8_t audioLevel;
      // Field size check
      static_assert(sizeof(uint8_t) == 0x1);
      // public System.Boolean tagged
      // Size: 0x1
      // Offset: 0x6
      bool tagged;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      // Padding between fields: tagged and: position
      char __padding3[0x1] = {};
      // public UnityEngine.Vector3 position
      // Size: 0xC
      // Offset: 0x8
      ::UnityEngine::Vector3 position;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Quaternion rotation
      // Size: 0x10
      // Offset: 0x14
      ::UnityEngine::Quaternion rotation;
      // Field size check
      static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
      public:
      // Creating value type constructor for type: SyncedState
      constexpr SyncedState(int riderId_ = {}, uint8_t materialIndex_ = {}, uint8_t audioLevel_ = {}, bool tagged_ = {}, ::UnityEngine::Vector3 position_ = {}, ::UnityEngine::Quaternion rotation_ = {}) noexcept : riderId{riderId_}, materialIndex{materialIndex_}, audioLevel{audioLevel_}, tagged{tagged_}, position{position_}, rotation{rotation_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.Int32 riderId
      [[deprecated("Use field access instead!")]] int& dyn_riderId();
      // Get instance field reference: public System.Byte materialIndex
      [[deprecated("Use field access instead!")]] uint8_t& dyn_materialIndex();
      // Get instance field reference: public System.Byte audioLevel
      [[deprecated("Use field access instead!")]] uint8_t& dyn_audioLevel();
      // Get instance field reference: public System.Boolean tagged
      [[deprecated("Use field access instead!")]] bool& dyn_tagged();
      // Get instance field reference: public UnityEngine.Vector3 position
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_position();
      // Get instance field reference: public UnityEngine.Quaternion rotation
      [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_rotation();
      // public System.Void Init(UnityEngine.Vector3 defaultPosition, UnityEngine.Quaternion defaultRotation)
      // Offset: 0x275BD8C
      void Init(::UnityEngine::Vector3 defaultPosition, ::UnityEngine::Quaternion defaultRotation);
    }; // GliderHoldable/SyncedState
    #pragma pack(pop)
    static check_size<sizeof(GliderHoldable::SyncedState), 20 + sizeof(::UnityEngine::Quaternion)> __GlobalNamespace_GliderHoldable_SyncedStateSizeCheck;
    static_assert(sizeof(GliderHoldable::SyncedState) == 0x24);
    // Size: 0x10
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: GliderHoldable/CosmeticMaterialOverride
    // [TokenAttribute] Offset: FFFFFFFF
    struct CosmeticMaterialOverride/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.String cosmeticName
      // Size: 0x8
      // Offset: 0x0
      ::StringW cosmeticName;
      // Field size check
      static_assert(sizeof(::StringW) == 0x8);
      // public UnityEngine.Material material
      // Size: 0x8
      // Offset: 0x8
      ::UnityEngine::Material* material;
      // Field size check
      static_assert(sizeof(::UnityEngine::Material*) == 0x8);
      public:
      // Creating value type constructor for type: CosmeticMaterialOverride
      constexpr CosmeticMaterialOverride(::StringW cosmeticName_ = {}, ::UnityEngine::Material* material_ = {}) noexcept : cosmeticName{cosmeticName_}, material{material_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.String cosmeticName
      [[deprecated("Use field access instead!")]] ::StringW& dyn_cosmeticName();
      // Get instance field reference: public UnityEngine.Material material
      [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn_material();
    }; // GliderHoldable/CosmeticMaterialOverride
    #pragma pack(pop)
    static check_size<sizeof(GliderHoldable::CosmeticMaterialOverride), 8 + sizeof(::UnityEngine::Material*)> __GlobalNamespace_GliderHoldable_CosmeticMaterialOverrideSizeCheck;
    static_assert(sizeof(GliderHoldable::CosmeticMaterialOverride) == 0x10);
    public:
    // private UnityEngine.Vector2 pitchMinMax
    // Size: 0x8
    // Offset: 0x28
    ::UnityEngine::Vector2 pitchMinMax;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private UnityEngine.Vector2 rollMinMax
    // Size: 0x8
    // Offset: 0x30
    ::UnityEngine::Vector2 rollMinMax;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single pitchHalfLife
    // Size: 0x4
    // Offset: 0x38
    float pitchHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single yawHalfLife
    // Size: 0x4
    // Offset: 0x3C
    float yawHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single rollHalfLife
    // Size: 0x4
    // Offset: 0x40
    float rollHalfLife;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single yawRateFactor
    // Size: 0x4
    // Offset: 0x44
    float yawRateFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single yawRateFactorRollOnly
    // Size: 0x4
    // Offset: 0x48
    float yawRateFactorRollOnly;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Vector2 pitchVelocityTargetMinMax
    // Size: 0x8
    // Offset: 0x4C
    ::UnityEngine::Vector2 pitchVelocityTargetMinMax;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // public UnityEngine.Vector2 pitchVelocityRampTimeMinMax
    // Size: 0x8
    // Offset: 0x54
    ::UnityEngine::Vector2 pitchVelocityRampTimeMinMax;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single pitchVelocityFollowRateAngle
    // Size: 0x4
    // Offset: 0x5C
    float pitchVelocityFollowRateAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single pitchVelocityFollowRateMagnitude
    // Size: 0x4
    // Offset: 0x60
    float pitchVelocityFollowRateMagnitude;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single yawVelocityFollowRateAngle
    // Size: 0x4
    // Offset: 0x64
    float yawVelocityFollowRateAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single yawVelocityFollowRateMagnitude
    // Size: 0x4
    // Offset: 0x68
    float yawVelocityFollowRateMagnitude;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.AnimationCurve liftVsAttack
    // Size: 0x8
    // Offset: 0x70
    ::UnityEngine::AnimationCurve* liftVsAttack;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // private UnityEngine.AnimationCurve dragVsAttack
    // Size: 0x8
    // Offset: 0x78
    ::UnityEngine::AnimationCurve* dragVsAttack;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // public System.Single attackDragFactor
    // Size: 0x4
    // Offset: 0x80
    float attackDragFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.AnimationCurve dragVsSpeed
    // Size: 0x8
    // Offset: 0x88
    ::UnityEngine::AnimationCurve* dragVsSpeed;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // public System.Single dragVsSpeedMaxSpeed
    // Size: 0x4
    // Offset: 0x90
    float dragVsSpeedMaxSpeed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single dragVsSpeedDragFactor
    // Size: 0x4
    // Offset: 0x94
    float dragVsSpeedDragFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.AnimationCurve liftIncreaseVsRoll
    // Size: 0x8
    // Offset: 0x98
    ::UnityEngine::AnimationCurve* liftIncreaseVsRoll;
    // Field size check
    static_assert(sizeof(::UnityEngine::AnimationCurve*) == 0x8);
    // private System.Single liftIncreaseVsRollMaxAngle
    // Size: 0x4
    // Offset: 0xA0
    float liftIncreaseVsRollMaxAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single gravityCompensation
    // Size: 0x4
    // Offset: 0xA4
    float gravityCompensation;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single pullUpLiftBonus
    // Size: 0x4
    // Offset: 0xA8
    float pullUpLiftBonus;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single pullUpLiftActivationVelocity
    // Size: 0x4
    // Offset: 0xAC
    float pullUpLiftActivationVelocity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single pullUpLiftActivationAcceleration
    // Size: 0x4
    // Offset: 0xB0
    float pullUpLiftActivationAcceleration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single riderPosDirectPitchMax
    // Size: 0x4
    // Offset: 0xB4
    float riderPosDirectPitchMax;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector2 riderPosRange
    // Size: 0x8
    // Offset: 0xB8
    ::UnityEngine::Vector2 riderPosRange;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single riderPosRangeOffset
    // Size: 0x4
    // Offset: 0xC0
    float riderPosRangeOffset;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector2 riderPosRangeNormalizedDeadzone
    // Size: 0x8
    // Offset: 0xC4
    ::UnityEngine::Vector2 riderPosRangeNormalizedDeadzone;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single holdRotationAngleMax
    // Size: 0x4
    // Offset: 0xCC
    float holdRotationAngleMax;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single oneHandHoldRotationRate
    // Size: 0x4
    // Offset: 0xD0
    float oneHandHoldRotationRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 oneHandSimulatedHoldOffset
    // Size: 0xC
    // Offset: 0xD4
    ::UnityEngine::Vector3 oneHandSimulatedHoldOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single oneHandPitchMultiplier
    // Size: 0x4
    // Offset: 0xE0
    float oneHandPitchMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single twoHandHoldRotationRate
    // Size: 0x4
    // Offset: 0xE4
    float twoHandHoldRotationRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean twoHandGliderInversionOnYawInsteadOfRoll
    // Size: 0x1
    // Offset: 0xE8
    bool twoHandGliderInversionOnYawInsteadOfRoll;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean setMaxHandSlipDuringFlight
    // Size: 0x1
    // Offset: 0xE9
    bool setMaxHandSlipDuringFlight;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Single maxSlipOverrideSpeedThreshold
    // Size: 0x4
    // Offset: 0xEC
    float maxSlipOverrideSpeedThreshold;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single subtlePlayerPitchFactor
    // Size: 0x4
    // Offset: 0xF0
    float subtlePlayerPitchFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single subtlePlayerPitchRate
    // Size: 0x4
    // Offset: 0xF4
    float subtlePlayerPitchRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single subtlePlayerRollFactor
    // Size: 0x4
    // Offset: 0xF8
    float subtlePlayerRollFactor;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single subtlePlayerRollRate
    // Size: 0x4
    // Offset: 0xFC
    float subtlePlayerRollRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector2 subtlePlayerRotationSpeedRampMinMax
    // Size: 0x8
    // Offset: 0x100
    ::UnityEngine::Vector2 subtlePlayerRotationSpeedRampMinMax;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private UnityEngine.Vector2 subtlePlayerRollAccelMinMax
    // Size: 0x8
    // Offset: 0x108
    ::UnityEngine::Vector2 subtlePlayerRollAccelMinMax;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private UnityEngine.Vector2 subtlePlayerPitchAccelMinMax
    // Size: 0x8
    // Offset: 0x110
    ::UnityEngine::Vector2 subtlePlayerPitchAccelMinMax;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single accelSmoothingFollowRate
    // Size: 0x4
    // Offset: 0x118
    float accelSmoothingFollowRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single horizontalAccelSmoothingFollowRate
    // Size: 0x4
    // Offset: 0x11C
    float horizontalAccelSmoothingFollowRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector2 hapticAccelInputRange
    // Size: 0x8
    // Offset: 0x120
    ::UnityEngine::Vector2 hapticAccelInputRange;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single hapticAccelOutputMax
    // Size: 0x4
    // Offset: 0x128
    float hapticAccelOutputMax;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector2 hapticMaxSpeedInputRange
    // Size: 0x8
    // Offset: 0x12C
    ::UnityEngine::Vector2 hapticMaxSpeedInputRange;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private UnityEngine.Vector2 hapticSpeedInputRange
    // Size: 0x8
    // Offset: 0x134
    ::UnityEngine::Vector2 hapticSpeedInputRange;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single hapticSpeedOutputMax
    // Size: 0x4
    // Offset: 0x13C
    float hapticSpeedOutputMax;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector2 whistlingAudioSpeedInputRange
    // Size: 0x8
    // Offset: 0x140
    ::UnityEngine::Vector2 whistlingAudioSpeedInputRange;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single audioVolumeMultiplier
    // Size: 0x4
    // Offset: 0x148
    float audioVolumeMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single infectedAudioVolumeMultiplier
    // Size: 0x4
    // Offset: 0x14C
    float infectedAudioVolumeMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector2 whooshSpeedThresholdInput
    // Size: 0x8
    // Offset: 0x150
    ::UnityEngine::Vector2 whooshSpeedThresholdInput;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private UnityEngine.Vector2 whooshVolumeOutput
    // Size: 0x8
    // Offset: 0x158
    ::UnityEngine::Vector2 whooshVolumeOutput;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Single whooshCheckDistance
    // Size: 0x4
    // Offset: 0x160
    float whooshCheckDistance;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean extendTagRangeInFlight
    // Size: 0x1
    // Offset: 0x164
    bool extendTagRangeInFlight;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private UnityEngine.Vector2 tagRangeSpeedInput
    // Size: 0x8
    // Offset: 0x168
    ::UnityEngine::Vector2 tagRangeSpeedInput;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private UnityEngine.Vector2 tagRangeOutput
    // Size: 0x8
    // Offset: 0x170
    ::UnityEngine::Vector2 tagRangeOutput;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private System.Boolean debugDrawTagRange
    // Size: 0x1
    // Offset: 0x178
    bool debugDrawTagRange;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Single infectedSpeedIncrease
    // Size: 0x4
    // Offset: 0x17C
    float infectedSpeedIncrease;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.MeshRenderer leafMesh
    // Size: 0x8
    // Offset: 0x180
    ::UnityEngine::MeshRenderer* leafMesh;
    // Field size check
    static_assert(sizeof(::UnityEngine::MeshRenderer*) == 0x8);
    // private UnityEngine.Material baseLeafMaterial
    // Size: 0x8
    // Offset: 0x188
    ::UnityEngine::Material* baseLeafMaterial;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private UnityEngine.Material infectedLeafMaterial
    // Size: 0x8
    // Offset: 0x190
    ::UnityEngine::Material* infectedLeafMaterial;
    // Field size check
    static_assert(sizeof(::UnityEngine::Material*) == 0x8);
    // private GliderHoldable/CosmeticMaterialOverride[] cosmeticMaterialOverrides
    // Size: 0x8
    // Offset: 0x198
    ::ArrayW<::GlobalNamespace::GliderHoldable::CosmeticMaterialOverride> cosmeticMaterialOverrides;
    // Field size check
    static_assert(sizeof(::ArrayW<::GlobalNamespace::GliderHoldable::CosmeticMaterialOverride>) == 0x8);
    // private System.Single networkSyncFollowRate
    // Size: 0x4
    // Offset: 0x1A0
    float networkSyncFollowRate;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Transform maxDistanceRespawnOrigin
    // Size: 0x8
    // Offset: 0x1A8
    ::UnityEngine::Transform* maxDistanceRespawnOrigin;
    // Field size check
    static_assert(sizeof(::UnityEngine::Transform*) == 0x8);
    // private System.Single maxDistanceBeforeRespawn
    // Size: 0x4
    // Offset: 0x1B0
    float maxDistanceBeforeRespawn;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single maxDroppedTimeToRespawn
    // Size: 0x4
    // Offset: 0x1B4
    float maxDroppedTimeToRespawn;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single windUprightTorqueMultiplier
    // Size: 0x4
    // Offset: 0x1B8
    float windUprightTorqueMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single gravityUprightTorqueMultiplier
    // Size: 0x4
    // Offset: 0x1BC
    float gravityUprightTorqueMultiplier;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single fallingGravityReduction
    // Size: 0x4
    // Offset: 0x1C0
    float fallingGravityReduction;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.AudioSource calmAudio
    // Size: 0x8
    // Offset: 0x1C8
    ::UnityEngine::AudioSource* calmAudio;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.AudioSource activeAudio
    // Size: 0x8
    // Offset: 0x1D0
    ::UnityEngine::AudioSource* activeAudio;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.AudioSource whistlingAudio
    // Size: 0x8
    // Offset: 0x1D8
    ::UnityEngine::AudioSource* whistlingAudio;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.AudioSource leftWhooshAudio
    // Size: 0x8
    // Offset: 0x1E0
    ::UnityEngine::AudioSource* leftWhooshAudio;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private UnityEngine.AudioSource rightWhooshAudio
    // Size: 0x8
    // Offset: 0x1E8
    ::UnityEngine::AudioSource* rightWhooshAudio;
    // Field size check
    static_assert(sizeof(::UnityEngine::AudioSource*) == 0x8);
    // private InteractionPoint handle
    // Size: 0x8
    // Offset: 0x1F0
    ::GlobalNamespace::InteractionPoint* handle;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::InteractionPoint*) == 0x8);
    // private RequestableOwnershipGuard ownershipGuard
    // Size: 0x8
    // Offset: 0x1F8
    ::GlobalNamespace::RequestableOwnershipGuard* ownershipGuard;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::RequestableOwnershipGuard*) == 0x8);
    // private System.Boolean subtlePlayerPitchActive
    // Size: 0x1
    // Offset: 0x200
    bool subtlePlayerPitchActive;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean subtlePlayerRollActive
    // Size: 0x1
    // Offset: 0x201
    bool subtlePlayerRollActive;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Single subtlePlayerPitch
    // Size: 0x4
    // Offset: 0x204
    float subtlePlayerPitch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single subtlePlayerRoll
    // Size: 0x4
    // Offset: 0x208
    float subtlePlayerRoll;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single subtlePlayerPitchRateExp
    // Size: 0x4
    // Offset: 0x20C
    float subtlePlayerPitchRateExp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single subtlePlayerRollRateExp
    // Size: 0x4
    // Offset: 0x210
    float subtlePlayerRollRateExp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private GliderHoldable/HoldingHand leftHold
    // Size: 0x38
    // Offset: 0x218
    ::GlobalNamespace::GliderHoldable::HoldingHand leftHold;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GliderHoldable::HoldingHand) == 0x38);
    // private GliderHoldable/HoldingHand rightHold
    // Size: 0x38
    // Offset: 0x250
    ::GlobalNamespace::GliderHoldable::HoldingHand rightHold;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GliderHoldable::HoldingHand) == 0x38);
    // private GliderHoldable/SyncedState syncedState
    // Size: 0x24
    // Offset: 0x288
    ::GlobalNamespace::GliderHoldable::SyncedState syncedState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GliderHoldable::SyncedState) == 0x24);
    // private UnityEngine.Vector3 twoHandRotationOffsetAxis
    // Size: 0xC
    // Offset: 0x2AC
    ::UnityEngine::Vector3 twoHandRotationOffsetAxis;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single twoHandRotationOffsetAngle
    // Size: 0x4
    // Offset: 0x2B8
    float twoHandRotationOffsetAngle;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Rigidbody rb
    // Size: 0x8
    // Offset: 0x2C0
    ::UnityEngine::Rigidbody* rb;
    // Field size check
    static_assert(sizeof(::UnityEngine::Rigidbody*) == 0x8);
    // private UnityEngine.Vector2 riderPosition
    // Size: 0x8
    // Offset: 0x2C8
    ::UnityEngine::Vector2 riderPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector2) == 0x8);
    // private UnityEngine.Vector3 previousVelocity
    // Size: 0xC
    // Offset: 0x2D0
    ::UnityEngine::Vector3 previousVelocity;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 currentVelocity
    // Size: 0xC
    // Offset: 0x2DC
    ::UnityEngine::Vector3 currentVelocity;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single pitch
    // Size: 0x4
    // Offset: 0x2E8
    float pitch;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single yaw
    // Size: 0x4
    // Offset: 0x2EC
    float yaw;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single roll
    // Size: 0x4
    // Offset: 0x2F0
    float roll;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single pitchVel
    // Size: 0x4
    // Offset: 0x2F4
    float pitchVel;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single yawVel
    // Size: 0x4
    // Offset: 0x2F8
    float yawVel;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single rollVel
    // Size: 0x4
    // Offset: 0x2FC
    float rollVel;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single oneHandRotationRateExp
    // Size: 0x4
    // Offset: 0x300
    float oneHandRotationRateExp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single twoHandRotationRateExp
    // Size: 0x4
    // Offset: 0x304
    float twoHandRotationRateExp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Quaternion playerFacingRotationOffset
    // Size: 0x10
    // Offset: 0x308
    ::UnityEngine::Quaternion playerFacingRotationOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private AverageVector3 accelerationAverage
    // Size: 0x8
    // Offset: 0x318
    ::GlobalNamespace::AverageVector3* accelerationAverage;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::AverageVector3*) == 0x8);
    // private System.Single accelerationSmoothed
    // Size: 0x4
    // Offset: 0x320
    float accelerationSmoothed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single turnAccelerationSmoothed
    // Size: 0x4
    // Offset: 0x324
    float turnAccelerationSmoothed;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single accelSmoothingFollowRateExp
    // Size: 0x4
    // Offset: 0x328
    float accelSmoothingFollowRateExp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single networkSyncFollowRateExp
    // Size: 0x4
    // Offset: 0x32C
    float networkSyncFollowRateExp;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean pendingOwnershipRequest
    // Size: 0x1
    // Offset: 0x330
    bool pendingOwnershipRequest;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private UnityEngine.Vector3 positionLocalToVRRig
    // Size: 0xC
    // Offset: 0x334
    ::UnityEngine::Vector3 positionLocalToVRRig;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion rotationLocalToVRRig
    // Size: 0x10
    // Offset: 0x340
    ::UnityEngine::Quaternion rotationLocalToVRRig;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Coroutine reenableOwnershipRequestCoroutine
    // Size: 0x8
    // Offset: 0x350
    ::UnityEngine::Coroutine* reenableOwnershipRequestCoroutine;
    // Field size check
    static_assert(sizeof(::UnityEngine::Coroutine*) == 0x8);
    // private UnityEngine.Vector3 spawnPosition
    // Size: 0xC
    // Offset: 0x358
    ::UnityEngine::Vector3 spawnPosition;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion spawnRotation
    // Size: 0x10
    // Offset: 0x364
    ::UnityEngine::Quaternion spawnRotation;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private System.Single lastHeldTime
    // Size: 0x4
    // Offset: 0x374
    float lastHeldTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Nullable`1<UnityEngine.Vector3> leftHoldPositionLocal
    // Size: 0xFFFFFFFF
    // Offset: 0x378
    ::System::Nullable_1<::UnityEngine::Vector3> leftHoldPositionLocal;
    // private System.Nullable`1<UnityEngine.Vector3> rightHoldPositionLocal
    // Size: 0xFFFFFFFF
    // Offset: 0x388
    ::System::Nullable_1<::UnityEngine::Vector3> rightHoldPositionLocal;
    // private System.Single whooshSoundDuration
    // Size: 0x4
    // Offset: 0x398
    float whooshSoundDuration;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single whooshSoundRetriggerThreshold
    // Size: 0x4
    // Offset: 0x39C
    float whooshSoundRetriggerThreshold;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single leftWhooshStartTime
    // Size: 0x4
    // Offset: 0x3A0
    float leftWhooshStartTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 leftWhooshHitPoint
    // Size: 0xC
    // Offset: 0x3A4
    ::UnityEngine::Vector3 leftWhooshHitPoint;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Vector3 whooshAudioPositionOffset
    // Size: 0xC
    // Offset: 0x3B0
    ::UnityEngine::Vector3 whooshAudioPositionOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Single rightWhooshStartTime
    // Size: 0x4
    // Offset: 0x3BC
    float rightWhooshStartTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3 rightWhooshHitPoint
    // Size: 0xC
    // Offset: 0x3C0
    ::UnityEngine::Vector3 rightWhooshHitPoint;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private System.Int32 ridersMaterialOverideIndex
    // Size: 0x4
    // Offset: 0x3CC
    int ridersMaterialOverideIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 windVolumeForceAppliedFrame
    // Size: 0x4
    // Offset: 0x3D0
    int windVolumeForceAppliedFrame;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Boolean holdingTwoGliders
    // Size: 0x1
    // Offset: 0x3D4
    bool holdingTwoGliders;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private GliderHoldable/GliderState gliderState
    // Size: 0x4
    // Offset: 0x3D8
    ::GlobalNamespace::GliderHoldable::GliderState gliderState;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::GliderHoldable::GliderState) == 0x4);
    // private System.Single audioLevel
    // Size: 0x4
    // Offset: 0x3DC
    float audioLevel;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Int32 riderId
    // Size: 0x4
    // Offset: 0x3E0
    int riderId;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private VRRig cachedRig
    // Size: 0x8
    // Offset: 0x3E8
    ::GlobalNamespace::VRRig* cachedRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::VRRig*) == 0x8);
    // private System.Boolean infectedState
    // Size: 0x1
    // Offset: 0x3F0
    bool infectedState;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating interface conversion operator: operator ::Photon::Pun::IPunObservable
    operator ::Photon::Pun::IPunObservable() noexcept {
      return *reinterpret_cast<::Photon::Pun::IPunObservable*>(this);
    }
    // Creating interface conversion operator: operator ::GlobalNamespace::IRequestableOwnershipGuardCallbacks
    operator ::GlobalNamespace::IRequestableOwnershipGuardCallbacks() noexcept {
      return *reinterpret_cast<::GlobalNamespace::IRequestableOwnershipGuardCallbacks*>(this);
    }
    // static field const value: static private System.Single accelAveragingWindow
    static constexpr const float accelAveragingWindow = 0.1;
    // Get static field: static private System.Single accelAveragingWindow
    static float _get_accelAveragingWindow();
    // Set static field: static private System.Single accelAveragingWindow
    static void _set_accelAveragingWindow(float value);
    // Get instance field reference: private UnityEngine.Vector2 pitchMinMax
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_pitchMinMax();
    // Get instance field reference: private UnityEngine.Vector2 rollMinMax
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_rollMinMax();
    // Get instance field reference: private System.Single pitchHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_pitchHalfLife();
    // Get instance field reference: private System.Single yawHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_yawHalfLife();
    // Get instance field reference: private System.Single rollHalfLife
    [[deprecated("Use field access instead!")]] float& dyn_rollHalfLife();
    // Get instance field reference: private System.Single yawRateFactor
    [[deprecated("Use field access instead!")]] float& dyn_yawRateFactor();
    // Get instance field reference: private System.Single yawRateFactorRollOnly
    [[deprecated("Use field access instead!")]] float& dyn_yawRateFactorRollOnly();
    // Get instance field reference: public UnityEngine.Vector2 pitchVelocityTargetMinMax
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_pitchVelocityTargetMinMax();
    // Get instance field reference: public UnityEngine.Vector2 pitchVelocityRampTimeMinMax
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_pitchVelocityRampTimeMinMax();
    // Get instance field reference: private System.Single pitchVelocityFollowRateAngle
    [[deprecated("Use field access instead!")]] float& dyn_pitchVelocityFollowRateAngle();
    // Get instance field reference: private System.Single pitchVelocityFollowRateMagnitude
    [[deprecated("Use field access instead!")]] float& dyn_pitchVelocityFollowRateMagnitude();
    // Get instance field reference: private System.Single yawVelocityFollowRateAngle
    [[deprecated("Use field access instead!")]] float& dyn_yawVelocityFollowRateAngle();
    // Get instance field reference: private System.Single yawVelocityFollowRateMagnitude
    [[deprecated("Use field access instead!")]] float& dyn_yawVelocityFollowRateMagnitude();
    // Get instance field reference: private UnityEngine.AnimationCurve liftVsAttack
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn_liftVsAttack();
    // Get instance field reference: private UnityEngine.AnimationCurve dragVsAttack
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn_dragVsAttack();
    // Get instance field reference: public System.Single attackDragFactor
    [[deprecated("Use field access instead!")]] float& dyn_attackDragFactor();
    // Get instance field reference: private UnityEngine.AnimationCurve dragVsSpeed
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn_dragVsSpeed();
    // Get instance field reference: public System.Single dragVsSpeedMaxSpeed
    [[deprecated("Use field access instead!")]] float& dyn_dragVsSpeedMaxSpeed();
    // Get instance field reference: public System.Single dragVsSpeedDragFactor
    [[deprecated("Use field access instead!")]] float& dyn_dragVsSpeedDragFactor();
    // Get instance field reference: private UnityEngine.AnimationCurve liftIncreaseVsRoll
    [[deprecated("Use field access instead!")]] ::UnityEngine::AnimationCurve*& dyn_liftIncreaseVsRoll();
    // Get instance field reference: private System.Single liftIncreaseVsRollMaxAngle
    [[deprecated("Use field access instead!")]] float& dyn_liftIncreaseVsRollMaxAngle();
    // Get instance field reference: private System.Single gravityCompensation
    [[deprecated("Use field access instead!")]] float& dyn_gravityCompensation();
    // Get instance field reference: public System.Single pullUpLiftBonus
    [[deprecated("Use field access instead!")]] float& dyn_pullUpLiftBonus();
    // Get instance field reference: public System.Single pullUpLiftActivationVelocity
    [[deprecated("Use field access instead!")]] float& dyn_pullUpLiftActivationVelocity();
    // Get instance field reference: public System.Single pullUpLiftActivationAcceleration
    [[deprecated("Use field access instead!")]] float& dyn_pullUpLiftActivationAcceleration();
    // Get instance field reference: private System.Single riderPosDirectPitchMax
    [[deprecated("Use field access instead!")]] float& dyn_riderPosDirectPitchMax();
    // Get instance field reference: private UnityEngine.Vector2 riderPosRange
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_riderPosRange();
    // Get instance field reference: private System.Single riderPosRangeOffset
    [[deprecated("Use field access instead!")]] float& dyn_riderPosRangeOffset();
    // Get instance field reference: private UnityEngine.Vector2 riderPosRangeNormalizedDeadzone
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_riderPosRangeNormalizedDeadzone();
    // Get instance field reference: private System.Single holdRotationAngleMax
    [[deprecated("Use field access instead!")]] float& dyn_holdRotationAngleMax();
    // Get instance field reference: private System.Single oneHandHoldRotationRate
    [[deprecated("Use field access instead!")]] float& dyn_oneHandHoldRotationRate();
    // Get instance field reference: private UnityEngine.Vector3 oneHandSimulatedHoldOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_oneHandSimulatedHoldOffset();
    // Get instance field reference: private System.Single oneHandPitchMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_oneHandPitchMultiplier();
    // Get instance field reference: private System.Single twoHandHoldRotationRate
    [[deprecated("Use field access instead!")]] float& dyn_twoHandHoldRotationRate();
    // Get instance field reference: private System.Boolean twoHandGliderInversionOnYawInsteadOfRoll
    [[deprecated("Use field access instead!")]] bool& dyn_twoHandGliderInversionOnYawInsteadOfRoll();
    // Get instance field reference: private System.Boolean setMaxHandSlipDuringFlight
    [[deprecated("Use field access instead!")]] bool& dyn_setMaxHandSlipDuringFlight();
    // Get instance field reference: private System.Single maxSlipOverrideSpeedThreshold
    [[deprecated("Use field access instead!")]] float& dyn_maxSlipOverrideSpeedThreshold();
    // Get instance field reference: private System.Single subtlePlayerPitchFactor
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerPitchFactor();
    // Get instance field reference: private System.Single subtlePlayerPitchRate
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerPitchRate();
    // Get instance field reference: private System.Single subtlePlayerRollFactor
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerRollFactor();
    // Get instance field reference: private System.Single subtlePlayerRollRate
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerRollRate();
    // Get instance field reference: private UnityEngine.Vector2 subtlePlayerRotationSpeedRampMinMax
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_subtlePlayerRotationSpeedRampMinMax();
    // Get instance field reference: private UnityEngine.Vector2 subtlePlayerRollAccelMinMax
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_subtlePlayerRollAccelMinMax();
    // Get instance field reference: private UnityEngine.Vector2 subtlePlayerPitchAccelMinMax
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_subtlePlayerPitchAccelMinMax();
    // Get instance field reference: private System.Single accelSmoothingFollowRate
    [[deprecated("Use field access instead!")]] float& dyn_accelSmoothingFollowRate();
    // Get instance field reference: private System.Single horizontalAccelSmoothingFollowRate
    [[deprecated("Use field access instead!")]] float& dyn_horizontalAccelSmoothingFollowRate();
    // Get instance field reference: private UnityEngine.Vector2 hapticAccelInputRange
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_hapticAccelInputRange();
    // Get instance field reference: private System.Single hapticAccelOutputMax
    [[deprecated("Use field access instead!")]] float& dyn_hapticAccelOutputMax();
    // Get instance field reference: private UnityEngine.Vector2 hapticMaxSpeedInputRange
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_hapticMaxSpeedInputRange();
    // Get instance field reference: private UnityEngine.Vector2 hapticSpeedInputRange
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_hapticSpeedInputRange();
    // Get instance field reference: private System.Single hapticSpeedOutputMax
    [[deprecated("Use field access instead!")]] float& dyn_hapticSpeedOutputMax();
    // Get instance field reference: private UnityEngine.Vector2 whistlingAudioSpeedInputRange
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_whistlingAudioSpeedInputRange();
    // Get instance field reference: private System.Single audioVolumeMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_audioVolumeMultiplier();
    // Get instance field reference: private System.Single infectedAudioVolumeMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_infectedAudioVolumeMultiplier();
    // Get instance field reference: private UnityEngine.Vector2 whooshSpeedThresholdInput
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_whooshSpeedThresholdInput();
    // Get instance field reference: private UnityEngine.Vector2 whooshVolumeOutput
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_whooshVolumeOutput();
    // Get instance field reference: private System.Single whooshCheckDistance
    [[deprecated("Use field access instead!")]] float& dyn_whooshCheckDistance();
    // Get instance field reference: private System.Boolean extendTagRangeInFlight
    [[deprecated("Use field access instead!")]] bool& dyn_extendTagRangeInFlight();
    // Get instance field reference: private UnityEngine.Vector2 tagRangeSpeedInput
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_tagRangeSpeedInput();
    // Get instance field reference: private UnityEngine.Vector2 tagRangeOutput
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_tagRangeOutput();
    // Get instance field reference: private System.Boolean debugDrawTagRange
    [[deprecated("Use field access instead!")]] bool& dyn_debugDrawTagRange();
    // Get instance field reference: private System.Single infectedSpeedIncrease
    [[deprecated("Use field access instead!")]] float& dyn_infectedSpeedIncrease();
    // Get instance field reference: private UnityEngine.MeshRenderer leafMesh
    [[deprecated("Use field access instead!")]] ::UnityEngine::MeshRenderer*& dyn_leafMesh();
    // Get instance field reference: private UnityEngine.Material baseLeafMaterial
    [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn_baseLeafMaterial();
    // Get instance field reference: private UnityEngine.Material infectedLeafMaterial
    [[deprecated("Use field access instead!")]] ::UnityEngine::Material*& dyn_infectedLeafMaterial();
    // Get instance field reference: private GliderHoldable/CosmeticMaterialOverride[] cosmeticMaterialOverrides
    [[deprecated("Use field access instead!")]] ::ArrayW<::GlobalNamespace::GliderHoldable::CosmeticMaterialOverride>& dyn_cosmeticMaterialOverrides();
    // Get instance field reference: private System.Single networkSyncFollowRate
    [[deprecated("Use field access instead!")]] float& dyn_networkSyncFollowRate();
    // Get instance field reference: private UnityEngine.Transform maxDistanceRespawnOrigin
    [[deprecated("Use field access instead!")]] ::UnityEngine::Transform*& dyn_maxDistanceRespawnOrigin();
    // Get instance field reference: private System.Single maxDistanceBeforeRespawn
    [[deprecated("Use field access instead!")]] float& dyn_maxDistanceBeforeRespawn();
    // Get instance field reference: private System.Single maxDroppedTimeToRespawn
    [[deprecated("Use field access instead!")]] float& dyn_maxDroppedTimeToRespawn();
    // Get instance field reference: private System.Single windUprightTorqueMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_windUprightTorqueMultiplier();
    // Get instance field reference: private System.Single gravityUprightTorqueMultiplier
    [[deprecated("Use field access instead!")]] float& dyn_gravityUprightTorqueMultiplier();
    // Get instance field reference: private System.Single fallingGravityReduction
    [[deprecated("Use field access instead!")]] float& dyn_fallingGravityReduction();
    // Get instance field reference: private UnityEngine.AudioSource calmAudio
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_calmAudio();
    // Get instance field reference: private UnityEngine.AudioSource activeAudio
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_activeAudio();
    // Get instance field reference: private UnityEngine.AudioSource whistlingAudio
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_whistlingAudio();
    // Get instance field reference: private UnityEngine.AudioSource leftWhooshAudio
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_leftWhooshAudio();
    // Get instance field reference: private UnityEngine.AudioSource rightWhooshAudio
    [[deprecated("Use field access instead!")]] ::UnityEngine::AudioSource*& dyn_rightWhooshAudio();
    // Get instance field reference: private InteractionPoint handle
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::InteractionPoint*& dyn_handle();
    // Get instance field reference: private RequestableOwnershipGuard ownershipGuard
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::RequestableOwnershipGuard*& dyn_ownershipGuard();
    // Get instance field reference: private System.Boolean subtlePlayerPitchActive
    [[deprecated("Use field access instead!")]] bool& dyn_subtlePlayerPitchActive();
    // Get instance field reference: private System.Boolean subtlePlayerRollActive
    [[deprecated("Use field access instead!")]] bool& dyn_subtlePlayerRollActive();
    // Get instance field reference: private System.Single subtlePlayerPitch
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerPitch();
    // Get instance field reference: private System.Single subtlePlayerRoll
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerRoll();
    // Get instance field reference: private System.Single subtlePlayerPitchRateExp
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerPitchRateExp();
    // Get instance field reference: private System.Single subtlePlayerRollRateExp
    [[deprecated("Use field access instead!")]] float& dyn_subtlePlayerRollRateExp();
    // Get instance field reference: private GliderHoldable/HoldingHand leftHold
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GliderHoldable::HoldingHand& dyn_leftHold();
    // Get instance field reference: private GliderHoldable/HoldingHand rightHold
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GliderHoldable::HoldingHand& dyn_rightHold();
    // Get instance field reference: private GliderHoldable/SyncedState syncedState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GliderHoldable::SyncedState& dyn_syncedState();
    // Get instance field reference: private UnityEngine.Vector3 twoHandRotationOffsetAxis
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_twoHandRotationOffsetAxis();
    // Get instance field reference: private System.Single twoHandRotationOffsetAngle
    [[deprecated("Use field access instead!")]] float& dyn_twoHandRotationOffsetAngle();
    // Get instance field reference: private UnityEngine.Rigidbody rb
    [[deprecated("Use field access instead!")]] ::UnityEngine::Rigidbody*& dyn_rb();
    // Get instance field reference: private UnityEngine.Vector2 riderPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector2& dyn_riderPosition();
    // Get instance field reference: private UnityEngine.Vector3 previousVelocity
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_previousVelocity();
    // Get instance field reference: private UnityEngine.Vector3 currentVelocity
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_currentVelocity();
    // Get instance field reference: private System.Single pitch
    [[deprecated("Use field access instead!")]] float& dyn_pitch();
    // Get instance field reference: private System.Single yaw
    [[deprecated("Use field access instead!")]] float& dyn_yaw();
    // Get instance field reference: private System.Single roll
    [[deprecated("Use field access instead!")]] float& dyn_roll();
    // Get instance field reference: private System.Single pitchVel
    [[deprecated("Use field access instead!")]] float& dyn_pitchVel();
    // Get instance field reference: private System.Single yawVel
    [[deprecated("Use field access instead!")]] float& dyn_yawVel();
    // Get instance field reference: private System.Single rollVel
    [[deprecated("Use field access instead!")]] float& dyn_rollVel();
    // Get instance field reference: private System.Single oneHandRotationRateExp
    [[deprecated("Use field access instead!")]] float& dyn_oneHandRotationRateExp();
    // Get instance field reference: private System.Single twoHandRotationRateExp
    [[deprecated("Use field access instead!")]] float& dyn_twoHandRotationRateExp();
    // Get instance field reference: private UnityEngine.Quaternion playerFacingRotationOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_playerFacingRotationOffset();
    // Get instance field reference: private AverageVector3 accelerationAverage
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::AverageVector3*& dyn_accelerationAverage();
    // Get instance field reference: private System.Single accelerationSmoothed
    [[deprecated("Use field access instead!")]] float& dyn_accelerationSmoothed();
    // Get instance field reference: private System.Single turnAccelerationSmoothed
    [[deprecated("Use field access instead!")]] float& dyn_turnAccelerationSmoothed();
    // Get instance field reference: private System.Single accelSmoothingFollowRateExp
    [[deprecated("Use field access instead!")]] float& dyn_accelSmoothingFollowRateExp();
    // Get instance field reference: private System.Single networkSyncFollowRateExp
    [[deprecated("Use field access instead!")]] float& dyn_networkSyncFollowRateExp();
    // Get instance field reference: private System.Boolean pendingOwnershipRequest
    [[deprecated("Use field access instead!")]] bool& dyn_pendingOwnershipRequest();
    // Get instance field reference: private UnityEngine.Vector3 positionLocalToVRRig
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_positionLocalToVRRig();
    // Get instance field reference: private UnityEngine.Quaternion rotationLocalToVRRig
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_rotationLocalToVRRig();
    // Get instance field reference: private UnityEngine.Coroutine reenableOwnershipRequestCoroutine
    [[deprecated("Use field access instead!")]] ::UnityEngine::Coroutine*& dyn_reenableOwnershipRequestCoroutine();
    // Get instance field reference: private UnityEngine.Vector3 spawnPosition
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_spawnPosition();
    // Get instance field reference: private UnityEngine.Quaternion spawnRotation
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_spawnRotation();
    // Get instance field reference: private System.Single lastHeldTime
    [[deprecated("Use field access instead!")]] float& dyn_lastHeldTime();
    // Get instance field reference: private System.Nullable`1<UnityEngine.Vector3> leftHoldPositionLocal
    [[deprecated("Use field access instead!")]] ::System::Nullable_1<::UnityEngine::Vector3>& dyn_leftHoldPositionLocal();
    // Get instance field reference: private System.Nullable`1<UnityEngine.Vector3> rightHoldPositionLocal
    [[deprecated("Use field access instead!")]] ::System::Nullable_1<::UnityEngine::Vector3>& dyn_rightHoldPositionLocal();
    // Get instance field reference: private System.Single whooshSoundDuration
    [[deprecated("Use field access instead!")]] float& dyn_whooshSoundDuration();
    // Get instance field reference: private System.Single whooshSoundRetriggerThreshold
    [[deprecated("Use field access instead!")]] float& dyn_whooshSoundRetriggerThreshold();
    // Get instance field reference: private System.Single leftWhooshStartTime
    [[deprecated("Use field access instead!")]] float& dyn_leftWhooshStartTime();
    // Get instance field reference: private UnityEngine.Vector3 leftWhooshHitPoint
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_leftWhooshHitPoint();
    // Get instance field reference: private UnityEngine.Vector3 whooshAudioPositionOffset
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_whooshAudioPositionOffset();
    // Get instance field reference: private System.Single rightWhooshStartTime
    [[deprecated("Use field access instead!")]] float& dyn_rightWhooshStartTime();
    // Get instance field reference: private UnityEngine.Vector3 rightWhooshHitPoint
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_rightWhooshHitPoint();
    // Get instance field reference: private System.Int32 ridersMaterialOverideIndex
    [[deprecated("Use field access instead!")]] int& dyn_ridersMaterialOverideIndex();
    // Get instance field reference: private System.Int32 windVolumeForceAppliedFrame
    [[deprecated("Use field access instead!")]] int& dyn_windVolumeForceAppliedFrame();
    // Get instance field reference: private System.Boolean holdingTwoGliders
    [[deprecated("Use field access instead!")]] bool& dyn_holdingTwoGliders();
    // Get instance field reference: private GliderHoldable/GliderState gliderState
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::GliderHoldable::GliderState& dyn_gliderState();
    // Get instance field reference: private System.Single audioLevel
    [[deprecated("Use field access instead!")]] float& dyn_audioLevel();
    // Get instance field reference: private System.Int32 riderId
    [[deprecated("Use field access instead!")]] int& dyn_riderId();
    // Get instance field reference: private VRRig cachedRig
    [[deprecated("Use field access instead!")]] ::GlobalNamespace::VRRig*& dyn_cachedRig();
    // Get instance field reference: private System.Boolean infectedState
    [[deprecated("Use field access instead!")]] bool& dyn_infectedState();
    // private System.Boolean get_OutOfBounds()
    // Offset: 0x275BAC8
    bool get_OutOfBounds();
    // private System.Void Awake()
    // Offset: 0x275BBB0
    void Awake();
    // private System.Void OnDestroy()
    // Offset: 0x275BDAC
    void OnDestroy();
    // public System.Void Respawn()
    // Offset: 0x275BE50
    void Respawn();
    // public System.Void OnGrabAuthority(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    // Offset: 0x275C464
    void OnGrabAuthority(::GlobalNamespace::InteractionPoint* pointGrabbed, ::UnityEngine::GameObject* grabbingHand);
    // public System.Void FixedUpdate()
    // Offset: 0x275DA74
    void FixedUpdate();
    // public System.Void LateUpdate()
    // Offset: 0x275E84C
    void LateUpdate();
    // private System.Void AuthorityUpdate(System.Single dt)
    // Offset: 0x275E900
    void AuthorityUpdate(float dt);
    // private System.Void AuthorityUpdateHeld(System.Single dt)
    // Offset: 0x275F0E4
    void AuthorityUpdateHeld(float dt);
    // private System.Void AuthorityUpdateUnheld(System.Single dt)
    // Offset: 0x275EF74
    void AuthorityUpdateUnheld(float dt);
    // private System.Void RemoteSyncUpdate(System.Single dt)
    // Offset: 0x275E9A8
    void RemoteSyncUpdate(float dt);
    // private VRRig getNewHolderRig(System.Int32 riderId)
    // Offset: 0x275CDA8
    ::GlobalNamespace::VRRig* getNewHolderRig(int riderId);
    // private UnityEngine.Vector3 ClosestPointInHandle(UnityEngine.Vector3 startingPoint, InteractionPoint interactionPoint)
    // Offset: 0x275CF1C
    ::UnityEngine::Vector3 ClosestPointInHandle(::UnityEngine::Vector3 startingPoint, ::GlobalNamespace::InteractionPoint* interactionPoint);
    // private System.Void UpdateGliderPosition()
    // Offset: 0x2761590
    void UpdateGliderPosition();
    // private UnityEngine.Vector3 GetHandsVector(UnityEngine.Vector3 leftHandPos, UnityEngine.Vector3 rightHandPos, UnityEngine.Vector3 headPos, System.Boolean flipBasedOnFacingDir)
    // Offset: 0x275D39C
    ::UnityEngine::Vector3 GetHandsVector(::UnityEngine::Vector3 leftHandPos, ::UnityEngine::Vector3 rightHandPos, ::UnityEngine::Vector3 headPos, bool flipBasedOnFacingDir);
    // private System.Void GetHandsOrientationVectors(UnityEngine.Vector3 leftHandPos, UnityEngine.Vector3 rightHandPos, UnityEngine.Transform head, System.Boolean flipBasedOnFacingDir, out UnityEngine.Vector3 handsVector, out UnityEngine.Vector3 handsUpVector)
    // Offset: 0x2761894
    void GetHandsOrientationVectors(::UnityEngine::Vector3 leftHandPos, ::UnityEngine::Vector3 rightHandPos, ::UnityEngine::Transform* head, bool flipBasedOnFacingDir, ByRef<::UnityEngine::Vector3> handsVector, ByRef<::UnityEngine::Vector3> handsUpVector);
    // private UnityEngine.Material GetMaterialFromIndex(System.Byte materialIndex)
    // Offset: 0x275D560
    ::UnityEngine::Material* GetMaterialFromIndex(uint8_t materialIndex);
    // private System.Single GetRollAngle180Wrapping()
    // Offset: 0x275E3C4
    float GetRollAngle180Wrapping();
    // private System.Single SignedAngleInPlane(UnityEngine.Vector3 from, UnityEngine.Vector3 to, UnityEngine.Vector3 normal)
    // Offset: 0x276223C
    float SignedAngleInPlane(::UnityEngine::Vector3 from, ::UnityEngine::Vector3 to, ::UnityEngine::Vector3 normal);
    // private System.Single NormalizeAngle180(System.Single angle)
    // Offset: 0x275E710
    float NormalizeAngle180(float angle);
    // private System.Void UpdateAudioSource(UnityEngine.AudioSource source, System.Single level)
    // Offset: 0x27617E4
    void UpdateAudioSource(::UnityEngine::AudioSource* source, float level);
    // public System.Void OnTriggerStay(UnityEngine.Collider other)
    // Offset: 0x276237C
    void OnTriggerStay(::UnityEngine::Collider* other);
    // private UnityEngine.Vector3 WindResistanceForceOffset(UnityEngine.Vector3 upDir, UnityEngine.Vector3 windDir)
    // Offset: 0x275E758
    ::UnityEngine::Vector3 WindResistanceForceOffset(::UnityEngine::Vector3 upDir, ::UnityEngine::Vector3 windDir);
    // public System.Void OnPhotonSerializeView(Photon.Pun.PhotonStream stream, Photon.Pun.PhotonMessageInfo info)
    // Offset: 0x27626EC
    void OnPhotonSerializeView(::Photon::Pun::PhotonStream* stream, ::Photon::Pun::PhotonMessageInfo info);
    // private System.Collections.IEnumerator ReenableOwnershipRequest()
    // Offset: 0x275C25C
    ::System::Collections::IEnumerator* ReenableOwnershipRequest();
    // public System.Void OnOwnershipTransferred(Photon.Realtime.Player toPlayer, Photon.Realtime.Player fromPlayer)
    // Offset: 0x2762B34
    void OnOwnershipTransferred(::Photon::Realtime::Player* toPlayer, ::Photon::Realtime::Player* fromPlayer);
    // public System.Boolean OnOwnershipRequest(Photon.Realtime.Player fromPlayer)
    // Offset: 0x2762C48
    bool OnOwnershipRequest(::Photon::Realtime::Player* fromPlayer);
    // public System.Void OnMyOwnerLeft()
    // Offset: 0x2762CDC
    void OnMyOwnerLeft();
    // public System.Boolean OnMasterClientAssistedTakeoverRequest(Photon.Realtime.Player fromPlayer, Photon.Realtime.Player toPlayer)
    // Offset: 0x2762CE0
    bool OnMasterClientAssistedTakeoverRequest(::Photon::Realtime::Player* fromPlayer, ::Photon::Realtime::Player* toPlayer);
    // public System.Void OnMyCreatorLeft()
    // Offset: 0x2762CE8
    void OnMyCreatorLeft();
    // private System.Void <OnHover>b__139_0()
    // Offset: 0x2763134
    void $OnHover$b__139_0();
    // private System.Void <OnGrab>b__140_0()
    // Offset: 0x276313C
    void $OnGrab$b__140_0();
    // public override System.Void OnDisable()
    // Offset: 0x275BE34
    // Implemented from: Photon.Pun.MonoBehaviourPunCallbacks
    // Base method: System.Void MonoBehaviourPunCallbacks::OnDisable()
    void OnDisable();
    // public override System.Boolean get_TwoHanded()
    // Offset: 0x275C11C
    // Implemented from: HoldableObject
    // Base method: System.Boolean HoldableObject::get_TwoHanded()
    bool get_TwoHanded();
    // public override System.Void OnHover(InteractionPoint pointHovered, UnityEngine.GameObject hoveringHand)
    // Offset: 0x275C124
    // Implemented from: HoldableObject
    // Base method: System.Void HoldableObject::OnHover(InteractionPoint pointHovered, UnityEngine.GameObject hoveringHand)
    void OnHover(::GlobalNamespace::InteractionPoint* pointHovered, ::UnityEngine::GameObject* hoveringHand);
    // public override System.Void OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    // Offset: 0x275C2C8
    // Implemented from: HoldableObject
    // Base method: System.Void HoldableObject::OnGrab(InteractionPoint pointGrabbed, UnityEngine.GameObject grabbingHand)
    void OnGrab(::GlobalNamespace::InteractionPoint* pointGrabbed, ::UnityEngine::GameObject* grabbingHand);
    // public override System.Boolean OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    // Offset: 0x275D5B0
    // Implemented from: HoldableObject
    // Base method: System.Boolean HoldableObject::OnRelease(DropZone zoneReleased, UnityEngine.GameObject releasingHand)
    bool OnRelease(::GlobalNamespace::DropZone* zoneReleased, ::UnityEngine::GameObject* releasingHand);
    // public System.Void .ctor()
    // Offset: 0x2762CEC
    // Implemented from: HoldableObject
    // Base method: System.Void HoldableObject::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static GliderHoldable* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::GliderHoldable::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<GliderHoldable*, creationType>()));
    }
  }; // GliderHoldable
  // WARNING Not writing size check since size may be invalid!
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::GliderHoldable::CosmeticMaterialOverride, "", "GliderHoldable/CosmeticMaterialOverride");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::GliderHoldable::SyncedState, "", "GliderHoldable/SyncedState");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::GliderHoldable::HoldingHand, "", "GliderHoldable/HoldingHand");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::GliderHoldable::GliderState, "", "GliderHoldable/GliderState");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::get_OutOfBounds
// Il2CppName: get_OutOfBounds
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::get_OutOfBounds)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "get_OutOfBounds", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::Awake
// Il2CppName: Awake
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::Awake)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "Awake", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::Respawn
// Il2CppName: Respawn
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::Respawn)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "Respawn", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnGrabAuthority
// Il2CppName: OnGrabAuthority
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::GlobalNamespace::InteractionPoint*, ::UnityEngine::GameObject*)>(&GlobalNamespace::GliderHoldable::OnGrabAuthority)> {
  static const MethodInfo* get() {
    static auto* pointGrabbed = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    static auto* grabbingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnGrabAuthority", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointGrabbed, grabbingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::FixedUpdate
// Il2CppName: FixedUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::FixedUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "FixedUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::AuthorityUpdate
// Il2CppName: AuthorityUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(float)>(&GlobalNamespace::GliderHoldable::AuthorityUpdate)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "AuthorityUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::AuthorityUpdateHeld
// Il2CppName: AuthorityUpdateHeld
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(float)>(&GlobalNamespace::GliderHoldable::AuthorityUpdateHeld)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "AuthorityUpdateHeld", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::AuthorityUpdateUnheld
// Il2CppName: AuthorityUpdateUnheld
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(float)>(&GlobalNamespace::GliderHoldable::AuthorityUpdateUnheld)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "AuthorityUpdateUnheld", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::RemoteSyncUpdate
// Il2CppName: RemoteSyncUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(float)>(&GlobalNamespace::GliderHoldable::RemoteSyncUpdate)> {
  static const MethodInfo* get() {
    static auto* dt = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "RemoteSyncUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{dt});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::getNewHolderRig
// Il2CppName: getNewHolderRig
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::VRRig* (GlobalNamespace::GliderHoldable::*)(int)>(&GlobalNamespace::GliderHoldable::getNewHolderRig)> {
  static const MethodInfo* get() {
    static auto* riderId = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "getNewHolderRig", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{riderId});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::ClosestPointInHandle
// Il2CppName: ClosestPointInHandle
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::GliderHoldable::*)(::UnityEngine::Vector3, ::GlobalNamespace::InteractionPoint*)>(&GlobalNamespace::GliderHoldable::ClosestPointInHandle)> {
  static const MethodInfo* get() {
    static auto* startingPoint = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* interactionPoint = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "ClosestPointInHandle", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{startingPoint, interactionPoint});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::UpdateGliderPosition
// Il2CppName: UpdateGliderPosition
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::UpdateGliderPosition)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "UpdateGliderPosition", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::GetHandsVector
// Il2CppName: GetHandsVector
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::GliderHoldable::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3, ::UnityEngine::Vector3, bool)>(&GlobalNamespace::GliderHoldable::GetHandsVector)> {
  static const MethodInfo* get() {
    static auto* leftHandPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* rightHandPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* headPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* flipBasedOnFacingDir = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "GetHandsVector", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{leftHandPos, rightHandPos, headPos, flipBasedOnFacingDir});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::GetHandsOrientationVectors
// Il2CppName: GetHandsOrientationVectors
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3, ::UnityEngine::Transform*, bool, ByRef<::UnityEngine::Vector3>, ByRef<::UnityEngine::Vector3>)>(&GlobalNamespace::GliderHoldable::GetHandsOrientationVectors)> {
  static const MethodInfo* get() {
    static auto* leftHandPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* rightHandPos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* head = &::il2cpp_utils::GetClassFromName("UnityEngine", "Transform")->byval_arg;
    static auto* flipBasedOnFacingDir = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* handsVector = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    static auto* handsUpVector = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "GetHandsOrientationVectors", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{leftHandPos, rightHandPos, head, flipBasedOnFacingDir, handsVector, handsUpVector});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::GetMaterialFromIndex
// Il2CppName: GetMaterialFromIndex
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Material* (GlobalNamespace::GliderHoldable::*)(uint8_t)>(&GlobalNamespace::GliderHoldable::GetMaterialFromIndex)> {
  static const MethodInfo* get() {
    static auto* materialIndex = &::il2cpp_utils::GetClassFromName("System", "Byte")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "GetMaterialFromIndex", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{materialIndex});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::GetRollAngle180Wrapping
// Il2CppName: GetRollAngle180Wrapping
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::GetRollAngle180Wrapping)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "GetRollAngle180Wrapping", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::SignedAngleInPlane
// Il2CppName: SignedAngleInPlane
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GlobalNamespace::GliderHoldable::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&GlobalNamespace::GliderHoldable::SignedAngleInPlane)> {
  static const MethodInfo* get() {
    static auto* from = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* to = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* normal = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "SignedAngleInPlane", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{from, to, normal});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::NormalizeAngle180
// Il2CppName: NormalizeAngle180
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GlobalNamespace::GliderHoldable::*)(float)>(&GlobalNamespace::GliderHoldable::NormalizeAngle180)> {
  static const MethodInfo* get() {
    static auto* angle = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "NormalizeAngle180", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{angle});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::UpdateAudioSource
// Il2CppName: UpdateAudioSource
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::UnityEngine::AudioSource*, float)>(&GlobalNamespace::GliderHoldable::UpdateAudioSource)> {
  static const MethodInfo* get() {
    static auto* source = &::il2cpp_utils::GetClassFromName("UnityEngine", "AudioSource")->byval_arg;
    static auto* level = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "UpdateAudioSource", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{source, level});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnTriggerStay
// Il2CppName: OnTriggerStay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::UnityEngine::Collider*)>(&GlobalNamespace::GliderHoldable::OnTriggerStay)> {
  static const MethodInfo* get() {
    static auto* other = &::il2cpp_utils::GetClassFromName("UnityEngine", "Collider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnTriggerStay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{other});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::WindResistanceForceOffset
// Il2CppName: WindResistanceForceOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Vector3 (GlobalNamespace::GliderHoldable::*)(::UnityEngine::Vector3, ::UnityEngine::Vector3)>(&GlobalNamespace::GliderHoldable::WindResistanceForceOffset)> {
  static const MethodInfo* get() {
    static auto* upDir = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* windDir = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "WindResistanceForceOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{upDir, windDir});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnPhotonSerializeView
// Il2CppName: OnPhotonSerializeView
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::Photon::Pun::PhotonStream*, ::Photon::Pun::PhotonMessageInfo)>(&GlobalNamespace::GliderHoldable::OnPhotonSerializeView)> {
  static const MethodInfo* get() {
    static auto* stream = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonStream")->byval_arg;
    static auto* info = &::il2cpp_utils::GetClassFromName("Photon.Pun", "PhotonMessageInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnPhotonSerializeView", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{stream, info});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::ReenableOwnershipRequest
// Il2CppName: ReenableOwnershipRequest
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Collections::IEnumerator* (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::ReenableOwnershipRequest)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "ReenableOwnershipRequest", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnOwnershipTransferred
// Il2CppName: OnOwnershipTransferred
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::Photon::Realtime::Player*, ::Photon::Realtime::Player*)>(&GlobalNamespace::GliderHoldable::OnOwnershipTransferred)> {
  static const MethodInfo* get() {
    static auto* toPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    static auto* fromPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnOwnershipTransferred", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{toPlayer, fromPlayer});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnOwnershipRequest
// Il2CppName: OnOwnershipRequest
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::GliderHoldable::*)(::Photon::Realtime::Player*)>(&GlobalNamespace::GliderHoldable::OnOwnershipRequest)> {
  static const MethodInfo* get() {
    static auto* fromPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnOwnershipRequest", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{fromPlayer});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnMyOwnerLeft
// Il2CppName: OnMyOwnerLeft
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::OnMyOwnerLeft)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnMyOwnerLeft", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnMasterClientAssistedTakeoverRequest
// Il2CppName: OnMasterClientAssistedTakeoverRequest
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::GliderHoldable::*)(::Photon::Realtime::Player*, ::Photon::Realtime::Player*)>(&GlobalNamespace::GliderHoldable::OnMasterClientAssistedTakeoverRequest)> {
  static const MethodInfo* get() {
    static auto* fromPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    static auto* toPlayer = &::il2cpp_utils::GetClassFromName("Photon.Realtime", "Player")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnMasterClientAssistedTakeoverRequest", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{fromPlayer, toPlayer});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnMyCreatorLeft
// Il2CppName: OnMyCreatorLeft
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::OnMyCreatorLeft)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnMyCreatorLeft", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::$OnHover$b__139_0
// Il2CppName: <OnHover>b__139_0
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::$OnHover$b__139_0)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "<OnHover>b__139_0", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::$OnGrab$b__140_0
// Il2CppName: <OnGrab>b__140_0
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::$OnGrab$b__140_0)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "<OnGrab>b__140_0", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::get_TwoHanded
// Il2CppName: get_TwoHanded
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::GliderHoldable::*)()>(&GlobalNamespace::GliderHoldable::get_TwoHanded)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "get_TwoHanded", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnHover
// Il2CppName: OnHover
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::GlobalNamespace::InteractionPoint*, ::UnityEngine::GameObject*)>(&GlobalNamespace::GliderHoldable::OnHover)> {
  static const MethodInfo* get() {
    static auto* pointHovered = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    static auto* hoveringHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnHover", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointHovered, hoveringHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnGrab
// Il2CppName: OnGrab
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::GliderHoldable::*)(::GlobalNamespace::InteractionPoint*, ::UnityEngine::GameObject*)>(&GlobalNamespace::GliderHoldable::OnGrab)> {
  static const MethodInfo* get() {
    static auto* pointGrabbed = &::il2cpp_utils::GetClassFromName("", "InteractionPoint")->byval_arg;
    static auto* grabbingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnGrab", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointGrabbed, grabbingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::OnRelease
// Il2CppName: OnRelease
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::GliderHoldable::*)(::GlobalNamespace::DropZone*, ::UnityEngine::GameObject*)>(&GlobalNamespace::GliderHoldable::OnRelease)> {
  static const MethodInfo* get() {
    static auto* zoneReleased = &::il2cpp_utils::GetClassFromName("", "DropZone")->byval_arg;
    static auto* releasingHand = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::GliderHoldable*), "OnRelease", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{zoneReleased, releasingHand});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::GliderHoldable::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
