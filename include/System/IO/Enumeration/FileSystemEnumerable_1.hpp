// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.Collections.Generic.IEnumerable`1
#include "System/Collections/Generic/IEnumerable_1.hpp"
// Including type: System.MulticastDelegate
#include "System/MulticastDelegate.hpp"
// Including type: System.IO.Enumeration.FileSystemEntry
#include "System/IO/Enumeration/FileSystemEntry.hpp"
// Including type: System.IO.Enumeration.FileSystemEnumerator`1
#include "System/IO/Enumeration/FileSystemEnumerator_1.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::IO::Enumeration
namespace System::IO::Enumeration {
  // Skipping declaration: FindPredicate because it is already included!
  // Skipping declaration: FindTransform because it is already included!
  // Skipping declaration: DelegateEnumerator because it is already included!
}
// Forward declaring namespace: System::IO
namespace System::IO {
  // Forward declaring type: EnumerationOptions
  class EnumerationOptions;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Skipping declaration: IEnumerator`1 because it is already included!
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Skipping declaration: IEnumerator because it is already included!
}
// Completed forward declares
// Type namespace: System.IO.Enumeration
namespace System::IO::Enumeration {
  // Forward declaring type: FileSystemEnumerable`1<TResult>
  template<typename TResult>
  class FileSystemEnumerable_1;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(::System::IO::Enumeration::FileSystemEnumerable_1, "System.IO.Enumeration", "FileSystemEnumerable`1");
// Type namespace: System.IO.Enumeration
namespace System::IO::Enumeration {
  // WARNING Size may be invalid!
  // Autogenerated type: System.IO.Enumeration.FileSystemEnumerable`1
  // [TokenAttribute] Offset: FFFFFFFF
  template<typename TResult>
  class FileSystemEnumerable_1 : public ::Il2CppObject/*, public ::System::Collections::Generic::IEnumerable_1<TResult>*/ {
    public:
    // Nested type: ::System::IO::Enumeration::FileSystemEnumerable_1::FindPredicate<TResult>
    class FindPredicate;
    // Nested type: ::System::IO::Enumeration::FileSystemEnumerable_1::FindTransform<TResult>
    class FindTransform;
    // Nested type: ::System::IO::Enumeration::FileSystemEnumerable_1::DelegateEnumerator<TResult>
    class DelegateEnumerator;
    // WARNING Size may be invalid!
    // Autogenerated type: System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate
    // [TokenAttribute] Offset: FFFFFFFF
    class FindPredicate : public ::il2cpp_utils::il2cpp_type_check::NestedType, public ::System::MulticastDelegate {
      public:
      using declaring_type = FileSystemEnumerable_1<TResult>*;
      static constexpr std::string_view NESTED_NAME = "FindPredicate";
      static constexpr bool IS_VALUE_TYPE = false;
      // public System.Void .ctor(System.Object object, System.IntPtr method)
      // Offset: 0xFFFFFFFFFFFFFFFF
      template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
      static typename FileSystemEnumerable_1<TResult>::FindPredicate* New_ctor(::Il2CppObject* object, ::System::IntPtr method) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::FindPredicate::.ctor");
        return THROW_UNLESS((::il2cpp_utils::New<typename FileSystemEnumerable_1<TResult>::FindPredicate*, creationType>(object, method)));
      }
      // public System.Boolean Invoke(ref System.IO.Enumeration.FileSystemEntry entry)
      // Offset: 0xFFFFFFFFFFFFFFFF
      bool Invoke(ByRef<::System::IO::Enumeration::FileSystemEntry> entry) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::FindPredicate::Invoke");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate*), -1));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, byref(entry));
      }
    }; // System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate
    // Could not write size check! Type: System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate is generic, or has no fields that are valid for size checks!
    // WARNING Size may be invalid!
    // Autogenerated type: System.IO.Enumeration.FileSystemEnumerable`1/FindTransform
    // [TokenAttribute] Offset: FFFFFFFF
    class FindTransform : public ::il2cpp_utils::il2cpp_type_check::NestedType, public ::System::MulticastDelegate {
      public:
      using declaring_type = FileSystemEnumerable_1<TResult>*;
      static constexpr std::string_view NESTED_NAME = "FindTransform";
      static constexpr bool IS_VALUE_TYPE = false;
      // public System.Void .ctor(System.Object object, System.IntPtr method)
      // Offset: 0xFFFFFFFFFFFFFFFF
      template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
      static typename FileSystemEnumerable_1<TResult>::FindTransform* New_ctor(::Il2CppObject* object, ::System::IntPtr method) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::FindTransform::.ctor");
        return THROW_UNLESS((::il2cpp_utils::New<typename FileSystemEnumerable_1<TResult>::FindTransform*, creationType>(object, method)));
      }
      // public TResult Invoke(ref System.IO.Enumeration.FileSystemEntry entry)
      // Offset: 0xFFFFFFFFFFFFFFFF
      TResult Invoke(ByRef<::System::IO::Enumeration::FileSystemEntry> entry) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::FindTransform::Invoke");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindTransform*), -1));
        return ::il2cpp_utils::RunMethodRethrow<TResult, false>(this, ___internal__method, byref(entry));
      }
    }; // System.IO.Enumeration.FileSystemEnumerable`1/FindTransform
    // Could not write size check! Type: System.IO.Enumeration.FileSystemEnumerable`1/FindTransform is generic, or has no fields that are valid for size checks!
    // WARNING Size may be invalid!
    // Autogenerated type: System.IO.Enumeration.FileSystemEnumerable`1/DelegateEnumerator
    // [TokenAttribute] Offset: FFFFFFFF
    class DelegateEnumerator : public ::il2cpp_utils::il2cpp_type_check::NestedType, public ::System::IO::Enumeration::FileSystemEnumerator_1<TResult> {
      public:
      using declaring_type = FileSystemEnumerable_1<TResult>*;
      static constexpr std::string_view NESTED_NAME = "DelegateEnumerator";
      static constexpr bool IS_VALUE_TYPE = false;
      public:
      // private readonly System.IO.Enumeration.FileSystemEnumerable`1<TResult> _enumerable
      // Size: 0x8
      // Offset: 0x0
      ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>* enumerable;
      // Field size check
      static_assert(sizeof(::System::IO::Enumeration::FileSystemEnumerable_1<TResult>*) == 0x8);
      public:
      // Creating conversion operator: operator ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>*
      constexpr operator ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>*() const noexcept {
        return enumerable;
      }
      // Autogenerated instance field getter
      // Get instance field: private readonly System.IO.Enumeration.FileSystemEnumerable`1<TResult> _enumerable
      [[deprecated("Use field access instead!")]] ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>*& dyn__enumerable() {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::DelegateEnumerator::dyn__enumerable");
        auto ___internal__instance = this;
        static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_enumerable"))->offset;
        return *reinterpret_cast<::System::IO::Enumeration::FileSystemEnumerable_1<TResult>**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
      }
      // public System.Void .ctor(System.IO.Enumeration.FileSystemEnumerable`1<TResult> enumerable)
      // Offset: 0xFFFFFFFFFFFFFFFF
      template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
      static typename FileSystemEnumerable_1<TResult>::DelegateEnumerator* New_ctor(::System::IO::Enumeration::FileSystemEnumerable_1<TResult>* enumerable) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::DelegateEnumerator::.ctor");
        return THROW_UNLESS((::il2cpp_utils::New<typename FileSystemEnumerable_1<TResult>::DelegateEnumerator*, creationType>(enumerable)));
      }
      // protected override TResult TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry)
      // Offset: 0xFFFFFFFFFFFFFFFF
      // Implemented from: System.IO.Enumeration.FileSystemEnumerator`1
      // Base method: TResult FileSystemEnumerator_1::TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry)
      TResult TransformEntry(ByRef<::System::IO::Enumeration::FileSystemEntry> entry) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::DelegateEnumerator::TransformEntry");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::System::IO::Enumeration::FileSystemEnumerator_1<TResult>*), -1));
        return ::il2cpp_utils::RunMethodRethrow<TResult, false>(this, ___internal__method, byref(entry));
      }
      // protected override System.Boolean ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry)
      // Offset: 0xFFFFFFFFFFFFFFFF
      // Implemented from: System.IO.Enumeration.FileSystemEnumerator`1
      // Base method: System.Boolean FileSystemEnumerator_1::ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry)
      bool ShouldRecurseIntoEntry(ByRef<::System::IO::Enumeration::FileSystemEntry> entry) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::DelegateEnumerator::ShouldRecurseIntoEntry");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::System::IO::Enumeration::FileSystemEnumerator_1<TResult>*), -1));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, byref(entry));
      }
      // protected override System.Boolean ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry)
      // Offset: 0xFFFFFFFFFFFFFFFF
      // Implemented from: System.IO.Enumeration.FileSystemEnumerator`1
      // Base method: System.Boolean FileSystemEnumerator_1::ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry)
      bool ShouldIncludeEntry(ByRef<::System::IO::Enumeration::FileSystemEntry> entry) {
        static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::DelegateEnumerator::ShouldIncludeEntry");
        auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::System::IO::Enumeration::FileSystemEnumerator_1<TResult>*), -1));
        return ::il2cpp_utils::RunMethodRethrow<bool, false>(this, ___internal__method, byref(entry));
      }
    }; // System.IO.Enumeration.FileSystemEnumerable`1/DelegateEnumerator
    // Could not write size check! Type: System.IO.Enumeration.FileSystemEnumerable`1/DelegateEnumerator is generic, or has no fields that are valid for size checks!
    public:
    // private System.IO.Enumeration.FileSystemEnumerable`1/DelegateEnumerator<TResult> _enumerator
    // Size: 0x8
    // Offset: 0x0
    typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::DelegateEnumerator* enumerator;
    // Field size check
    static_assert(sizeof(typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::DelegateEnumerator*) == 0x8);
    // private readonly System.IO.Enumeration.FileSystemEnumerable`1/FindTransform<TResult> _transform
    // Size: 0x8
    // Offset: 0x0
    typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindTransform* transform;
    // Field size check
    static_assert(sizeof(typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindTransform*) == 0x8);
    // private readonly System.IO.EnumerationOptions _options
    // Size: 0x8
    // Offset: 0x0
    ::System::IO::EnumerationOptions* options;
    // Field size check
    static_assert(sizeof(::System::IO::EnumerationOptions*) == 0x8);
    // private readonly System.String _directory
    // Size: 0x8
    // Offset: 0x0
    ::StringW directory;
    // Field size check
    static_assert(sizeof(::StringW) == 0x8);
    // private System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField
    // Size: 0x8
    // Offset: 0x0
    typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate* ShouldIncludePredicate;
    // Field size check
    static_assert(sizeof(typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate*) == 0x8);
    // private System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField
    // Size: 0x8
    // Offset: 0x0
    typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate* ShouldRecursePredicate;
    // Field size check
    static_assert(sizeof(typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate*) == 0x8);
    public:
    // Creating interface conversion operator: operator ::System::Collections::Generic::IEnumerable_1<TResult>
    operator ::System::Collections::Generic::IEnumerable_1<TResult>() noexcept {
      return *reinterpret_cast<::System::Collections::Generic::IEnumerable_1<TResult>*>(this);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.IO.Enumeration.FileSystemEnumerable`1/DelegateEnumerator<TResult> _enumerator
    [[deprecated("Use field access instead!")]] typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::DelegateEnumerator*& dyn__enumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::dyn__enumerator");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_enumerator"))->offset;
      return *reinterpret_cast<typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::DelegateEnumerator**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private readonly System.IO.Enumeration.FileSystemEnumerable`1/FindTransform<TResult> _transform
    [[deprecated("Use field access instead!")]] typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindTransform*& dyn__transform() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::dyn__transform");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_transform"))->offset;
      return *reinterpret_cast<typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindTransform**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private readonly System.IO.EnumerationOptions _options
    [[deprecated("Use field access instead!")]] ::System::IO::EnumerationOptions*& dyn__options() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::dyn__options");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_options"))->offset;
      return *reinterpret_cast<::System::IO::EnumerationOptions**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private readonly System.String _directory
    [[deprecated("Use field access instead!")]] ::StringW& dyn__directory() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::dyn__directory");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "_directory"))->offset;
      return *reinterpret_cast<::StringW*>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField
    [[deprecated("Use field access instead!")]] typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate*& dyn_$ShouldIncludePredicate$k__BackingField() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::dyn_$ShouldIncludePredicate$k__BackingField");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "<ShouldIncludePredicate>k__BackingField"))->offset;
      return *reinterpret_cast<typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // Autogenerated instance field getter
    // Get instance field: private System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField
    [[deprecated("Use field access instead!")]] typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate*& dyn_$ShouldRecursePredicate$k__BackingField() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::dyn_$ShouldRecursePredicate$k__BackingField");
      auto ___internal__instance = this;
      static auto ___internal__field__offset = THROW_UNLESS(il2cpp_utils::FindField(___internal__instance, "<ShouldRecursePredicate>k__BackingField"))->offset;
      return *reinterpret_cast<typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate**>(reinterpret_cast<char*>(this) + ___internal__field__offset);
    }
    // public System.Void .ctor(System.String directory, System.IO.Enumeration.FileSystemEnumerable`1/FindTransform<TResult> transform, System.IO.EnumerationOptions options)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static FileSystemEnumerable_1<TResult>* New_ctor(::StringW directory, typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindTransform* transform, ::System::IO::EnumerationOptions* options) {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<FileSystemEnumerable_1<TResult>*, creationType>(directory, transform, options)));
    }
    // public System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate<TResult> get_ShouldIncludePredicate()
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate* get_ShouldIncludePredicate() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::get_ShouldIncludePredicate");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "get_ShouldIncludePredicate", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate*, false>(this, ___internal__method);
    }
    // public System.Void set_ShouldIncludePredicate(System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate<TResult> value)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void set_ShouldIncludePredicate(typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate* value) {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::set_ShouldIncludePredicate");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "set_ShouldIncludePredicate", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(value)})));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___internal__method, value);
    }
    // public System.IO.Enumeration.FileSystemEnumerable`1/FindPredicate<TResult> get_ShouldRecursePredicate()
    // Offset: 0xFFFFFFFFFFFFFFFF
    typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate* get_ShouldRecursePredicate() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::get_ShouldRecursePredicate");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "get_ShouldRecursePredicate", std::vector<Il2CppClass*>{}, ::std::vector<const Il2CppType*>{})));
      return ::il2cpp_utils::RunMethodRethrow<typename ::System::IO::Enumeration::FileSystemEnumerable_1<TResult>::FindPredicate*, false>(this, ___internal__method);
    }
    // public System.Collections.Generic.IEnumerator`1<TResult> GetEnumerator()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::Generic::IEnumerator_1<TResult>* GetEnumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::GetEnumerator");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::System::IO::Enumeration::FileSystemEnumerable_1<TResult>*), -1));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::Generic::IEnumerator_1<TResult>*, false>(this, ___internal__method);
    }
    // private System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::System::Collections::IEnumerator* System_Collections_IEnumerable_GetEnumerator() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::IO::Enumeration::FileSystemEnumerable_1::System.Collections.IEnumerable.GetEnumerator");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::System::IO::Enumeration::FileSystemEnumerable_1<TResult>*), -1));
      return ::il2cpp_utils::RunMethodRethrow<::System::Collections::IEnumerator*, false>(this, ___internal__method);
    }
  }; // System.IO.Enumeration.FileSystemEnumerable`1
  // Could not write size check! Type: System.IO.Enumeration.FileSystemEnumerable`1 is generic, or has no fields that are valid for size checks!
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
