// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Globalization
namespace System::Globalization {
  // Forward declaring type: CultureInfo
  class CultureInfo;
  // Forward declaring type: UnicodeCategory
  struct UnicodeCategory;
}
// Forward declaring namespace: System::Text::RegularExpressions
namespace System::Text::RegularExpressions {
  // Skipping declaration: SingleRange because it is already included!
}
// Forward declaring namespace: System::Text
namespace System::Text {
  // Forward declaring type: StringBuilder
  class StringBuilder;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Completed forward declares
// Type namespace: System.Text.RegularExpressions
namespace System::Text::RegularExpressions {
  // Forward declaring type: RegexCharClass
  class RegexCharClass;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::System::Text::RegularExpressions::RegexCharClass);
DEFINE_IL2CPP_ARG_TYPE(::System::Text::RegularExpressions::RegexCharClass*, "System.Text.RegularExpressions", "RegexCharClass");
// Type namespace: System.Text.RegularExpressions
namespace System::Text::RegularExpressions {
  // Size: 0x30
  #pragma pack(push, 1)
  // Autogenerated type: System.Text.RegularExpressions.RegexCharClass
  // [TokenAttribute] Offset: FFFFFFFF
  class RegexCharClass : public ::Il2CppObject {
    public:
    // Nested type: ::System::Text::RegularExpressions::RegexCharClass::LowerCaseMapping
    struct LowerCaseMapping;
    // Nested type: ::System::Text::RegularExpressions::RegexCharClass::SingleRangeComparer
    class SingleRangeComparer;
    // Nested type: ::System::Text::RegularExpressions::RegexCharClass::SingleRange
    struct SingleRange;
    // Size: 0xC
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: System.Text.RegularExpressions.RegexCharClass/LowerCaseMapping
    // [TokenAttribute] Offset: FFFFFFFF
    // [IsReadOnlyAttribute] Offset: FFFFFFFF
    struct LowerCaseMapping/*, public ::System::ValueType*/ {
      public:
      public:
      // public readonly System.Char ChMin
      // Size: 0x2
      // Offset: 0x0
      ::Il2CppChar ChMin;
      // Field size check
      static_assert(sizeof(::Il2CppChar) == 0x2);
      // public readonly System.Char ChMax
      // Size: 0x2
      // Offset: 0x2
      ::Il2CppChar ChMax;
      // Field size check
      static_assert(sizeof(::Il2CppChar) == 0x2);
      // public readonly System.Int32 LcOp
      // Size: 0x4
      // Offset: 0x4
      int LcOp;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public readonly System.Int32 Data
      // Size: 0x4
      // Offset: 0x8
      int Data;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: LowerCaseMapping
      constexpr LowerCaseMapping(::Il2CppChar ChMin_ = {}, ::Il2CppChar ChMax_ = {}, int LcOp_ = {}, int Data_ = {}) noexcept : ChMin{ChMin_}, ChMax{ChMax_}, LcOp{LcOp_}, Data{Data_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public readonly System.Char ChMin
      [[deprecated("Use field access instead!")]] ::Il2CppChar& dyn_ChMin();
      // Get instance field reference: public readonly System.Char ChMax
      [[deprecated("Use field access instead!")]] ::Il2CppChar& dyn_ChMax();
      // Get instance field reference: public readonly System.Int32 LcOp
      [[deprecated("Use field access instead!")]] int& dyn_LcOp();
      // Get instance field reference: public readonly System.Int32 Data
      [[deprecated("Use field access instead!")]] int& dyn_Data();
      // System.Void .ctor(System.Char chMin, System.Char chMax, System.Int32 lcOp, System.Int32 data)
      // Offset: 0x4F77FF0
      // ABORTED: conflicts with another method.  LowerCaseMapping(::Il2CppChar chMin, ::Il2CppChar chMax, int lcOp, int data);
    }; // System.Text.RegularExpressions.RegexCharClass/LowerCaseMapping
    #pragma pack(pop)
    static check_size<sizeof(RegexCharClass::LowerCaseMapping), 8 + sizeof(int)> __System_Text_RegularExpressions_RegexCharClass_LowerCaseMappingSizeCheck;
    static_assert(sizeof(RegexCharClass::LowerCaseMapping) == 0xC);
    // Size: 0x4
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: System.Text.RegularExpressions.RegexCharClass/SingleRange
    // [TokenAttribute] Offset: FFFFFFFF
    // [IsReadOnlyAttribute] Offset: FFFFFFFF
    struct SingleRange/*, public ::System::ValueType*/ {
      public:
      public:
      // public readonly System.Char First
      // Size: 0x2
      // Offset: 0x0
      ::Il2CppChar First;
      // Field size check
      static_assert(sizeof(::Il2CppChar) == 0x2);
      // public readonly System.Char Last
      // Size: 0x2
      // Offset: 0x2
      ::Il2CppChar Last;
      // Field size check
      static_assert(sizeof(::Il2CppChar) == 0x2);
      public:
      // Creating value type constructor for type: SingleRange
      constexpr SingleRange(::Il2CppChar First_ = {}, ::Il2CppChar Last_ = {}) noexcept : First{First_}, Last{Last_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public readonly System.Char First
      [[deprecated("Use field access instead!")]] ::Il2CppChar& dyn_First();
      // Get instance field reference: public readonly System.Char Last
      [[deprecated("Use field access instead!")]] ::Il2CppChar& dyn_Last();
      // System.Void .ctor(System.Char first, System.Char last)
      // Offset: 0x4F78090
      // ABORTED: conflicts with another method.  SingleRange(::Il2CppChar first, ::Il2CppChar last);
    }; // System.Text.RegularExpressions.RegexCharClass/SingleRange
    #pragma pack(pop)
    static check_size<sizeof(RegexCharClass::SingleRange), 2 + sizeof(::Il2CppChar)> __System_Text_RegularExpressions_RegexCharClass_SingleRangeSizeCheck;
    static_assert(sizeof(RegexCharClass::SingleRange) == 0x4);
    public:
    // private System.Collections.Generic.List`1<System.Text.RegularExpressions.RegexCharClass/SingleRange> _rangelist
    // Size: 0x8
    // Offset: 0x10
    ::System::Collections::Generic::List_1<::System::Text::RegularExpressions::RegexCharClass::SingleRange>* rangelist;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::System::Text::RegularExpressions::RegexCharClass::SingleRange>*) == 0x8);
    // private System.Text.StringBuilder _categories
    // Size: 0x8
    // Offset: 0x18
    ::System::Text::StringBuilder* categories;
    // Field size check
    static_assert(sizeof(::System::Text::StringBuilder*) == 0x8);
    // private System.Boolean _canonical
    // Size: 0x1
    // Offset: 0x20
    bool canonical;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // private System.Boolean _negate
    // Size: 0x1
    // Offset: 0x21
    bool negate;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: negate and: subtractor
    char __padding3[0x6] = {};
    // private System.Text.RegularExpressions.RegexCharClass _subtractor
    // Size: 0x8
    // Offset: 0x28
    ::System::Text::RegularExpressions::RegexCharClass* subtractor;
    // Field size check
    static_assert(sizeof(::System::Text::RegularExpressions::RegexCharClass*) == 0x8);
    public:
    // Get static field: static private readonly System.String s_internalRegexIgnoreCase
    static ::StringW _get_s_internalRegexIgnoreCase();
    // Set static field: static private readonly System.String s_internalRegexIgnoreCase
    static void _set_s_internalRegexIgnoreCase(::StringW value);
    // Get static field: static private readonly System.String s_space
    static ::StringW _get_s_space();
    // Set static field: static private readonly System.String s_space
    static void _set_s_space(::StringW value);
    // Get static field: static private readonly System.String s_notSpace
    static ::StringW _get_s_notSpace();
    // Set static field: static private readonly System.String s_notSpace
    static void _set_s_notSpace(::StringW value);
    // Get static field: static private readonly System.String s_word
    static ::StringW _get_s_word();
    // Set static field: static private readonly System.String s_word
    static void _set_s_word(::StringW value);
    // Get static field: static private readonly System.String s_notWord
    static ::StringW _get_s_notWord();
    // Set static field: static private readonly System.String s_notWord
    static void _set_s_notWord(::StringW value);
    // Get static field: static public readonly System.String SpaceClass
    static ::StringW _get_SpaceClass();
    // Set static field: static public readonly System.String SpaceClass
    static void _set_SpaceClass(::StringW value);
    // Get static field: static public readonly System.String NotSpaceClass
    static ::StringW _get_NotSpaceClass();
    // Set static field: static public readonly System.String NotSpaceClass
    static void _set_NotSpaceClass(::StringW value);
    // Get static field: static public readonly System.String WordClass
    static ::StringW _get_WordClass();
    // Set static field: static public readonly System.String WordClass
    static void _set_WordClass(::StringW value);
    // Get static field: static public readonly System.String NotWordClass
    static ::StringW _get_NotWordClass();
    // Set static field: static public readonly System.String NotWordClass
    static void _set_NotWordClass(::StringW value);
    // Get static field: static public readonly System.String DigitClass
    static ::StringW _get_DigitClass();
    // Set static field: static public readonly System.String DigitClass
    static void _set_DigitClass(::StringW value);
    // Get static field: static public readonly System.String NotDigitClass
    static ::StringW _get_NotDigitClass();
    // Set static field: static public readonly System.String NotDigitClass
    static void _set_NotDigitClass(::StringW value);
    // Get static field: static private readonly System.Collections.Generic.Dictionary`2<System.String,System.String> s_definedCategories
    static ::System::Collections::Generic::Dictionary_2<::StringW, ::StringW>* _get_s_definedCategories();
    // Set static field: static private readonly System.Collections.Generic.Dictionary`2<System.String,System.String> s_definedCategories
    static void _set_s_definedCategories(::System::Collections::Generic::Dictionary_2<::StringW, ::StringW>* value);
    // Get static field: static private readonly System.String[][] s_propTable
    static ::ArrayW<::ArrayW<::StringW>> _get_s_propTable();
    // Set static field: static private readonly System.String[][] s_propTable
    static void _set_s_propTable(::ArrayW<::ArrayW<::StringW>> value);
    // Get static field: static private readonly System.Text.RegularExpressions.RegexCharClass/LowerCaseMapping[] s_lcTable
    static ::ArrayW<::System::Text::RegularExpressions::RegexCharClass::LowerCaseMapping> _get_s_lcTable();
    // Set static field: static private readonly System.Text.RegularExpressions.RegexCharClass/LowerCaseMapping[] s_lcTable
    static void _set_s_lcTable(::ArrayW<::System::Text::RegularExpressions::RegexCharClass::LowerCaseMapping> value);
    // Get instance field reference: private System.Collections.Generic.List`1<System.Text.RegularExpressions.RegexCharClass/SingleRange> _rangelist
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::System::Text::RegularExpressions::RegexCharClass::SingleRange>*& dyn__rangelist();
    // Get instance field reference: private System.Text.StringBuilder _categories
    [[deprecated("Use field access instead!")]] ::System::Text::StringBuilder*& dyn__categories();
    // Get instance field reference: private System.Boolean _canonical
    [[deprecated("Use field access instead!")]] bool& dyn__canonical();
    // Get instance field reference: private System.Boolean _negate
    [[deprecated("Use field access instead!")]] bool& dyn__negate();
    // Get instance field reference: private System.Text.RegularExpressions.RegexCharClass _subtractor
    [[deprecated("Use field access instead!")]] ::System::Text::RegularExpressions::RegexCharClass*& dyn__subtractor();
    // public System.Void .ctor()
    // Offset: 0x4F6F970
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static RegexCharClass* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::Text::RegularExpressions::RegexCharClass::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<RegexCharClass*, creationType>()));
    }
    // private System.Void .ctor(System.Boolean negate, System.Collections.Generic.List`1<System.Text.RegularExpressions.RegexCharClass/SingleRange> ranges, System.Text.StringBuilder categories, System.Text.RegularExpressions.RegexCharClass subtraction)
    // Offset: 0x4F6FA3C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static RegexCharClass* New_ctor(bool negate, ::System::Collections::Generic::List_1<::System::Text::RegularExpressions::RegexCharClass::SingleRange>* ranges, ::System::Text::StringBuilder* categories, ::System::Text::RegularExpressions::RegexCharClass* subtraction) {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::Text::RegularExpressions::RegexCharClass::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<RegexCharClass*, creationType>(negate, ranges, categories, subtraction)));
    }
    // public System.Boolean get_CanMerge()
    // Offset: 0x4F6FAAC
    bool get_CanMerge();
    // public System.Void set_Negate(System.Boolean value)
    // Offset: 0x4F6FACC
    void set_Negate(bool value);
    // public System.Void AddChar(System.Char c)
    // Offset: 0x4F6FAD8
    void AddChar(::Il2CppChar c);
    // public System.Void AddCharClass(System.Text.RegularExpressions.RegexCharClass cc)
    // Offset: 0x4F6FBFC
    void AddCharClass(::System::Text::RegularExpressions::RegexCharClass* cc);
    // private System.Void AddSet(System.String set)
    // Offset: 0x4F6FE14
    void AddSet(::StringW set);
    // public System.Void AddSubtraction(System.Text.RegularExpressions.RegexCharClass sub)
    // Offset: 0x4F70038
    void AddSubtraction(::System::Text::RegularExpressions::RegexCharClass* sub);
    // public System.Void AddRange(System.Char first, System.Char last)
    // Offset: 0x4F6FAE0
    void AddRange(::Il2CppChar first, ::Il2CppChar last);
    // public System.Void AddCategoryFromName(System.String categoryName, System.Boolean invert, System.Boolean caseInsensitive, System.String pattern)
    // Offset: 0x4F70040
    void AddCategoryFromName(::StringW categoryName, bool invert, bool caseInsensitive, ::StringW pattern);
    // private System.Void AddCategory(System.String category)
    // Offset: 0x4F70534
    void AddCategory(::StringW category);
    // public System.Void AddLowercase(System.Globalization.CultureInfo culture)
    // Offset: 0x4F70550
    void AddLowercase(::System::Globalization::CultureInfo* culture);
    // private System.Void AddLowercaseRange(System.Char chMin, System.Char chMax, System.Globalization.CultureInfo culture)
    // Offset: 0x4F7068C
    void AddLowercaseRange(::Il2CppChar chMin, ::Il2CppChar chMax, ::System::Globalization::CultureInfo* culture);
    // public System.Void AddWord(System.Boolean ecma, System.Boolean negate)
    // Offset: 0x4F708BC
    void AddWord(bool ecma, bool negate);
    // public System.Void AddSpace(System.Boolean ecma, System.Boolean negate)
    // Offset: 0x4F709B8
    void AddSpace(bool ecma, bool negate);
    // public System.Void AddDigit(System.Boolean ecma, System.Boolean negate, System.String pattern)
    // Offset: 0x4F70AB4
    void AddDigit(bool ecma, bool negate, ::StringW pattern);
    // static public System.Char SingletonChar(System.String set)
    // Offset: 0x4F70B68
    static ::Il2CppChar SingletonChar(::StringW set);
    // static public System.Boolean IsMergeable(System.String charClass)
    // Offset: 0x4F70B80
    static bool IsMergeable(::StringW charClass);
    // static public System.Boolean IsEmpty(System.String charClass)
    // Offset: 0x4F70C9C
    static bool IsEmpty(::StringW charClass);
    // static public System.Boolean IsSingleton(System.String set)
    // Offset: 0x4F70D5C
    static bool IsSingleton(::StringW set);
    // static public System.Boolean IsSingletonInverse(System.String set)
    // Offset: 0x4F70E68
    static bool IsSingletonInverse(::StringW set);
    // static private System.Boolean IsSubtraction(System.String charClass)
    // Offset: 0x4F70C44
    static bool IsSubtraction(::StringW charClass);
    // static private System.Boolean IsNegated(System.String set)
    // Offset: 0x4F70C1C
    static bool IsNegated(::StringW set);
    // static public System.Boolean IsECMAWordChar(System.Char ch)
    // Offset: 0x4F70F78
    static bool IsECMAWordChar(::Il2CppChar ch);
    // static public System.Boolean IsWordChar(System.Char ch)
    // Offset: 0x4F7104C
    static bool IsWordChar(::Il2CppChar ch);
    // static public System.Boolean CharInClass(System.Char ch, System.String set)
    // Offset: 0x4F70FE4
    static bool CharInClass(::Il2CppChar ch, ::StringW set);
    // static private System.Boolean CharInClassRecursive(System.Char ch, System.String set, System.Int32 start)
    // Offset: 0x4F710C8
    static bool CharInClassRecursive(::Il2CppChar ch, ::StringW set, int start);
    // static private System.Boolean CharInClassInternal(System.Char ch, System.String set, System.Int32 start, System.Int32 mySetLength, System.Int32 myCategoryLength)
    // Offset: 0x4F711F0
    static bool CharInClassInternal(::Il2CppChar ch, ::StringW set, int start, int mySetLength, int myCategoryLength);
    // static private System.Boolean CharInCategory(System.Char ch, System.String set, System.Int32 start, System.Int32 mySetLength, System.Int32 myCategoryLength)
    // Offset: 0x4F71300
    static bool CharInCategory(::Il2CppChar ch, ::StringW set, int start, int mySetLength, int myCategoryLength);
    // static private System.Boolean CharInCategoryGroup(System.Char ch, System.Globalization.UnicodeCategory chcategory, System.String category, ref System.Int32 i)
    // Offset: 0x4F71488
    static bool CharInCategoryGroup(::Il2CppChar ch, ::System::Globalization::UnicodeCategory chcategory, ::StringW category, ByRef<int> i);
    // static private System.String NegateCategory(System.String category)
    // Offset: 0x4F70250
    static ::StringW NegateCategory(::StringW category);
    // static public System.Text.RegularExpressions.RegexCharClass Parse(System.String charClass)
    // Offset: 0x4F71558
    static ::System::Text::RegularExpressions::RegexCharClass* Parse(::StringW charClass);
    // static private System.Text.RegularExpressions.RegexCharClass ParseRecursive(System.String charClass, System.Int32 start)
    // Offset: 0x4F715B0
    static ::System::Text::RegularExpressions::RegexCharClass* ParseRecursive(::StringW charClass, int start);
    // private System.Int32 RangeCount()
    // Offset: 0x4F6FD6C
    int RangeCount();
    // public System.String ToStringClass()
    // Offset: 0x4F7181C
    ::StringW ToStringClass();
    // private System.Text.RegularExpressions.RegexCharClass/SingleRange GetRangeAt(System.Int32 i)
    // Offset: 0x4F6FDB4
    ::System::Text::RegularExpressions::RegexCharClass::SingleRange GetRangeAt(int i);
    // private System.Void Canonicalize()
    // Offset: 0x4F719B8
    void Canonicalize();
    // static private System.String SetFromProperty(System.String capname, System.Boolean invert, System.String pattern)
    // Offset: 0x4F702D8
    static ::StringW SetFromProperty(::StringW capname, bool invert, ::StringW pattern);
    // static private System.Void .cctor()
    // Offset: 0x4F71BF0
    static void _cctor();
  }; // System.Text.RegularExpressions.RegexCharClass
  #pragma pack(pop)
  static check_size<sizeof(RegexCharClass), 40 + sizeof(::System::Text::RegularExpressions::RegexCharClass*)> __System_Text_RegularExpressions_RegexCharClassSizeCheck;
  static_assert(sizeof(RegexCharClass) == 0x30);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::System::Text::RegularExpressions::RegexCharClass::SingleRange, "System.Text.RegularExpressions", "RegexCharClass/SingleRange");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::System::Text::RegularExpressions::RegexCharClass::LowerCaseMapping, "System.Text.RegularExpressions", "RegexCharClass/LowerCaseMapping");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::get_CanMerge
// Il2CppName: get_CanMerge
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (System::Text::RegularExpressions::RegexCharClass::*)()>(&System::Text::RegularExpressions::RegexCharClass::get_CanMerge)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "get_CanMerge", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::set_Negate
// Il2CppName: set_Negate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(bool)>(&System::Text::RegularExpressions::RegexCharClass::set_Negate)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "set_Negate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddChar
// Il2CppName: AddChar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::Il2CppChar)>(&System::Text::RegularExpressions::RegexCharClass::AddChar)> {
  static const MethodInfo* get() {
    static auto* c = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddChar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{c});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddCharClass
// Il2CppName: AddCharClass
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::System::Text::RegularExpressions::RegexCharClass*)>(&System::Text::RegularExpressions::RegexCharClass::AddCharClass)> {
  static const MethodInfo* get() {
    static auto* cc = &::il2cpp_utils::GetClassFromName("System.Text.RegularExpressions", "RegexCharClass")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddCharClass", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{cc});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddSet
// Il2CppName: AddSet
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::AddSet)> {
  static const MethodInfo* get() {
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddSet", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{set});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddSubtraction
// Il2CppName: AddSubtraction
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::System::Text::RegularExpressions::RegexCharClass*)>(&System::Text::RegularExpressions::RegexCharClass::AddSubtraction)> {
  static const MethodInfo* get() {
    static auto* sub = &::il2cpp_utils::GetClassFromName("System.Text.RegularExpressions", "RegexCharClass")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddSubtraction", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{sub});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddRange
// Il2CppName: AddRange
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::Il2CppChar, ::Il2CppChar)>(&System::Text::RegularExpressions::RegexCharClass::AddRange)> {
  static const MethodInfo* get() {
    static auto* first = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* last = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddRange", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{first, last});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddCategoryFromName
// Il2CppName: AddCategoryFromName
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::StringW, bool, bool, ::StringW)>(&System::Text::RegularExpressions::RegexCharClass::AddCategoryFromName)> {
  static const MethodInfo* get() {
    static auto* categoryName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* invert = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* caseInsensitive = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* pattern = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddCategoryFromName", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{categoryName, invert, caseInsensitive, pattern});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddCategory
// Il2CppName: AddCategory
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::AddCategory)> {
  static const MethodInfo* get() {
    static auto* category = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddCategory", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{category});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddLowercase
// Il2CppName: AddLowercase
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::System::Globalization::CultureInfo*)>(&System::Text::RegularExpressions::RegexCharClass::AddLowercase)> {
  static const MethodInfo* get() {
    static auto* culture = &::il2cpp_utils::GetClassFromName("System.Globalization", "CultureInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddLowercase", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{culture});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddLowercaseRange
// Il2CppName: AddLowercaseRange
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(::Il2CppChar, ::Il2CppChar, ::System::Globalization::CultureInfo*)>(&System::Text::RegularExpressions::RegexCharClass::AddLowercaseRange)> {
  static const MethodInfo* get() {
    static auto* chMin = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* chMax = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* culture = &::il2cpp_utils::GetClassFromName("System.Globalization", "CultureInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddLowercaseRange", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{chMin, chMax, culture});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddWord
// Il2CppName: AddWord
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(bool, bool)>(&System::Text::RegularExpressions::RegexCharClass::AddWord)> {
  static const MethodInfo* get() {
    static auto* ecma = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* negate = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddWord", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ecma, negate});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddSpace
// Il2CppName: AddSpace
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(bool, bool)>(&System::Text::RegularExpressions::RegexCharClass::AddSpace)> {
  static const MethodInfo* get() {
    static auto* ecma = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* negate = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddSpace", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ecma, negate});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::AddDigit
// Il2CppName: AddDigit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)(bool, bool, ::StringW)>(&System::Text::RegularExpressions::RegexCharClass::AddDigit)> {
  static const MethodInfo* get() {
    static auto* ecma = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* negate = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* pattern = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "AddDigit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ecma, negate, pattern});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::SingletonChar
// Il2CppName: SingletonChar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Il2CppChar (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::SingletonChar)> {
  static const MethodInfo* get() {
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "SingletonChar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{set});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsMergeable
// Il2CppName: IsMergeable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::IsMergeable)> {
  static const MethodInfo* get() {
    static auto* charClass = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsMergeable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{charClass});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsEmpty
// Il2CppName: IsEmpty
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::IsEmpty)> {
  static const MethodInfo* get() {
    static auto* charClass = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsEmpty", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{charClass});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsSingleton
// Il2CppName: IsSingleton
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::IsSingleton)> {
  static const MethodInfo* get() {
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsSingleton", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{set});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsSingletonInverse
// Il2CppName: IsSingletonInverse
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::IsSingletonInverse)> {
  static const MethodInfo* get() {
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsSingletonInverse", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{set});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsSubtraction
// Il2CppName: IsSubtraction
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::IsSubtraction)> {
  static const MethodInfo* get() {
    static auto* charClass = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsSubtraction", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{charClass});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsNegated
// Il2CppName: IsNegated
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::IsNegated)> {
  static const MethodInfo* get() {
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsNegated", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{set});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsECMAWordChar
// Il2CppName: IsECMAWordChar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppChar)>(&System::Text::RegularExpressions::RegexCharClass::IsECMAWordChar)> {
  static const MethodInfo* get() {
    static auto* ch = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsECMAWordChar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ch});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::IsWordChar
// Il2CppName: IsWordChar
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppChar)>(&System::Text::RegularExpressions::RegexCharClass::IsWordChar)> {
  static const MethodInfo* get() {
    static auto* ch = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "IsWordChar", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ch});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::CharInClass
// Il2CppName: CharInClass
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppChar, ::StringW)>(&System::Text::RegularExpressions::RegexCharClass::CharInClass)> {
  static const MethodInfo* get() {
    static auto* ch = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "CharInClass", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ch, set});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::CharInClassRecursive
// Il2CppName: CharInClassRecursive
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppChar, ::StringW, int)>(&System::Text::RegularExpressions::RegexCharClass::CharInClassRecursive)> {
  static const MethodInfo* get() {
    static auto* ch = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* start = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "CharInClassRecursive", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ch, set, start});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::CharInClassInternal
// Il2CppName: CharInClassInternal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppChar, ::StringW, int, int, int)>(&System::Text::RegularExpressions::RegexCharClass::CharInClassInternal)> {
  static const MethodInfo* get() {
    static auto* ch = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* start = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* mySetLength = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* myCategoryLength = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "CharInClassInternal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ch, set, start, mySetLength, myCategoryLength});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::CharInCategory
// Il2CppName: CharInCategory
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppChar, ::StringW, int, int, int)>(&System::Text::RegularExpressions::RegexCharClass::CharInCategory)> {
  static const MethodInfo* get() {
    static auto* ch = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* set = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* start = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* mySetLength = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* myCategoryLength = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "CharInCategory", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ch, set, start, mySetLength, myCategoryLength});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::CharInCategoryGroup
// Il2CppName: CharInCategoryGroup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::Il2CppChar, ::System::Globalization::UnicodeCategory, ::StringW, ByRef<int>)>(&System::Text::RegularExpressions::RegexCharClass::CharInCategoryGroup)> {
  static const MethodInfo* get() {
    static auto* ch = &::il2cpp_utils::GetClassFromName("System", "Char")->byval_arg;
    static auto* chcategory = &::il2cpp_utils::GetClassFromName("System.Globalization", "UnicodeCategory")->byval_arg;
    static auto* category = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* i = &::il2cpp_utils::GetClassFromName("System", "Int32")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "CharInCategoryGroup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ch, chcategory, category, i});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::NegateCategory
// Il2CppName: NegateCategory
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::NegateCategory)> {
  static const MethodInfo* get() {
    static auto* category = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "NegateCategory", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{category});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::Parse
// Il2CppName: Parse
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Text::RegularExpressions::RegexCharClass* (*)(::StringW)>(&System::Text::RegularExpressions::RegexCharClass::Parse)> {
  static const MethodInfo* get() {
    static auto* charClass = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "Parse", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{charClass});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::ParseRecursive
// Il2CppName: ParseRecursive
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Text::RegularExpressions::RegexCharClass* (*)(::StringW, int)>(&System::Text::RegularExpressions::RegexCharClass::ParseRecursive)> {
  static const MethodInfo* get() {
    static auto* charClass = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* start = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "ParseRecursive", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{charClass, start});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::RangeCount
// Il2CppName: RangeCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (System::Text::RegularExpressions::RegexCharClass::*)()>(&System::Text::RegularExpressions::RegexCharClass::RangeCount)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "RangeCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::ToStringClass
// Il2CppName: ToStringClass
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (System::Text::RegularExpressions::RegexCharClass::*)()>(&System::Text::RegularExpressions::RegexCharClass::ToStringClass)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "ToStringClass", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::GetRangeAt
// Il2CppName: GetRangeAt
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Text::RegularExpressions::RegexCharClass::SingleRange (System::Text::RegularExpressions::RegexCharClass::*)(int)>(&System::Text::RegularExpressions::RegexCharClass::GetRangeAt)> {
  static const MethodInfo* get() {
    static auto* i = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "GetRangeAt", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{i});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::Canonicalize
// Il2CppName: Canonicalize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Text::RegularExpressions::RegexCharClass::*)()>(&System::Text::RegularExpressions::RegexCharClass::Canonicalize)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "Canonicalize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::SetFromProperty
// Il2CppName: SetFromProperty
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)(::StringW, bool, ::StringW)>(&System::Text::RegularExpressions::RegexCharClass::SetFromProperty)> {
  static const MethodInfo* get() {
    static auto* capname = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    static auto* invert = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* pattern = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), "SetFromProperty", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{capname, invert, pattern});
  }
};
// Writing MetadataGetter for method: System::Text::RegularExpressions::RegexCharClass::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&System::Text::RegularExpressions::RegexCharClass::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Text::RegularExpressions::RegexCharClass*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
