// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Including type: System.Int32
#include "System/Int32.hpp"
// Including type: System.Byte
#include "System/Byte.hpp"
// Including type: Fusion.Ptr
#include "Fusion/Ptr.hpp"
// Including type: Fusion.Simulation
#include "Fusion/Simulation.hpp"
// Including type: Fusion.PageSizes
#include "Fusion/PageSizes.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Fusion
namespace Fusion {
  // Skipping declaration: Config because it is already included!
}
// Forward declaring namespace: Fusion::Sockets
namespace Fusion::Sockets {
  // Forward declaring type: NetBitBuffer
  struct NetBitBuffer;
}
// Completed forward declares
// Type namespace: Fusion
namespace Fusion {
  // Forward declaring type: Allocator
  struct Allocator;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Fusion::Allocator, "Fusion", "Allocator");
// Type namespace: Fusion
namespace Fusion {
  // Size: 0x70
  #pragma pack(push, 1)
  // WARNING Layout: Explicit may not be correctly taken into account!
  // Autogenerated type: Fusion.Allocator
  // [TokenAttribute] Offset: FFFFFFFF
  struct Allocator/*, public ::System::ValueType*/ {
    public:
    // Nested type: ::Fusion::Allocator::Block
    struct Block;
    // Nested type: ::Fusion::Allocator::BlockList
    struct BlockList;
    // Nested type: ::Fusion::Allocator::Bucket
    struct Bucket;
    // Nested type: ::Fusion::Allocator::AllocatorBucketSize
    class AllocatorBucketSize;
    // Nested type: ::Fusion::Allocator::Config
    struct Config;
    // Nested type: ::Fusion::Allocator::Segment
    struct Segment;
    // Size: 0xC
    #pragma pack(push, 1)
    // WARNING Layout: Explicit may not be correctly taken into account!
    // Autogenerated type: Fusion.Allocator/Config
    // [TokenAttribute] Offset: FFFFFFFF
    struct Config/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.Int32 BlockShift
      // Size: 0x4
      // Offset: 0x0
      int BlockShift;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 BlockCount
      // Size: 0x4
      // Offset: 0x4
      int BlockCount;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      // public System.Int32 GlobalsSize
      // Size: 0x4
      // Offset: 0x8
      int GlobalsSize;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: Config
      constexpr Config(int BlockShift_ = {}, int BlockCount_ = {}, int GlobalsSize_ = {}) noexcept : BlockShift{BlockShift_}, BlockCount{BlockCount_}, GlobalsSize{GlobalsSize_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // static field const value: static public System.Int32 SIZE
      static constexpr const int SIZE = 12;
      // Get static field: static public System.Int32 SIZE
      static int _get_SIZE();
      // Set static field: static public System.Int32 SIZE
      static void _set_SIZE(int value);
      // static field const value: static public Fusion.PageSizes DEFAULT_BLOCK_SHIFT
      static constexpr const int DEFAULT_BLOCK_SHIFT = 14;
      // Get static field: static public Fusion.PageSizes DEFAULT_BLOCK_SHIFT
      static ::Fusion::PageSizes _get_DEFAULT_BLOCK_SHIFT();
      // Set static field: static public Fusion.PageSizes DEFAULT_BLOCK_SHIFT
      static void _set_DEFAULT_BLOCK_SHIFT(::Fusion::PageSizes value);
      // static field const value: static public System.Int32 DEFAULT_BLOCK_COUNT
      static constexpr const int DEFAULT_BLOCK_COUNT = 128;
      // Get static field: static public System.Int32 DEFAULT_BLOCK_COUNT
      static int _get_DEFAULT_BLOCK_COUNT();
      // Set static field: static public System.Int32 DEFAULT_BLOCK_COUNT
      static void _set_DEFAULT_BLOCK_COUNT(int value);
      // Get instance field reference: public System.Int32 BlockShift
      [[deprecated("Use field access instead!")]] int& dyn_BlockShift();
      // Get instance field reference: public System.Int32 BlockCount
      [[deprecated("Use field access instead!")]] int& dyn_BlockCount();
      // Get instance field reference: public System.Int32 GlobalsSize
      [[deprecated("Use field access instead!")]] int& dyn_GlobalsSize();
      // public System.Int32 get_BlockByteSize()
      // Offset: 0x2AFCE54
      int get_BlockByteSize();
      // public System.Int32 get_BlockWordCount()
      // Offset: 0x2AFE130
      int get_BlockWordCount();
      // public System.Int32 get_HeapSizeUsable()
      // Offset: 0x2AFCD50
      int get_HeapSizeUsable();
      // public System.Int32 get_HeapSizeAllocated()
      // Offset: 0x2AFE148
      int get_HeapSizeAllocated();
      // public System.Void .ctor(Fusion.PageSizes shift, System.Int32 count, System.Int32 globalsSize)
      // Offset: 0x2AFE3A8
      Config(::Fusion::PageSizes shift, int count, int globalsSize);
      // public System.Boolean Equals(Fusion.Allocator/Config other)
      // Offset: 0x2AFE42C
      bool Equals(::Fusion::Allocator::Config other);
      // public override System.Boolean Equals(System.Object obj)
      // Offset: 0x2AFE454
      // Implemented from: System.ValueType
      // Base method: System.Boolean ValueType::Equals(System.Object obj)
      bool Equals(::Il2CppObject* obj);
      // public override System.Int32 GetHashCode()
      // Offset: 0x2AFE4DC
      // Implemented from: System.ValueType
      // Base method: System.Int32 ValueType::GetHashCode()
      int GetHashCode();
      // public override System.String ToString()
      // Offset: 0x2AFE4F0
      // Implemented from: System.ValueType
      // Base method: System.String ValueType::ToString()
      ::StringW ToString();
    }; // Fusion.Allocator/Config
    #pragma pack(pop)
    static check_size<sizeof(Allocator::Config), 8 + sizeof(int)> __Fusion_Allocator_ConfigSizeCheck;
    static_assert(sizeof(Allocator::Config) == 0xC);
    public:
    // private System.Byte* _root
    // Size: 0x8
    // Offset: 0x0
    uint8_t* root;
    // Field size check
    static_assert(sizeof(uint8_t*) == 0x8);
    // private System.Byte* _heap
    // Size: 0x8
    // Offset: 0x8
    uint8_t* heap;
    // Field size check
    static_assert(sizeof(uint8_t*) == 0x8);
    // private System.Byte* _meta
    // Size: 0x8
    // Offset: 0x10
    uint8_t* meta;
    // Field size check
    static_assert(sizeof(uint8_t*) == 0x8);
    // private System.Void* _globals
    // Size: 0x8
    // Offset: 0x18
    void* globals;
    // Field size check
    static_assert(sizeof(void*) == 0x8);
    // private System.Void* _checksum
    // Size: 0x8
    // Offset: 0x20
    void* checksum;
    // Field size check
    static_assert(sizeof(void*) == 0x8);
    // private System.Void* _replicate
    // Size: 0x8
    // Offset: 0x28
    void* replicate;
    // Field size check
    static_assert(sizeof(void*) == 0x8);
    // private Fusion.Allocator/Block* _blocks
    // Size: 0x8
    // Offset: 0x30
    ::Fusion::Allocator::Block* blocks;
    // Field size check
    static_assert(sizeof(::Fusion::Allocator::Block*) == 0x8);
    // private Fusion.Allocator/BlockList* _blocksFreeList
    // Size: 0x8
    // Offset: 0x38
    ::Fusion::Allocator::BlockList* blocksFreeList;
    // Field size check
    static_assert(sizeof(::Fusion::Allocator::BlockList*) == 0x8);
    // private Fusion.Allocator/Bucket* _buckets
    // Size: 0x8
    // Offset: 0x40
    ::Fusion::Allocator::Bucket* buckets;
    // Field size check
    static_assert(sizeof(::Fusion::Allocator::Bucket*) == 0x8);
    // private System.Byte* _bucketsMap
    // Size: 0x8
    // Offset: 0x48
    uint8_t* bucketsMap;
    // Field size check
    static_assert(sizeof(uint8_t*) == 0x8);
    // private Fusion.Allocator/BlockList* _bucketsLists
    // Size: 0x8
    // Offset: 0x50
    ::Fusion::Allocator::BlockList* bucketsLists;
    // Field size check
    static_assert(sizeof(::Fusion::Allocator::BlockList*) == 0x8);
    // private Fusion.Allocator/Config _config
    // Size: 0xC
    // Offset: 0x58
    ::Fusion::Allocator::Config config;
    // Field size check
    static_assert(sizeof(::Fusion::Allocator::Config) == 0xC);
    // private System.Int32 _maxBlockIndexUsed
    // Size: 0x4
    // Offset: 0x64
    int maxBlockIndexUsed;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _checksumByteLength
    // Size: 0x4
    // Offset: 0x68
    int checksumByteLength;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _replicateByteLength
    // Size: 0x4
    // Offset: 0x6C
    int replicateByteLength;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    public:
    // Creating value type constructor for type: Allocator
    constexpr Allocator(uint8_t* root_ = {}, uint8_t* heap_ = {}, uint8_t* meta_ = {}, void* globals_ = {}, void* checksum_ = {}, void* replicate_ = {}, ::Fusion::Allocator::Block* blocks_ = {}, ::Fusion::Allocator::BlockList* blocksFreeList_ = {}, ::Fusion::Allocator::Bucket* buckets_ = {}, uint8_t* bucketsMap_ = {}, ::Fusion::Allocator::BlockList* bucketsLists_ = {}, ::Fusion::Allocator::Config config_ = {}, int maxBlockIndexUsed_ = {}, int checksumByteLength_ = {}, int replicateByteLength_ = {}) noexcept : root{root_}, heap{heap_}, meta{meta_}, globals{globals_}, checksum{checksum_}, replicate{replicate_}, blocks{blocks_}, blocksFreeList{blocksFreeList_}, buckets{buckets_}, bucketsMap{bucketsMap_}, bucketsLists{bucketsLists_}, config{config_}, maxBlockIndexUsed{maxBlockIndexUsed_}, checksumByteLength{checksumByteLength_}, replicateByteLength{replicateByteLength_} {}
    // Creating interface conversion operator: operator ::System::ValueType
    operator ::System::ValueType() noexcept {
      return *reinterpret_cast<::System::ValueType*>(this);
    }
    // static field const value: static private System.Int32 SIZE
    static constexpr const int SIZE = 112;
    // Get static field: static private System.Int32 SIZE
    static int _get_SIZE();
    // Set static field: static private System.Int32 SIZE
    static void _set_SIZE(int value);
    // static field const value: static private System.Int32 WORD_SHIFT
    static constexpr const int WORD_SHIFT = 3;
    // Get static field: static private System.Int32 WORD_SHIFT
    static int _get_WORD_SHIFT();
    // Set static field: static private System.Int32 WORD_SHIFT
    static void _set_WORD_SHIFT(int value);
    // static field const value: static private System.Int32 WORD_BYTE_SIZE
    static constexpr const int WORD_BYTE_SIZE = 8;
    // Get static field: static private System.Int32 WORD_BYTE_SIZE
    static int _get_WORD_BYTE_SIZE();
    // Set static field: static private System.Int32 WORD_BYTE_SIZE
    static void _set_WORD_BYTE_SIZE(int value);
    // static field const value: static public System.Int32 HEAP_ALIGNMENT
    static constexpr const int HEAP_ALIGNMENT = 8;
    // Get static field: static public System.Int32 HEAP_ALIGNMENT
    static int _get_HEAP_ALIGNMENT();
    // Set static field: static public System.Int32 HEAP_ALIGNMENT
    static void _set_HEAP_ALIGNMENT(int value);
    // static field const value: static public System.Int32 REPLICATE_WORD_SHIFT
    static constexpr const int REPLICATE_WORD_SHIFT = 2;
    // Get static field: static public System.Int32 REPLICATE_WORD_SHIFT
    static int _get_REPLICATE_WORD_SHIFT();
    // Set static field: static public System.Int32 REPLICATE_WORD_SHIFT
    static void _set_REPLICATE_WORD_SHIFT(int value);
    // static field const value: static public System.Int32 REPLICATE_WORD_SIZE
    static constexpr const int REPLICATE_WORD_SIZE = 4;
    // Get static field: static public System.Int32 REPLICATE_WORD_SIZE
    static int _get_REPLICATE_WORD_SIZE();
    // Set static field: static public System.Int32 REPLICATE_WORD_SIZE
    static void _set_REPLICATE_WORD_SIZE(int value);
    // static field const value: static public System.Int32 REPLICATE_WORD_ALIGN
    static constexpr const int REPLICATE_WORD_ALIGN = 4;
    // Get static field: static public System.Int32 REPLICATE_WORD_ALIGN
    static int _get_REPLICATE_WORD_ALIGN();
    // Set static field: static public System.Int32 REPLICATE_WORD_ALIGN
    static void _set_REPLICATE_WORD_ALIGN(int value);
    // static field const value: static public System.Int32 BUCKET_COUNT
    static constexpr const int BUCKET_COUNT = 57;
    // Get static field: static public System.Int32 BUCKET_COUNT
    static int _get_BUCKET_COUNT();
    // Set static field: static public System.Int32 BUCKET_COUNT
    static void _set_BUCKET_COUNT(int value);
    // static field const value: static public System.Byte BUCKET_INVALID
    static constexpr const uint8_t BUCKET_INVALID = 255u;
    // Get static field: static public System.Byte BUCKET_INVALID
    static uint8_t _get_BUCKET_INVALID();
    // Set static field: static public System.Byte BUCKET_INVALID
    static void _set_BUCKET_INVALID(uint8_t value);
    // static field const value: static private System.Int32 PTR_SIZE
    static constexpr const int PTR_SIZE = 8;
    // Get static field: static private System.Int32 PTR_SIZE
    static int _get_PTR_SIZE();
    // Set static field: static private System.Int32 PTR_SIZE
    static void _set_PTR_SIZE(int value);
    // Get instance field reference: private System.Byte* _root
    [[deprecated("Use field access instead!")]] uint8_t*& dyn__root();
    // Get instance field reference: private System.Byte* _heap
    [[deprecated("Use field access instead!")]] uint8_t*& dyn__heap();
    // Get instance field reference: private System.Byte* _meta
    [[deprecated("Use field access instead!")]] uint8_t*& dyn__meta();
    // Get instance field reference: private System.Void* _globals
    [[deprecated("Use field access instead!")]] void*& dyn__globals();
    // Get instance field reference: private System.Void* _checksum
    [[deprecated("Use field access instead!")]] void*& dyn__checksum();
    // Get instance field reference: private System.Void* _replicate
    [[deprecated("Use field access instead!")]] void*& dyn__replicate();
    // Get instance field reference: private Fusion.Allocator/Block* _blocks
    [[deprecated("Use field access instead!")]] ::Fusion::Allocator::Block*& dyn__blocks();
    // Get instance field reference: private Fusion.Allocator/BlockList* _blocksFreeList
    [[deprecated("Use field access instead!")]] ::Fusion::Allocator::BlockList*& dyn__blocksFreeList();
    // Get instance field reference: private Fusion.Allocator/Bucket* _buckets
    [[deprecated("Use field access instead!")]] ::Fusion::Allocator::Bucket*& dyn__buckets();
    // Get instance field reference: private System.Byte* _bucketsMap
    [[deprecated("Use field access instead!")]] uint8_t*& dyn__bucketsMap();
    // Get instance field reference: private Fusion.Allocator/BlockList* _bucketsLists
    [[deprecated("Use field access instead!")]] ::Fusion::Allocator::BlockList*& dyn__bucketsLists();
    // Get instance field reference: private Fusion.Allocator/Config _config
    [[deprecated("Use field access instead!")]] ::Fusion::Allocator::Config& dyn__config();
    // Get instance field reference: private System.Int32 _maxBlockIndexUsed
    [[deprecated("Use field access instead!")]] int& dyn__maxBlockIndexUsed();
    // Get instance field reference: private System.Int32 _checksumByteLength
    [[deprecated("Use field access instead!")]] int& dyn__checksumByteLength();
    // Get instance field reference: private System.Int32 _replicateByteLength
    [[deprecated("Use field access instead!")]] int& dyn__replicateByteLength();
    // Fusion.Allocator/Config get_Configuration()
    // Offset: 0x2AFCC14
    ::Fusion::Allocator::Config get_Configuration();
    // System.Void* get_Globals()
    // Offset: 0x2AFCC24
    void* get_Globals();
    // System.Void* get_Checksum()
    // Offset: 0x2AFCC2C
    void* get_Checksum();
    // System.Int32* get_Replicate()
    // Offset: 0x2AFCC34
    int* get_Replicate();
    // System.Int32 get_ChecksumByteLength()
    // Offset: 0x2AFCC3C
    int get_ChecksumByteLength();
    // System.Int32 get_ReplicateByteLength()
    // Offset: 0x2AFCC44
    int get_ReplicateByteLength();
    // System.Int32 get_ReplicateWordLength()
    // Offset: 0x2AFCC4C
    int get_ReplicateWordLength();
    // System.Int32 get_ReplicateHeapWordOffset()
    // Offset: 0x2AFCC64
    int get_ReplicateHeapWordOffset();
    // private Fusion.Ptr Meta(System.Void* p)
    // Offset: 0x2AFCC84
    ::Fusion::Ptr Meta(void* p);
    // private System.Void* Meta(Fusion.Ptr ptr)
    // Offset: 0x2AFCC90
    void* Meta(::Fusion::Ptr ptr);
    // System.Int32 GetReplicateWordOffset(System.Void* ptr)
    // Offset: 0x2AFCC9C
    int GetReplicateWordOffset(void* ptr);
    // System.Int32 GetReplicateWordOffset(Fusion.Ptr ptr)
    // Offset: 0x2AFCCC4
    int GetReplicateWordOffset(::Fusion::Ptr ptr);
    // Fusion.Ptr Ptr(System.Void* p)
    // Offset: 0x2AFCCE8
    ::Fusion::Ptr Ptr(void* p);
    // System.Void* Ptr(Fusion.Ptr ptr)
    // Offset: 0x2AFCCF4
    void* Ptr(::Fusion::Ptr ptr);
    // T* Ptr(Fusion.Ptr ptr)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    T* Ptr(::Fusion::Ptr ptr) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Allocator::Ptr");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(*this, "Ptr", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(ptr)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(this, ___generic__method, ptr);
    }
    // private System.Boolean IsPointerInMeta(System.Void* p)
    // Offset: 0x2AFCD00
    bool IsPointerInMeta(void* p);
    // System.Boolean IsPointerInHeap(System.Void* p)
    // Offset: 0x2AFCD24
    bool IsPointerInHeap(void* p);
    // static private System.Int32 WordCount(System.Int32 size)
    // Offset: 0x2AFCD5C
    static int WordCount(int size);
    // private Fusion.Allocator/Bucket* GetBucket(System.Int32 index)
    // Offset: 0x2AFCD68
    ::Fusion::Allocator::Bucket* GetBucket(int index);
    // private Fusion.Allocator/Bucket* GetBucketForBlock(Fusion.Allocator/Block* block)
    // Offset: 0x2AFCD74
    ::Fusion::Allocator::Bucket* GetBucketForBlock(::Fusion::Allocator::Block* block);
    // private Fusion.Allocator/BlockList* GetBucketList(System.Int32 index)
    // Offset: 0x2AFCD94
    ::Fusion::Allocator::BlockList* GetBucketList(int index);
    // private Fusion.Allocator/Block* GetBlock(System.Int32 index)
    // Offset: 0x2AFCDA0
    ::Fusion::Allocator::Block* GetBlock(int index);
    // private Fusion.Allocator/Block* GetBlock(System.Int64 index)
    // Offset: 0x2AFCDB0
    ::Fusion::Allocator::Block* GetBlock(int64_t index);
    // private System.Int32 GetBlockBucket(System.Int64 index)
    // Offset: 0x2AFCDC0
    int GetBlockBucket(int64_t index);
    // private Fusion.Allocator/Block* GetBlockForPointer(System.Void* ptr)
    // Offset: 0x2AFCDE4
    ::Fusion::Allocator::Block* GetBlockForPointer(void* ptr);
    // private System.Int32 GetBlockIndexForPointer(System.Void* ptr)
    // Offset: 0x2AFCE04
    int GetBlockIndexForPointer(void* ptr);
    // private System.Byte* GetBlockMemory(Fusion.Allocator/Block* block)
    // Offset: 0x2AFCE18
    uint8_t* GetBlockMemory(::Fusion::Allocator::Block* block);
    // private System.Byte* GetBlockMemory(System.Int64 blockIndex)
    // Offset: 0x2AFCE64
    uint8_t* GetBlockMemory(int64_t blockIndex);
    // System.Boolean TryGetSegmentRoot(System.Void* ptr, out System.Void* root)
    // Offset: 0x2AFCE80
    bool TryGetSegmentRoot(void* ptr, ByRef<void*> root);
    // System.Void* GetSegmentRoot(System.Void* ptr)
    // Offset: 0x2AFCF18
    void* GetSegmentRoot(void* ptr);
    // static T* AllocArray(Fusion.Allocator* s, System.Int32 length)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* AllocArray(::Fusion::Allocator* s, int length) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Allocator::AllocArray");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Allocator", "AllocArray", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(s), ::il2cpp_utils::ExtractType(length)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, s, length);
    }
    // static T* AllocAndClearArray(Fusion.Allocator* s, System.Int32 length)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* AllocAndClearArray(::Fusion::Allocator* s, int length) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Allocator::AllocAndClearArray");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Allocator", "AllocAndClearArray", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(s), ::il2cpp_utils::ExtractType(length)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, s, length);
    }
    // static T* Alloc(Fusion.Allocator* s)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* Alloc(::Fusion::Allocator* s) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Allocator::Alloc");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Allocator", "Alloc", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(s)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, s);
    }
    // static T* AllocAndClear(Fusion.Allocator* s)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* AllocAndClear(::Fusion::Allocator* s) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Allocator::AllocAndClear");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Allocator", "AllocAndClear", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(s)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, s);
    }
    // static System.Void* AllocAndClear(Fusion.Allocator* a, System.Int32 size)
    // Offset: 0x2AFCF94
    static void* AllocAndClear(::Fusion::Allocator* a, int size);
    // static System.Int32 GetWordLengthForReplication(Fusion.Allocator* allocator)
    // Offset: 0x2AFD1E8
    static int GetWordLengthForReplication(::Fusion::Allocator* allocator);
    // static System.Int32 GetByteLengthForReplication(Fusion.Allocator* allocator)
    // Offset: 0x2AFD208
    static int GetByteLengthForReplication(::Fusion::Allocator* allocator);
    // static System.String PrintDebugInfo(Fusion.Allocator* allocator)
    // Offset: 0x2AFD254
    static ::StringW PrintDebugInfo(::Fusion::Allocator* allocator);
    // static System.Void DeltaPack(Fusion.Simulation/IDeltaCompressor compressor, Fusion.Allocator* current, Fusion.Allocator* shared, Fusion.Sockets.NetBitBuffer* b)
    // Offset: 0x2AFD590
    static void DeltaPack(::Fusion::Simulation::IDeltaCompressor* compressor, ::Fusion::Allocator* current, ::Fusion::Allocator* shared, ::Fusion::Sockets::NetBitBuffer* b);
    // static System.Void DeltaUnpack(Fusion.Allocator* target, Fusion.Allocator* shared, Fusion.Sockets.NetBitBuffer* b)
    // Offset: 0x2AFD734
    static void DeltaUnpack(::Fusion::Allocator* target, ::Fusion::Allocator* shared, ::Fusion::Sockets::NetBitBuffer* b);
    // System.Boolean CanAllocSize(System.Int32 size)
    // Offset: 0x2AFD84C
    bool CanAllocSize(int size);
    // System.Boolean CanAllocSizeAssert_Temp(System.Int32 size)
    // Offset: 0x2AFD874
    bool CanAllocSizeAssert_Temp(int size);
    // static System.Void* Alloc(Fusion.Allocator* a, System.Int32 size)
    // Offset: 0x2AFCFC4
    static void* Alloc(::Fusion::Allocator* a, int size);
    // static private System.Void* TryAllocateSegmentFromBlock(Fusion.Allocator* a, Fusion.Allocator/Bucket* bucket, Fusion.Allocator/Block* block, System.Int32 size)
    // Offset: 0x2AFD99C
    static void* TryAllocateSegmentFromBlock(::Fusion::Allocator* a, ::Fusion::Allocator::Bucket* bucket, ::Fusion::Allocator::Block* block, int size);
    // static System.Void Free(Fusion.Allocator* a, System.Void* ptr)
    // Offset: 0x2AFDBCC
    static void Free(::Fusion::Allocator* a, void* ptr);
    // static private System.Void DebugVerifyBucketIntegrity(Fusion.Allocator* a, System.Int32 index)
    // Offset: 0x2AFDDD4
    static void DebugVerifyBucketIntegrity(::Fusion::Allocator* a, int index);
    // static System.Void Dispose(Fusion.Allocator* a)
    // Offset: 0x2AFDE44
    static void Dispose(::Fusion::Allocator* a);
    // static System.Void Copy(Fusion.Allocator* from, Fusion.Allocator* to, System.Boolean onlyUsed)
    // Offset: 0x2AFDE54
    static void Copy(::Fusion::Allocator* from, ::Fusion::Allocator* to, bool onlyUsed);
    // static Fusion.Allocator* Create(Fusion.Allocator/Config config)
    // Offset: 0x2AFDEA8
    static ::Fusion::Allocator* Create(::Fusion::Allocator::Config config);
  }; // Fusion.Allocator
  #pragma pack(pop)
  static check_size<sizeof(Allocator), 108 + sizeof(int)> __Fusion_AllocatorSizeCheck;
  static_assert(sizeof(Allocator) == 0x70);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Fusion::Allocator::Config, "Fusion", "Allocator/Config");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Fusion::Allocator::get_Configuration
// Il2CppName: get_Configuration
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator::Config (Fusion::Allocator::*)()>(&Fusion::Allocator::get_Configuration)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_Configuration", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::get_Globals
// Il2CppName: get_Globals
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (Fusion::Allocator::*)()>(&Fusion::Allocator::get_Globals)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_Globals", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::get_Checksum
// Il2CppName: get_Checksum
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (Fusion::Allocator::*)()>(&Fusion::Allocator::get_Checksum)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_Checksum", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::get_Replicate
// Il2CppName: get_Replicate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int* (Fusion::Allocator::*)()>(&Fusion::Allocator::get_Replicate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_Replicate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::get_ChecksumByteLength
// Il2CppName: get_ChecksumByteLength
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)()>(&Fusion::Allocator::get_ChecksumByteLength)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_ChecksumByteLength", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::get_ReplicateByteLength
// Il2CppName: get_ReplicateByteLength
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)()>(&Fusion::Allocator::get_ReplicateByteLength)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_ReplicateByteLength", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::get_ReplicateWordLength
// Il2CppName: get_ReplicateWordLength
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)()>(&Fusion::Allocator::get_ReplicateWordLength)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_ReplicateWordLength", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::get_ReplicateHeapWordOffset
// Il2CppName: get_ReplicateHeapWordOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)()>(&Fusion::Allocator::get_ReplicateHeapWordOffset)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "get_ReplicateHeapWordOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Meta
// Il2CppName: Meta
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Ptr (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::Meta)> {
  static const MethodInfo* get() {
    static auto* p = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Meta", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Meta
// Il2CppName: Meta
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (Fusion::Allocator::*)(::Fusion::Ptr)>(&Fusion::Allocator::Meta)> {
  static const MethodInfo* get() {
    static auto* ptr = &::il2cpp_utils::GetClassFromName("Fusion", "Ptr")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Meta", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetReplicateWordOffset
// Il2CppName: GetReplicateWordOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::GetReplicateWordOffset)> {
  static const MethodInfo* get() {
    static auto* ptr = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetReplicateWordOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetReplicateWordOffset
// Il2CppName: GetReplicateWordOffset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)(::Fusion::Ptr)>(&Fusion::Allocator::GetReplicateWordOffset)> {
  static const MethodInfo* get() {
    static auto* ptr = &::il2cpp_utils::GetClassFromName("Fusion", "Ptr")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetReplicateWordOffset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Ptr
// Il2CppName: Ptr
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Ptr (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::Ptr)> {
  static const MethodInfo* get() {
    static auto* p = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Ptr", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Ptr
// Il2CppName: Ptr
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (Fusion::Allocator::*)(::Fusion::Ptr)>(&Fusion::Allocator::Ptr)> {
  static const MethodInfo* get() {
    static auto* ptr = &::il2cpp_utils::GetClassFromName("Fusion", "Ptr")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Ptr", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Ptr
// Il2CppName: Ptr
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Allocator::IsPointerInMeta
// Il2CppName: IsPointerInMeta
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::IsPointerInMeta)> {
  static const MethodInfo* get() {
    static auto* p = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "IsPointerInMeta", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::IsPointerInHeap
// Il2CppName: IsPointerInHeap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::IsPointerInHeap)> {
  static const MethodInfo* get() {
    static auto* p = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "IsPointerInHeap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{p});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::WordCount
// Il2CppName: WordCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(int)>(&Fusion::Allocator::WordCount)> {
  static const MethodInfo* get() {
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "WordCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{size});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBucket
// Il2CppName: GetBucket
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator::Bucket* (Fusion::Allocator::*)(int)>(&Fusion::Allocator::GetBucket)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBucket", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBucketForBlock
// Il2CppName: GetBucketForBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator::Bucket* (Fusion::Allocator::*)(::Fusion::Allocator::Block*)>(&Fusion::Allocator::GetBucketForBlock)> {
  static const MethodInfo* get() {
    static auto* block = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator/Block"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBucketForBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{block});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBucketList
// Il2CppName: GetBucketList
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator::BlockList* (Fusion::Allocator::*)(int)>(&Fusion::Allocator::GetBucketList)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBucketList", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBlock
// Il2CppName: GetBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator::Block* (Fusion::Allocator::*)(int)>(&Fusion::Allocator::GetBlock)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBlock
// Il2CppName: GetBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator::Block* (Fusion::Allocator::*)(int64_t)>(&Fusion::Allocator::GetBlock)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int64")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBlockBucket
// Il2CppName: GetBlockBucket
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)(int64_t)>(&Fusion::Allocator::GetBlockBucket)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int64")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBlockBucket", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBlockForPointer
// Il2CppName: GetBlockForPointer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator::Block* (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::GetBlockForPointer)> {
  static const MethodInfo* get() {
    static auto* ptr = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBlockForPointer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBlockIndexForPointer
// Il2CppName: GetBlockIndexForPointer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::GetBlockIndexForPointer)> {
  static const MethodInfo* get() {
    static auto* ptr = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBlockIndexForPointer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBlockMemory
// Il2CppName: GetBlockMemory
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<uint8_t* (Fusion::Allocator::*)(::Fusion::Allocator::Block*)>(&Fusion::Allocator::GetBlockMemory)> {
  static const MethodInfo* get() {
    static auto* block = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator/Block"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBlockMemory", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{block});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetBlockMemory
// Il2CppName: GetBlockMemory
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<uint8_t* (Fusion::Allocator::*)(int64_t)>(&Fusion::Allocator::GetBlockMemory)> {
  static const MethodInfo* get() {
    static auto* blockIndex = &::il2cpp_utils::GetClassFromName("System", "Int64")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetBlockMemory", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{blockIndex});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::TryGetSegmentRoot
// Il2CppName: TryGetSegmentRoot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::Allocator::*)(void*, ByRef<void*>)>(&Fusion::Allocator::TryGetSegmentRoot)> {
  static const MethodInfo* get() {
    static auto* ptr = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* root = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "TryGetSegmentRoot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr, root});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetSegmentRoot
// Il2CppName: GetSegmentRoot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (Fusion::Allocator::*)(void*)>(&Fusion::Allocator::GetSegmentRoot)> {
  static const MethodInfo* get() {
    static auto* ptr = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetSegmentRoot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::AllocArray
// Il2CppName: AllocArray
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Allocator::AllocAndClearArray
// Il2CppName: AllocAndClearArray
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Allocator::Alloc
// Il2CppName: Alloc
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Allocator::AllocAndClear
// Il2CppName: AllocAndClear
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Allocator::AllocAndClear
// Il2CppName: AllocAndClear
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (*)(::Fusion::Allocator*, int)>(&Fusion::Allocator::AllocAndClear)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "AllocAndClear", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, size});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetWordLengthForReplication
// Il2CppName: GetWordLengthForReplication
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(::Fusion::Allocator*)>(&Fusion::Allocator::GetWordLengthForReplication)> {
  static const MethodInfo* get() {
    static auto* allocator = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetWordLengthForReplication", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{allocator});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::GetByteLengthForReplication
// Il2CppName: GetByteLengthForReplication
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(::Fusion::Allocator*)>(&Fusion::Allocator::GetByteLengthForReplication)> {
  static const MethodInfo* get() {
    static auto* allocator = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "GetByteLengthForReplication", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{allocator});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::PrintDebugInfo
// Il2CppName: PrintDebugInfo
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (*)(::Fusion::Allocator*)>(&Fusion::Allocator::PrintDebugInfo)> {
  static const MethodInfo* get() {
    static auto* allocator = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "PrintDebugInfo", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{allocator});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::DeltaPack
// Il2CppName: DeltaPack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::Simulation::IDeltaCompressor*, ::Fusion::Allocator*, ::Fusion::Allocator*, ::Fusion::Sockets::NetBitBuffer*)>(&Fusion::Allocator::DeltaPack)> {
  static const MethodInfo* get() {
    static auto* compressor = &::il2cpp_utils::GetClassFromName("Fusion", "Simulation/IDeltaCompressor")->byval_arg;
    static auto* current = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* shared = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* b = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion.Sockets", "NetBitBuffer"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "DeltaPack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{compressor, current, shared, b});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::DeltaUnpack
// Il2CppName: DeltaUnpack
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::Allocator*, ::Fusion::Allocator*, ::Fusion::Sockets::NetBitBuffer*)>(&Fusion::Allocator::DeltaUnpack)> {
  static const MethodInfo* get() {
    static auto* target = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* shared = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* b = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion.Sockets", "NetBitBuffer"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "DeltaUnpack", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{target, shared, b});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::CanAllocSize
// Il2CppName: CanAllocSize
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::Allocator::*)(int)>(&Fusion::Allocator::CanAllocSize)> {
  static const MethodInfo* get() {
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "CanAllocSize", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{size});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::CanAllocSizeAssert_Temp
// Il2CppName: CanAllocSizeAssert_Temp
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::Allocator::*)(int)>(&Fusion::Allocator::CanAllocSizeAssert_Temp)> {
  static const MethodInfo* get() {
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "CanAllocSizeAssert_Temp", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{size});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Alloc
// Il2CppName: Alloc
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (*)(::Fusion::Allocator*, int)>(&Fusion::Allocator::Alloc)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Alloc", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, size});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::TryAllocateSegmentFromBlock
// Il2CppName: TryAllocateSegmentFromBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (*)(::Fusion::Allocator*, ::Fusion::Allocator::Bucket*, ::Fusion::Allocator::Block*, int)>(&Fusion::Allocator::TryAllocateSegmentFromBlock)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* bucket = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator/Bucket"))->byval_arg;
    static auto* block = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator/Block"))->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "TryAllocateSegmentFromBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, bucket, block, size});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Free
// Il2CppName: Free
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::Allocator*, void*)>(&Fusion::Allocator::Free)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* ptr = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Free", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, ptr});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::DebugVerifyBucketIntegrity
// Il2CppName: DebugVerifyBucketIntegrity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::Allocator*, int)>(&Fusion::Allocator::DebugVerifyBucketIntegrity)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "DebugVerifyBucketIntegrity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a, index});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Dispose
// Il2CppName: Dispose
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::Allocator*)>(&Fusion::Allocator::Dispose)> {
  static const MethodInfo* get() {
    static auto* a = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Dispose", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{a});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Copy
// Il2CppName: Copy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::Allocator*, ::Fusion::Allocator*, bool)>(&Fusion::Allocator::Copy)> {
  static const MethodInfo* get() {
    static auto* from = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* to = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("Fusion", "Allocator"))->byval_arg;
    static auto* onlyUsed = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Copy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{from, to, onlyUsed});
  }
};
// Writing MetadataGetter for method: Fusion::Allocator::Create
// Il2CppName: Create
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::Allocator* (*)(::Fusion::Allocator::Config)>(&Fusion::Allocator::Create)> {
  static const MethodInfo* get() {
    static auto* config = &::il2cpp_utils::GetClassFromName("Fusion", "Allocator/Config")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Allocator), "Create", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{config});
  }
};
