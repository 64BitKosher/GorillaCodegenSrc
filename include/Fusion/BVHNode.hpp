// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.ValueType
#include "System/ValueType.hpp"
// Including type: UnityEngine.Bounds
#include "UnityEngine/Bounds.hpp"
// Including type: Fusion.NetworkBehaviourId
#include "Fusion/NetworkBehaviourId.hpp"
// Including type: Fusion.HitboxRoot
#include "Fusion/HitboxRoot.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Fusion
namespace Fusion {
  // Forward declaring type: BVH
  class BVH;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Forward declaring namespace: System::Text
namespace System::Text {
  // Forward declaring type: StringBuilder
  class StringBuilder;
}
// Completed forward declares
// Type namespace: Fusion
namespace Fusion {
  // Forward declaring type: BVHNode
  struct BVHNode;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Fusion::BVHNode, "Fusion", "BVHNode");
// Type namespace: Fusion
namespace Fusion {
  // Size: 0x79
  #pragma pack(push, 1)
  // WARNING Layout: Sequential may not be correctly taken into account!
  // Autogenerated type: Fusion.BVHNode
  // [TokenAttribute] Offset: FFFFFFFF
  struct BVHNode/*, public ::System::ValueType*/ {
    public:
    // Nested type: ::Fusion::BVHNode::CachedBounds
    struct CachedBounds;
    // Nested type: ::Fusion::BVHNode::Rot
    struct Rot;
    // Size: 0x30
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: Fusion.BVHNode/CachedBounds
    // [TokenAttribute] Offset: FFFFFFFF
    struct CachedBounds/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.Vector3 Center
      // Size: 0xC
      // Offset: 0x0
      ::UnityEngine::Vector3 Center;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Vector3 Extents
      // Size: 0xC
      // Offset: 0xC
      ::UnityEngine::Vector3 Extents;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Vector3 Min
      // Size: 0xC
      // Offset: 0x18
      ::UnityEngine::Vector3 Min;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public UnityEngine.Vector3 Max
      // Size: 0xC
      // Offset: 0x24
      ::UnityEngine::Vector3 Max;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      public:
      // Creating value type constructor for type: CachedBounds
      constexpr CachedBounds(::UnityEngine::Vector3 Center_ = {}, ::UnityEngine::Vector3 Extents_ = {}, ::UnityEngine::Vector3 Min_ = {}, ::UnityEngine::Vector3 Max_ = {}) noexcept : Center{Center_}, Extents{Extents_}, Min{Min_}, Max{Max_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.Vector3 Center
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_Center();
      // Get instance field reference: public UnityEngine.Vector3 Extents
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_Extents();
      // Get instance field reference: public UnityEngine.Vector3 Min
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_Min();
      // Get instance field reference: public UnityEngine.Vector3 Max
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_Max();
      // public System.Void .ctor(UnityEngine.Bounds bounds)
      // Offset: 0x2B370D0
      CachedBounds(::UnityEngine::Bounds bounds);
      // public System.Void .ctor(UnityEngine.Vector3 center, UnityEngine.Vector3 extents)
      // Offset: 0x2B372A0
      CachedBounds(::UnityEngine::Vector3 center, ::UnityEngine::Vector3 extents);
    }; // Fusion.BVHNode/CachedBounds
    #pragma pack(pop)
    static check_size<sizeof(BVHNode::CachedBounds), 36 + sizeof(::UnityEngine::Vector3)> __Fusion_BVHNode_CachedBoundsSizeCheck;
    static_assert(sizeof(BVHNode::CachedBounds) == 0x30);
    public:
    // public UnityEngine.Bounds Box
    // Size: 0x18
    // Offset: 0x0
    ::UnityEngine::Bounds Box;
    // Field size check
    static_assert(sizeof(::UnityEngine::Bounds) == 0x18);
    // Fusion.BVHNode/CachedBounds _cachedBounds
    // Size: 0x30
    // Offset: 0x18
    ::Fusion::BVHNode::CachedBounds cachedBounds;
    // Field size check
    static_assert(sizeof(::Fusion::BVHNode::CachedBounds) == 0x30);
    // private System.Int32 _nodeIndex
    // Size: 0x4
    // Offset: 0x48
    int nodeIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _parentIndex
    // Size: 0x4
    // Offset: 0x4C
    int parentIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _leftIndex
    // Size: 0x4
    // Offset: 0x50
    int leftIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _rightIndex
    // Size: 0x4
    // Offset: 0x54
    int rightIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // System.Boolean Active
    // Size: 0x1
    // Offset: 0x58
    bool Active;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: Active and: Depth
    char __padding6[0x3] = {};
    // System.Int32 Depth
    // Size: 0x4
    // Offset: 0x5C
    int Depth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // System.Boolean Used
    // Size: 0x1
    // Offset: 0x60
    bool Used;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: Used and: Next
    char __padding8[0x3] = {};
    // System.Int32 Next
    // Size: 0x4
    // Offset: 0x64
    int Next;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Fusion.HitboxRoot _root
    // Size: 0x8
    // Offset: 0x68
    ::Fusion::HitboxRoot* root;
    // Field size check
    static_assert(sizeof(::Fusion::HitboxRoot*) == 0x8);
    // Fusion.NetworkBehaviourId _rootId
    // Size: 0x8
    // Offset: 0x70
    ::Fusion::NetworkBehaviourId rootId;
    // Field size check
    static_assert(sizeof(::Fusion::NetworkBehaviourId) == 0x8);
    // System.Boolean _isLeaf
    // Size: 0x1
    // Offset: 0x78
    bool isLeaf;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Creating value type constructor for type: BVHNode
    constexpr BVHNode(::UnityEngine::Bounds Box_ = {}, ::Fusion::BVHNode::CachedBounds cachedBounds_ = {}, int nodeIndex_ = {}, int parentIndex_ = {}, int leftIndex_ = {}, int rightIndex_ = {}, bool Active_ = {}, int Depth_ = {}, bool Used_ = {}, int Next_ = {}, ::Fusion::HitboxRoot* root_ = {}, ::Fusion::NetworkBehaviourId rootId_ = {}, bool isLeaf_ = {}) noexcept : Box{Box_}, cachedBounds{cachedBounds_}, nodeIndex{nodeIndex_}, parentIndex{parentIndex_}, leftIndex{leftIndex_}, rightIndex{rightIndex_}, Active{Active_}, Depth{Depth_}, Used{Used_}, Next{Next_}, root{root_}, rootId{rootId_}, isLeaf{isLeaf_} {}
    // Creating interface conversion operator: operator ::System::ValueType
    operator ::System::ValueType() noexcept {
      return *reinterpret_cast<::System::ValueType*>(this);
    }
    // static field const value: static System.Int32 MaxEntriesPerNode
    static constexpr const int MaxEntriesPerNode = 1;
    // Get static field: static System.Int32 MaxEntriesPerNode
    static int _get_MaxEntriesPerNode();
    // Set static field: static System.Int32 MaxEntriesPerNode
    static void _set_MaxEntriesPerNode(int value);
    // static field const value: static System.Int32 RootNodeIndex
    static constexpr const int RootNodeIndex = 1;
    // Get static field: static System.Int32 RootNodeIndex
    static int _get_RootNodeIndex();
    // Set static field: static System.Int32 RootNodeIndex
    static void _set_RootNodeIndex(int value);
    // Get static field: static private readonly Fusion.HitboxRoot/HitboxComparerX ComparerX
    static ::Fusion::HitboxRoot::HitboxComparerX* _get_ComparerX();
    // Set static field: static private readonly Fusion.HitboxRoot/HitboxComparerX ComparerX
    static void _set_ComparerX(::Fusion::HitboxRoot::HitboxComparerX* value);
    // Get static field: static private readonly Fusion.HitboxRoot/HitboxComparerY ComparerY
    static ::Fusion::HitboxRoot::HitboxComparerY* _get_ComparerY();
    // Set static field: static private readonly Fusion.HitboxRoot/HitboxComparerY ComparerY
    static void _set_ComparerY(::Fusion::HitboxRoot::HitboxComparerY* value);
    // Get static field: static private readonly Fusion.HitboxRoot/HitboxComparerZ ComparerZ
    static ::Fusion::HitboxRoot::HitboxComparerZ* _get_ComparerZ();
    // Set static field: static private readonly Fusion.HitboxRoot/HitboxComparerZ ComparerZ
    static void _set_ComparerZ(::Fusion::HitboxRoot::HitboxComparerZ* value);
    // Get instance field reference: public UnityEngine.Bounds Box
    [[deprecated("Use field access instead!")]] ::UnityEngine::Bounds& dyn_Box();
    // Get instance field reference: Fusion.BVHNode/CachedBounds _cachedBounds
    [[deprecated("Use field access instead!")]] ::Fusion::BVHNode::CachedBounds& dyn__cachedBounds();
    // Get instance field reference: private System.Int32 _nodeIndex
    [[deprecated("Use field access instead!")]] int& dyn__nodeIndex();
    // Get instance field reference: private System.Int32 _parentIndex
    [[deprecated("Use field access instead!")]] int& dyn__parentIndex();
    // Get instance field reference: private System.Int32 _leftIndex
    [[deprecated("Use field access instead!")]] int& dyn__leftIndex();
    // Get instance field reference: private System.Int32 _rightIndex
    [[deprecated("Use field access instead!")]] int& dyn__rightIndex();
    // Get instance field reference: System.Boolean Active
    [[deprecated("Use field access instead!")]] bool& dyn_Active();
    // Get instance field reference: System.Int32 Depth
    [[deprecated("Use field access instead!")]] int& dyn_Depth();
    // Get instance field reference: System.Boolean Used
    [[deprecated("Use field access instead!")]] bool& dyn_Used();
    // Get instance field reference: System.Int32 Next
    [[deprecated("Use field access instead!")]] int& dyn_Next();
    // Get instance field reference: Fusion.HitboxRoot _root
    [[deprecated("Use field access instead!")]] ::Fusion::HitboxRoot*& dyn__root();
    // Get instance field reference: Fusion.NetworkBehaviourId _rootId
    [[deprecated("Use field access instead!")]] ::Fusion::NetworkBehaviourId& dyn__rootId();
    // Get instance field reference: System.Boolean _isLeaf
    [[deprecated("Use field access instead!")]] bool& dyn__isLeaf();
    // System.Int32 get_Index()
    // Offset: 0x2B34A7C
    int get_Index();
    // System.Boolean get_IsValid()
    // Offset: 0x2B34A84
    bool get_IsValid();
    // System.Boolean get_IsRootNode()
    // Offset: 0x2B34A94
    bool get_IsRootNode();
    // System.Boolean get_HasParent()
    // Offset: 0x2B34AA4
    bool get_HasParent();
    // System.Boolean get_HasLeft()
    // Offset: 0x2B34AB4
    bool get_HasLeft();
    // System.Boolean get_HasRight()
    // Offset: 0x2B34AC4
    bool get_HasRight();
    // Fusion.BVHNode GetParent(Fusion.BVH bvh)
    // Offset: 0x2B34AD4
    ::Fusion::BVHNode GetParent(::Fusion::BVH* bvh);
    // Fusion.BVHNode GetRight(Fusion.BVH bvh)
    // Offset: 0x2B34B0C
    ::Fusion::BVHNode GetRight(::Fusion::BVH* bvh);
    // Fusion.BVHNode GetLeft(Fusion.BVH bvh)
    // Offset: 0x2B34B44
    ::Fusion::BVHNode GetLeft(::Fusion::BVH* bvh);
    // System.Boolean get_IsLeaf()
    // Offset: 0x2B34C00
    bool get_IsLeaf();
    // System.Boolean get_HasValidRoot()
    // Offset: 0x2B34C08
    bool get_HasValidRoot();
    // System.Void RefitObjectChanged(Fusion.BVH bvh)
    // Offset: 0x2B34CF8
    void RefitObjectChanged(::Fusion::BVH* bvh);
    // private System.Void ExpandVolume(Fusion.BVH bvh, UnityEngine.Vector3 objectpos, System.Single radius, ref UnityEngine.Bounds bounds, System.Boolean expandParent)
    // Offset: 0x2B34D9C
    void ExpandVolume(::Fusion::BVH* bvh, ::UnityEngine::Vector3 objectpos, float radius, ByRef<::UnityEngine::Bounds> bounds, bool expandParent);
    // private System.Void AssignVolume(UnityEngine.Vector3 pos, System.Single radius, ref UnityEngine.Bounds bounds)
    // Offset: 0x2B35324
    void AssignVolume(::UnityEngine::Vector3 pos, float radius, ByRef<::UnityEngine::Bounds> bounds);
    // private System.Void ComputeVolume(Fusion.BVH bvh)
    // Offset: 0x2B353A8
    void ComputeVolume(::Fusion::BVH* bvh);
    // private UnityEngine.Bounds ComputeMinVolume(Fusion.BVH bvh)
    // Offset: 0x2B3584C
    ::UnityEngine::Bounds ComputeMinVolume(::Fusion::BVH* bvh);
    // private System.Boolean RefitVolume(Fusion.BVH bvh)
    // Offset: 0x2B359C4
    bool RefitVolume(::Fusion::BVH* bvh);
    // static System.Single SA(UnityEngine.Bounds box)
    // Offset: 0x2B35B4C
    static float SA(::UnityEngine::Bounds box);
    // static System.Single SA(ref UnityEngine.Bounds box)
    // Offset: 0x2B32D84
    static float SA_(ByRef<::UnityEngine::Bounds> box);
    // static System.Single SA(ref Fusion.BVHNode node)
    // Offset: 0x2B35B90
    static float SA(ByRef<::Fusion::BVHNode> node);
    // static UnityEngine.Bounds AABBofPair(ref Fusion.BVHNode nodea, ref Fusion.BVHNode nodeb)
    // Offset: 0x2B35BD4
    static ::UnityEngine::Bounds AABBofPair(ByRef<::Fusion::BVHNode> nodea, ByRef<::Fusion::BVHNode> nodeb);
    // static private UnityEngine.Bounds GetEntryBounds(Fusion.HitboxRoot entry)
    // Offset: 0x2B35CB0
    static ::UnityEngine::Bounds GetEntryBounds(::Fusion::HitboxRoot* entry);
    // static private System.Single SAofList(System.Collections.Generic.List`1<Fusion.HitboxRoot> entries)
    // Offset: 0x2B35CF8
    static float SAofList(::System::Collections::Generic::List_1<::Fusion::HitboxRoot*>* entries);
    // System.Void TryRotate(Fusion.BVH bvh)
    // Offset: 0x2B32148
    void TryRotate(::Fusion::BVH* bvh);
    // System.Void SplitNode(Fusion.BVH bvh, System.Collections.Generic.List`1<Fusion.HitboxRoot> entries)
    // Offset: 0x2B360EC
    void SplitNode(::Fusion::BVH* bvh, ::System::Collections::Generic::List_1<::Fusion::HitboxRoot*>* entries);
    // static private System.Void AddObjectPushdown(Fusion.BVH bvh, ref Fusion.BVHNode curNode, Fusion.HitboxRoot entry)
    // Offset: 0x2B36458
    static void AddObjectPushdown(::Fusion::BVH* bvh, ByRef<::Fusion::BVHNode> curNode, ::Fusion::HitboxRoot* entry);
    // static System.Void Add(Fusion.BVH bvh, ref Fusion.BVHNode startNode, Fusion.HitboxRoot entry, ref UnityEngine.Bounds newObBox, System.Single newObSah)
    // Offset: 0x2B32DC8
    static void Add(::Fusion::BVH* bvh, ByRef<::Fusion::BVHNode> startNode, ::Fusion::HitboxRoot* entry, ByRef<::UnityEngine::Bounds> newObBox, float newObSah);
    // System.Int32 NodesCount(Fusion.BVH bvh)
    // Offset: 0x2B366E0
    int NodesCount(::Fusion::BVH* bvh);
    // System.Void Remove(Fusion.BVH bvh, Fusion.HitboxRoot entry)
    // Offset: 0x2B3362C
    void Remove(::Fusion::BVH* bvh, ::Fusion::HitboxRoot* entry);
    // private System.Void SetDepth(Fusion.BVH bvh, System.Int32 newdepth)
    // Offset: 0x2B36044
    void SetDepth(::Fusion::BVH* bvh, int newdepth);
    // private System.Void RemoveLeaf(Fusion.BVH bvh, System.Int32 removeIndex)
    // Offset: 0x2B367B8
    void RemoveLeaf(::Fusion::BVH* bvh, int removeIndex);
    // System.Void FindOverlappingLeaves(Fusion.BVH bvh, UnityEngine.Vector3 origin, System.Single radius, System.Collections.Generic.List`1<Fusion.BVHNode> overlapList)
    // Offset: 0x2B36AE4
    void FindOverlappingLeaves(::Fusion::BVH* bvh, ::UnityEngine::Vector3 origin, float radius, ::System::Collections::Generic::List_1<::Fusion::BVHNode>* overlapList);
    // private System.Boolean BoundsIntersectsSphere(UnityEngine.Bounds bounds, UnityEngine.Vector3 origin, System.Single radius)
    // Offset: 0x2B36D80
    bool BoundsIntersectsSphere(::UnityEngine::Bounds bounds, ::UnityEngine::Vector3 origin, float radius);
    // System.Void FindOverlappingLeaves(Fusion.BVH bvh, UnityEngine.Bounds aabb, System.Collections.Generic.List`1<Fusion.BVHNode> overlapList)
    // Offset: 0x2B36E0C
    void FindOverlappingLeaves(::Fusion::BVH* bvh, ::UnityEngine::Bounds aabb, ::System::Collections::Generic::List_1<::Fusion::BVHNode>* overlapList);
    // UnityEngine.Bounds ToBounds()
    // Offset: 0x2B36D04
    ::UnityEngine::Bounds ToBounds();
    // System.Void ChildExpanded(Fusion.BVH bvh, ref Fusion.BVHNode child)
    // Offset: 0x2B35038
    void ChildExpanded(::Fusion::BVH* bvh, ByRef<::Fusion::BVHNode> child);
    // private System.Void UpdateBoundsCache()
    // Offset: 0x2B37090
    void UpdateBoundsCache();
    // System.Void ChildRefit(Fusion.BVH bvh, System.Boolean propagate)
    // Offset: 0x2B37134
    void ChildRefit(::Fusion::BVH* bvh, bool propagate);
    // static System.Void ChildRefit(Fusion.BVH bvh, System.Int32 nodeIndex, System.Boolean propagate)
    // Offset: 0x2B3552C
    static void ChildRefit(::Fusion::BVH* bvh, int nodeIndex, bool propagate);
    // static System.Void InitNode(ref Fusion.BVHNode node, Fusion.BVH bvh, System.Int32 index, System.Int32 parentIndex, System.Int32 curDepth, System.Collections.Generic.List`1<Fusion.HitboxRoot> entries)
    // Offset: 0x2B339E0
    static void InitNode(ByRef<::Fusion::BVHNode> node, ::Fusion::BVH* bvh, int index, int parentIndex, int curDepth, ::System::Collections::Generic::List_1<::Fusion::HitboxRoot*>* entries);
    // public System.Void BuildLog(System.Text.StringBuilder builder)
    // Offset: 0x2B33F7C
    void BuildLog(::System::Text::StringBuilder* builder);
    // static private System.Void .cctor()
    // Offset: 0x2B371A4
    static void _cctor();
    // public override System.String ToString()
    // Offset: 0x2B34B7C
    // Implemented from: System.ValueType
    // Base method: System.String ValueType::ToString()
    ::StringW ToString();
  }; // Fusion.BVHNode
  #pragma pack(pop)
  static check_size<sizeof(BVHNode), 120 + sizeof(bool)> __Fusion_BVHNodeSizeCheck;
  static_assert(sizeof(BVHNode) == 0x79);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Fusion::BVHNode::CachedBounds, "Fusion", "BVHNode/CachedBounds");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Fusion::BVHNode::get_Index
// Il2CppName: get_Index
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_Index)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_Index", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::get_IsValid
// Il2CppName: get_IsValid
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_IsValid)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_IsValid", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::get_IsRootNode
// Il2CppName: get_IsRootNode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_IsRootNode)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_IsRootNode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::get_HasParent
// Il2CppName: get_HasParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_HasParent)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_HasParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::get_HasLeft
// Il2CppName: get_HasLeft
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_HasLeft)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_HasLeft", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::get_HasRight
// Il2CppName: get_HasRight
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_HasRight)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_HasRight", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::GetParent
// Il2CppName: GetParent
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::BVHNode (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::GetParent)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "GetParent", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::GetRight
// Il2CppName: GetRight
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::BVHNode (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::GetRight)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "GetRight", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::GetLeft
// Il2CppName: GetLeft
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::Fusion::BVHNode (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::GetLeft)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "GetLeft", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::get_IsLeaf
// Il2CppName: get_IsLeaf
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_IsLeaf)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_IsLeaf", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::get_HasValidRoot
// Il2CppName: get_HasValidRoot
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)()>(&Fusion::BVHNode::get_HasValidRoot)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "get_HasValidRoot", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::RefitObjectChanged
// Il2CppName: RefitObjectChanged
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::RefitObjectChanged)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "RefitObjectChanged", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ExpandVolume
// Il2CppName: ExpandVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, ::UnityEngine::Vector3, float, ByRef<::UnityEngine::Bounds>, bool)>(&Fusion::BVHNode::ExpandVolume)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* objectpos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* radius = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* bounds = &::il2cpp_utils::GetClassFromName("UnityEngine", "Bounds")->this_arg;
    static auto* expandParent = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ExpandVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, objectpos, radius, bounds, expandParent});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::AssignVolume
// Il2CppName: AssignVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::UnityEngine::Vector3, float, ByRef<::UnityEngine::Bounds>)>(&Fusion::BVHNode::AssignVolume)> {
  static const MethodInfo* get() {
    static auto* pos = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* radius = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* bounds = &::il2cpp_utils::GetClassFromName("UnityEngine", "Bounds")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "AssignVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pos, radius, bounds});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ComputeVolume
// Il2CppName: ComputeVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::ComputeVolume)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ComputeVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ComputeMinVolume
// Il2CppName: ComputeMinVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Bounds (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::ComputeMinVolume)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ComputeMinVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::RefitVolume
// Il2CppName: RefitVolume
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::RefitVolume)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "RefitVolume", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::SA
// Il2CppName: SA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (*)(::UnityEngine::Bounds)>(&Fusion::BVHNode::SA)> {
  static const MethodInfo* get() {
    static auto* box = &::il2cpp_utils::GetClassFromName("UnityEngine", "Bounds")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "SA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{box});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::SA_
// Il2CppName: SA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (*)(ByRef<::UnityEngine::Bounds>)>(&Fusion::BVHNode::SA_)> {
  static const MethodInfo* get() {
    static auto* box = &::il2cpp_utils::GetClassFromName("UnityEngine", "Bounds")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "SA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{box});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::SA
// Il2CppName: SA
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (*)(ByRef<::Fusion::BVHNode>)>(&Fusion::BVHNode::SA)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "SA", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::AABBofPair
// Il2CppName: AABBofPair
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Bounds (*)(ByRef<::Fusion::BVHNode>, ByRef<::Fusion::BVHNode>)>(&Fusion::BVHNode::AABBofPair)> {
  static const MethodInfo* get() {
    static auto* nodea = &::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")->this_arg;
    static auto* nodeb = &::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "AABBofPair", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{nodea, nodeb});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::GetEntryBounds
// Il2CppName: GetEntryBounds
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Bounds (*)(::Fusion::HitboxRoot*)>(&Fusion::BVHNode::GetEntryBounds)> {
  static const MethodInfo* get() {
    static auto* entry = &::il2cpp_utils::GetClassFromName("Fusion", "HitboxRoot")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "GetEntryBounds", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{entry});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::SAofList
// Il2CppName: SAofList
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (*)(::System::Collections::Generic::List_1<::Fusion::HitboxRoot*>*)>(&Fusion::BVHNode::SAofList)> {
  static const MethodInfo* get() {
    static auto* entries = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Fusion", "HitboxRoot")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "SAofList", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{entries});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::TryRotate
// Il2CppName: TryRotate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::TryRotate)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "TryRotate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::SplitNode
// Il2CppName: SplitNode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, ::System::Collections::Generic::List_1<::Fusion::HitboxRoot*>*)>(&Fusion::BVHNode::SplitNode)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* entries = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Fusion", "HitboxRoot")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "SplitNode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, entries});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::AddObjectPushdown
// Il2CppName: AddObjectPushdown
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::BVH*, ByRef<::Fusion::BVHNode>, ::Fusion::HitboxRoot*)>(&Fusion::BVHNode::AddObjectPushdown)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* curNode = &::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")->this_arg;
    static auto* entry = &::il2cpp_utils::GetClassFromName("Fusion", "HitboxRoot")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "AddObjectPushdown", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, curNode, entry});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::Add
// Il2CppName: Add
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::BVH*, ByRef<::Fusion::BVHNode>, ::Fusion::HitboxRoot*, ByRef<::UnityEngine::Bounds>, float)>(&Fusion::BVHNode::Add)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* startNode = &::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")->this_arg;
    static auto* entry = &::il2cpp_utils::GetClassFromName("Fusion", "HitboxRoot")->byval_arg;
    static auto* newObBox = &::il2cpp_utils::GetClassFromName("UnityEngine", "Bounds")->this_arg;
    static auto* newObSah = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "Add", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, startNode, entry, newObBox, newObSah});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::NodesCount
// Il2CppName: NodesCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (Fusion::BVHNode::*)(::Fusion::BVH*)>(&Fusion::BVHNode::NodesCount)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "NodesCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::Remove
// Il2CppName: Remove
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, ::Fusion::HitboxRoot*)>(&Fusion::BVHNode::Remove)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* entry = &::il2cpp_utils::GetClassFromName("Fusion", "HitboxRoot")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "Remove", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, entry});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::SetDepth
// Il2CppName: SetDepth
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, int)>(&Fusion::BVHNode::SetDepth)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* newdepth = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "SetDepth", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, newdepth});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::RemoveLeaf
// Il2CppName: RemoveLeaf
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, int)>(&Fusion::BVHNode::RemoveLeaf)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* removeIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "RemoveLeaf", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, removeIndex});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::FindOverlappingLeaves
// Il2CppName: FindOverlappingLeaves
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, ::UnityEngine::Vector3, float, ::System::Collections::Generic::List_1<::Fusion::BVHNode>*)>(&Fusion::BVHNode::FindOverlappingLeaves)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* origin = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* radius = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* overlapList = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "FindOverlappingLeaves", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, origin, radius, overlapList});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::BoundsIntersectsSphere
// Il2CppName: BoundsIntersectsSphere
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::BVHNode::*)(::UnityEngine::Bounds, ::UnityEngine::Vector3, float)>(&Fusion::BVHNode::BoundsIntersectsSphere)> {
  static const MethodInfo* get() {
    static auto* bounds = &::il2cpp_utils::GetClassFromName("UnityEngine", "Bounds")->byval_arg;
    static auto* origin = &::il2cpp_utils::GetClassFromName("UnityEngine", "Vector3")->byval_arg;
    static auto* radius = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "BoundsIntersectsSphere", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bounds, origin, radius});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::FindOverlappingLeaves
// Il2CppName: FindOverlappingLeaves
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, ::UnityEngine::Bounds, ::System::Collections::Generic::List_1<::Fusion::BVHNode>*)>(&Fusion::BVHNode::FindOverlappingLeaves)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* aabb = &::il2cpp_utils::GetClassFromName("UnityEngine", "Bounds")->byval_arg;
    static auto* overlapList = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "FindOverlappingLeaves", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, aabb, overlapList});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ToBounds
// Il2CppName: ToBounds
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Bounds (Fusion::BVHNode::*)()>(&Fusion::BVHNode::ToBounds)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ToBounds", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ChildExpanded
// Il2CppName: ChildExpanded
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, ByRef<::Fusion::BVHNode>)>(&Fusion::BVHNode::ChildExpanded)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* child = &::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ChildExpanded", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, child});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::UpdateBoundsCache
// Il2CppName: UpdateBoundsCache
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)()>(&Fusion::BVHNode::UpdateBoundsCache)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "UpdateBoundsCache", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ChildRefit
// Il2CppName: ChildRefit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::Fusion::BVH*, bool)>(&Fusion::BVHNode::ChildRefit)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* propagate = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ChildRefit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, propagate});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ChildRefit
// Il2CppName: ChildRefit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::Fusion::BVH*, int, bool)>(&Fusion::BVHNode::ChildRefit)> {
  static const MethodInfo* get() {
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* nodeIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* propagate = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ChildRefit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bvh, nodeIndex, propagate});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::InitNode
// Il2CppName: InitNode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(ByRef<::Fusion::BVHNode>, ::Fusion::BVH*, int, int, int, ::System::Collections::Generic::List_1<::Fusion::HitboxRoot*>*)>(&Fusion::BVHNode::InitNode)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("Fusion", "BVHNode")->this_arg;
    static auto* bvh = &::il2cpp_utils::GetClassFromName("Fusion", "BVH")->byval_arg;
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* parentIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* curDepth = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* entries = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "List`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("Fusion", "HitboxRoot")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "InitNode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node, bvh, index, parentIndex, curDepth, entries});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::BuildLog
// Il2CppName: BuildLog
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::BVHNode::*)(::System::Text::StringBuilder*)>(&Fusion::BVHNode::BuildLog)> {
  static const MethodInfo* get() {
    static auto* builder = &::il2cpp_utils::GetClassFromName("System.Text", "StringBuilder")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "BuildLog", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{builder});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Fusion::BVHNode::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::BVHNode::ToString
// Il2CppName: ToString
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::StringW (Fusion::BVHNode::*)()>(&Fusion::BVHNode::ToString)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::BVHNode), "ToString", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
