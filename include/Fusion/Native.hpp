// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
  // Forward declaring type: ValueType
  class ValueType;
}
// Completed forward declares
// Type namespace: Fusion
namespace Fusion {
  // Forward declaring type: Native
  class Native;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Fusion::Native);
DEFINE_IL2CPP_ARG_TYPE(::Fusion::Native*, "Fusion", "Native");
// Type namespace: Fusion
namespace Fusion {
  // Size: 0x10
  #pragma pack(push, 1)
  // Autogenerated type: Fusion.Native
  // [TokenAttribute] Offset: FFFFFFFF
  class Native : public ::Il2CppObject {
    public:
    // static public System.Void MemCpy(System.Void* destination, System.Void* source, System.Int32 size)
    // Offset: 0x2AD8800
    static void MemCpy(void* destination, void* source, int size);
    // static public System.Void MemClear(System.Void* ptr, System.Int32 size)
    // Offset: 0x2AD880C
    static void MemClear(void* ptr, int size);
    // static public System.Int32 MemCmp(System.Void* ptr1, System.Void* ptr2, System.Int32 size)
    // Offset: 0x2AD8818
    static int MemCmp(void* ptr1, void* ptr2, int size);
    // static public System.Void* Malloc(System.Int32 size)
    // Offset: 0x2AD8824
    static void* Malloc(int size);
    // static public System.Void Free(System.Void* memory)
    // Offset: 0x2AD3134
    static void Free(void* memory);
    // static public System.Int32 SizeOf(System.Type t)
    // Offset: 0x2AD88F8
    static int SizeOf(::System::Type* t);
    // static public System.Void* MallocAndClear(System.Int32 size)
    // Offset: 0x2AD30EC
    static void* MallocAndClear(int size);
    // static public T* MallocAndClear()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* MallocAndClear() {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::MallocAndClear");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "MallocAndClear", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method);
    }
    // static public T* Malloc()
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* Malloc() {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::Malloc");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "Malloc", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method);
    }
    // static public System.Void* MallocAndClearArray(System.Int32 stride, System.Int32 length)
    // Offset: 0x2AD8900
    static void* MallocAndClearArray(int stride, int length);
    // static public T* MallocAndClearArray(System.Int32 length)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* MallocAndClearArray(int length) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::MallocAndClearArray");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "MallocAndClearArray", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(length)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, length);
    }
    // static public T* MallocAndClearArrayMin1(System.Int32 length)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T* MallocAndClearArrayMin1(int length) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::MallocAndClearArrayMin1");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "MallocAndClearArrayMin1", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(length)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, length);
    }
    // static public T** MallocAndClearPtrArray(System.Int32 length)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T** MallocAndClearPtrArray(int length) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::MallocAndClearPtrArray");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "MallocAndClearPtrArray", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(length)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T**, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, length);
    }
    // static public T** MallocAndClearPtrArrayMin1(System.Int32 length)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T** MallocAndClearPtrArrayMin1(int length) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::MallocAndClearPtrArrayMin1");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "MallocAndClearPtrArrayMin1", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(length)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T**, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, length);
    }
    // static public System.Void ArrayClear(T* ptr, System.Int32 size)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static void ArrayClear(T* ptr, int size) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::ArrayClear");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "ArrayClear", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(ptr), ::il2cpp_utils::ExtractType(size)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, ptr, size);
    }
    // static public System.Int32 ArrayCompare(T* ptr1, T* ptr2, System.Int32 size)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static int ArrayCompare(T* ptr1, T* ptr2, int size) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::ArrayCompare");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "ArrayCompare", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(ptr1), ::il2cpp_utils::ExtractType(ptr2), ::il2cpp_utils::ExtractType(size)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<int, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, ptr1, ptr2, size);
    }
    // static public T** DoublePtrArray(T** array, System.Int32 currentLength)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T** DoublePtrArray(T** array, int currentLength) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::DoublePtrArray");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "DoublePtrArray", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(array), ::il2cpp_utils::ExtractType(currentLength)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T**, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, array, currentLength);
    }
    // static public T** ExpandPtrArray(T** array, System.Int32 currentLength, System.Int32 newLength)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static T** ExpandPtrArray(T** array, int currentLength, int newLength) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::ExpandPtrArray");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "ExpandPtrArray", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(array), ::il2cpp_utils::ExtractType(currentLength), ::il2cpp_utils::ExtractType(newLength)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<T**, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, array, currentLength, newLength);
    }
    // static public System.Int32 GetLengthPrefixedUTF8ByteCount(System.String str)
    // Offset: 0x2AD8934
    static int GetLengthPrefixedUTF8ByteCount(::StringW str);
    // static public System.Int32 WriteLengthPrefixedUTF8(System.Void* destination, System.String str)
    // Offset: 0x2AD8968
    static int WriteLengthPrefixedUTF8(void* destination, ::StringW str);
    // static public System.Int32 ReadLengthPrefixedUTF8(System.Void* source, out System.String result)
    // Offset: 0x2AD8A04
    static int ReadLengthPrefixedUTF8(void* source, ByRef<::StringW> result);
    // static public System.Void* AlignPointer(System.Void* pointer, System.Int32 alignment)
    // Offset: 0x2AD8A58
    static void* AlignPointer(void* pointer, int alignment);
    // static public System.Int32 RoundToMaxAlignment(System.Int32 stride)
    // Offset: 0x2AD8A78
    static int RoundToMaxAlignment(int stride);
    // static public System.Int32 RoundToAlignment(System.Int32 stride, System.Int32 alignment)
    // Offset: 0x2AD2FFC
    static int RoundToAlignment(int stride, int alignment);
    // static public System.Int32 RoundBitsUpTo32(System.Int32 bits)
    // Offset: 0x2AD8A84
    static int RoundBitsUpTo32(int bits);
    // static public System.Int32 GetAlignment(System.Int32 stride)
    // Offset: 0x2AD2FBC
    static int GetAlignment(int stride);
    // static public System.Byte* ReferenceToPointer(ref T obj)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    static uint8_t* ReferenceToPointer(ByRef<T> obj) {
      static_assert(std::is_convertible_v<T, ::System::ValueType*>);
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::Native::ReferenceToPointer");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod("Fusion", "Native", "ReferenceToPointer", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(obj)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<uint8_t*, false>(static_cast<Il2CppObject*>(nullptr), ___generic__method, byref(obj));
    }
    // static public System.Int32 MallocAndClearBlock(System.Int32 size0, System.Int32 size1, out System.Void* ptr0, out System.Void* ptr1, System.Int32 alignment)
    // Offset: 0x2AD8A90
    static int MallocAndClearBlock(int size0, int size1, ByRef<void*> ptr0, ByRef<void*> ptr1, int alignment);
    // static public System.Int32 MallocAndClearBlock(System.Int32 size0, System.Int32 size1, System.Int32 size2, System.Int32 size3, System.Int32 size4, System.Int32 size5, System.Int32 size6, System.Int32 size7, out System.Void* ptr0, out System.Void* ptr1, out System.Void* ptr2, out System.Void* ptr3, out System.Void* ptr4, out System.Void* ptr5, out System.Void* ptr6, out System.Void* ptr7, System.Int32 alignment)
    // Offset: 0x2AD8B00
    static int MallocAndClearBlock(int size0, int size1, int size2, int size3, int size4, int size5, int size6, int size7, ByRef<void*> ptr0, ByRef<void*> ptr1, ByRef<void*> ptr2, ByRef<void*> ptr3, ByRef<void*> ptr4, ByRef<void*> ptr5, ByRef<void*> ptr6, ByRef<void*> ptr7, int alignment);
  }; // Fusion.Native
  #pragma pack(pop)
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Fusion::Native::MemCpy
// Il2CppName: MemCpy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(void*, void*, int)>(&Fusion::Native::MemCpy)> {
  static const MethodInfo* get() {
    static auto* destination = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* source = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "MemCpy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{destination, source, size});
  }
};
// Writing MetadataGetter for method: Fusion::Native::MemClear
// Il2CppName: MemClear
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(void*, int)>(&Fusion::Native::MemClear)> {
  static const MethodInfo* get() {
    static auto* ptr = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "MemClear", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr, size});
  }
};
// Writing MetadataGetter for method: Fusion::Native::MemCmp
// Il2CppName: MemCmp
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(void*, void*, int)>(&Fusion::Native::MemCmp)> {
  static const MethodInfo* get() {
    static auto* ptr1 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* ptr2 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "MemCmp", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{ptr1, ptr2, size});
  }
};
// Writing MetadataGetter for method: Fusion::Native::Malloc
// Il2CppName: Malloc
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (*)(int)>(&Fusion::Native::Malloc)> {
  static const MethodInfo* get() {
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "Malloc", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{size});
  }
};
// Writing MetadataGetter for method: Fusion::Native::Free
// Il2CppName: Free
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(void*)>(&Fusion::Native::Free)> {
  static const MethodInfo* get() {
    static auto* memory = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "Free", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{memory});
  }
};
// Writing MetadataGetter for method: Fusion::Native::SizeOf
// Il2CppName: SizeOf
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(::System::Type*)>(&Fusion::Native::SizeOf)> {
  static const MethodInfo* get() {
    static auto* t = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "SizeOf", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{t});
  }
};
// Writing MetadataGetter for method: Fusion::Native::MallocAndClear
// Il2CppName: MallocAndClear
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (*)(int)>(&Fusion::Native::MallocAndClear)> {
  static const MethodInfo* get() {
    static auto* size = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "MallocAndClear", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{size});
  }
};
// Writing MetadataGetter for method: Fusion::Native::MallocAndClear
// Il2CppName: MallocAndClear
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::Malloc
// Il2CppName: Malloc
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::MallocAndClearArray
// Il2CppName: MallocAndClearArray
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (*)(int, int)>(&Fusion::Native::MallocAndClearArray)> {
  static const MethodInfo* get() {
    static auto* stride = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* length = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "MallocAndClearArray", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{stride, length});
  }
};
// Writing MetadataGetter for method: Fusion::Native::MallocAndClearArray
// Il2CppName: MallocAndClearArray
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::MallocAndClearArrayMin1
// Il2CppName: MallocAndClearArrayMin1
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::MallocAndClearPtrArray
// Il2CppName: MallocAndClearPtrArray
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::MallocAndClearPtrArrayMin1
// Il2CppName: MallocAndClearPtrArrayMin1
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::ArrayClear
// Il2CppName: ArrayClear
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::ArrayCompare
// Il2CppName: ArrayCompare
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::DoublePtrArray
// Il2CppName: DoublePtrArray
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::ExpandPtrArray
// Il2CppName: ExpandPtrArray
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::GetLengthPrefixedUTF8ByteCount
// Il2CppName: GetLengthPrefixedUTF8ByteCount
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(::StringW)>(&Fusion::Native::GetLengthPrefixedUTF8ByteCount)> {
  static const MethodInfo* get() {
    static auto* str = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "GetLengthPrefixedUTF8ByteCount", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{str});
  }
};
// Writing MetadataGetter for method: Fusion::Native::WriteLengthPrefixedUTF8
// Il2CppName: WriteLengthPrefixedUTF8
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(void*, ::StringW)>(&Fusion::Native::WriteLengthPrefixedUTF8)> {
  static const MethodInfo* get() {
    static auto* destination = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* str = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "WriteLengthPrefixedUTF8", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{destination, str});
  }
};
// Writing MetadataGetter for method: Fusion::Native::ReadLengthPrefixedUTF8
// Il2CppName: ReadLengthPrefixedUTF8
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(void*, ByRef<::StringW>)>(&Fusion::Native::ReadLengthPrefixedUTF8)> {
  static const MethodInfo* get() {
    static auto* source = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* result = &::il2cpp_utils::GetClassFromName("System", "String")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "ReadLengthPrefixedUTF8", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{source, result});
  }
};
// Writing MetadataGetter for method: Fusion::Native::AlignPointer
// Il2CppName: AlignPointer
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void* (*)(void*, int)>(&Fusion::Native::AlignPointer)> {
  static const MethodInfo* get() {
    static auto* pointer = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->byval_arg;
    static auto* alignment = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "AlignPointer", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{pointer, alignment});
  }
};
// Writing MetadataGetter for method: Fusion::Native::RoundToMaxAlignment
// Il2CppName: RoundToMaxAlignment
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(int)>(&Fusion::Native::RoundToMaxAlignment)> {
  static const MethodInfo* get() {
    static auto* stride = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "RoundToMaxAlignment", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{stride});
  }
};
// Writing MetadataGetter for method: Fusion::Native::RoundToAlignment
// Il2CppName: RoundToAlignment
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(int, int)>(&Fusion::Native::RoundToAlignment)> {
  static const MethodInfo* get() {
    static auto* stride = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* alignment = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "RoundToAlignment", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{stride, alignment});
  }
};
// Writing MetadataGetter for method: Fusion::Native::RoundBitsUpTo32
// Il2CppName: RoundBitsUpTo32
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(int)>(&Fusion::Native::RoundBitsUpTo32)> {
  static const MethodInfo* get() {
    static auto* bits = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "RoundBitsUpTo32", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bits});
  }
};
// Writing MetadataGetter for method: Fusion::Native::GetAlignment
// Il2CppName: GetAlignment
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(int)>(&Fusion::Native::GetAlignment)> {
  static const MethodInfo* get() {
    static auto* stride = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "GetAlignment", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{stride});
  }
};
// Writing MetadataGetter for method: Fusion::Native::ReferenceToPointer
// Il2CppName: ReferenceToPointer
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: Fusion::Native::MallocAndClearBlock
// Il2CppName: MallocAndClearBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(int, int, ByRef<void*>, ByRef<void*>, int)>(&Fusion::Native::MallocAndClearBlock)> {
  static const MethodInfo* get() {
    static auto* size0 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size1 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* ptr0 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr1 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* alignment = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "MallocAndClearBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{size0, size1, ptr0, ptr1, alignment});
  }
};
// Writing MetadataGetter for method: Fusion::Native::MallocAndClearBlock
// Il2CppName: MallocAndClearBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (*)(int, int, int, int, int, int, int, int, ByRef<void*>, ByRef<void*>, ByRef<void*>, ByRef<void*>, ByRef<void*>, ByRef<void*>, ByRef<void*>, ByRef<void*>, int)>(&Fusion::Native::MallocAndClearBlock)> {
  static const MethodInfo* get() {
    static auto* size0 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size1 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size2 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size3 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size4 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size5 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size6 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* size7 = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* ptr0 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr1 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr2 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr3 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr4 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr5 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr6 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* ptr7 = &il2cpp_functions::Class_GetPtrClass(::il2cpp_utils::GetClassFromName("System", "Void"))->this_arg;
    static auto* alignment = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Native*), "MallocAndClearBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{size0, size1, size2, size3, size4, size5, size6, size7, ptr0, ptr1, ptr2, ptr3, ptr4, ptr5, ptr6, ptr7, alignment});
  }
};
