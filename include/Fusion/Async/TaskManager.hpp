// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.Threading.CancellationToken
#include "System/Threading/CancellationToken.hpp"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: Fusion::Async
namespace Fusion::Async {
}
// Forward declaring namespace: System::Threading::Tasks
namespace System::Threading::Tasks {
  // Forward declaring type: TaskFactory
  class TaskFactory;
  // Forward declaring type: Task
  class Task;
  // Forward declaring type: Task`1<TResult>
  template<typename TResult>
  class Task_1;
  // Forward declaring type: TaskCreationOptions
  struct TaskCreationOptions;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Func`1<TResult>
  template<typename TResult>
  class Func_1;
  // Forward declaring type: Func`2<T, TResult>
  template<typename T, typename TResult>
  class Func_2;
}
// Completed forward declares
// Type namespace: Fusion.Async
namespace Fusion::Async {
  // Forward declaring type: TaskManager
  class TaskManager;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Fusion::Async::TaskManager);
DEFINE_IL2CPP_ARG_TYPE(::Fusion::Async::TaskManager*, "Fusion.Async", "TaskManager");
// Type namespace: Fusion.Async
namespace Fusion::Async {
  // Size: 0x10
  #pragma pack(push, 1)
  // Autogenerated type: Fusion.Async.TaskManager
  // [TokenAttribute] Offset: FFFFFFFF
  class TaskManager : public ::Il2CppObject {
    public:
    // Nested type: ::Fusion::Async::TaskManager::$$c__DisplayClass6_0
    class $$c__DisplayClass6_0;
    // Nested type: ::Fusion::Async::TaskManager::$$c__DisplayClass7_0
    class $$c__DisplayClass7_0;
    // Nested type: ::Fusion::Async::TaskManager::$$c__DisplayClass8_0
    class $$c__DisplayClass8_0;
    // Nested type: ::Fusion::Async::TaskManager::$$c__DisplayClass9_0
    class $$c__DisplayClass9_0;
    // Get static field: static private System.Threading.Tasks.TaskFactory <TaskFactory>k__BackingField
    static ::System::Threading::Tasks::TaskFactory* _get_$TaskFactory$k__BackingField();
    // Set static field: static private System.Threading.Tasks.TaskFactory <TaskFactory>k__BackingField
    static void _set_$TaskFactory$k__BackingField(::System::Threading::Tasks::TaskFactory* value);
    // static private System.Threading.Tasks.TaskFactory get_TaskFactory()
    // Offset: 0x2ADB080
    static ::System::Threading::Tasks::TaskFactory* get_TaskFactory();
    // static private System.Void set_TaskFactory(System.Threading.Tasks.TaskFactory value)
    // Offset: 0x2ADB0D8
    static void set_TaskFactory(::System::Threading::Tasks::TaskFactory* value);
    // static public System.Void Setup()
    // Offset: 0x2ADB140
    static void Setup();
    // static public System.Threading.Tasks.Task Service(System.Func`1<System.Threading.Tasks.Task`1<System.Boolean>> recurringAction, System.Threading.CancellationToken cancellationToken, System.Int32 interval, System.String serviceName)
    // Offset: 0x2ADB3A0
    static ::System::Threading::Tasks::Task* Service(::System::Func_1<::System::Threading::Tasks::Task_1<bool>*>* recurringAction, ::System::Threading::CancellationToken cancellationToken, int interval, ::StringW serviceName);
    // static public System.Threading.Tasks.Task Run(System.Func`2<System.Threading.CancellationToken,System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions options)
    // Offset: 0x2ADB590
    static ::System::Threading::Tasks::Task* Run(::System::Func_2<::System::Threading::CancellationToken, ::System::Threading::Tasks::Task*>* action, ::System::Threading::CancellationToken cancellationToken, ::System::Threading::Tasks::TaskCreationOptions options);
    // static public System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] precedingTasks, System.Func`2<System.Threading.CancellationToken,System.Threading.Tasks.Task> action, System.Threading.CancellationToken cancellationToken)
    // Offset: 0x2ADB77C
    static ::System::Threading::Tasks::Task* ContinueWhenAll(::ArrayW<::System::Threading::Tasks::Task*> precedingTasks, ::System::Func_2<::System::Threading::CancellationToken, ::System::Threading::Tasks::Task*>* action, ::System::Threading::CancellationToken cancellationToken);
    // static System.Threading.Tasks.Task Delay(System.Int32 delay, System.Threading.CancellationToken token)
    // Offset: 0x2ADB96C
    static ::System::Threading::Tasks::Task* Delay(int delay, ::System::Threading::CancellationToken token);
    // static private System.Void .cctor()
    // Offset: 0x2ADBAD0
    static void _cctor();
  }; // Fusion.Async.TaskManager
  #pragma pack(pop)
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Fusion::Async::TaskManager::get_TaskFactory
// Il2CppName: get_TaskFactory
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Threading::Tasks::TaskFactory* (*)()>(&Fusion::Async::TaskManager::get_TaskFactory)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), "get_TaskFactory", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Async::TaskManager::set_TaskFactory
// Il2CppName: set_TaskFactory
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)(::System::Threading::Tasks::TaskFactory*)>(&Fusion::Async::TaskManager::set_TaskFactory)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System.Threading.Tasks", "TaskFactory")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), "set_TaskFactory", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: Fusion::Async::TaskManager::Setup
// Il2CppName: Setup
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Fusion::Async::TaskManager::Setup)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), "Setup", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::Async::TaskManager::Service
// Il2CppName: Service
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Threading::Tasks::Task* (*)(::System::Func_1<::System::Threading::Tasks::Task_1<bool>*>*, ::System::Threading::CancellationToken, int, ::StringW)>(&Fusion::Async::TaskManager::Service)> {
  static const MethodInfo* get() {
    static auto* recurringAction = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Threading.Tasks", "Task`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Boolean")})})->byval_arg;
    static auto* cancellationToken = &::il2cpp_utils::GetClassFromName("System.Threading", "CancellationToken")->byval_arg;
    static auto* interval = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* serviceName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), "Service", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{recurringAction, cancellationToken, interval, serviceName});
  }
};
// Writing MetadataGetter for method: Fusion::Async::TaskManager::Run
// Il2CppName: Run
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Threading::Tasks::Task* (*)(::System::Func_2<::System::Threading::CancellationToken, ::System::Threading::Tasks::Task*>*, ::System::Threading::CancellationToken, ::System::Threading::Tasks::TaskCreationOptions)>(&Fusion::Async::TaskManager::Run)> {
  static const MethodInfo* get() {
    static auto* action = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`2"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System.Threading", "CancellationToken"), ::il2cpp_utils::GetClassFromName("System.Threading.Tasks", "Task")})->byval_arg;
    static auto* cancellationToken = &::il2cpp_utils::GetClassFromName("System.Threading", "CancellationToken")->byval_arg;
    static auto* options = &::il2cpp_utils::GetClassFromName("System.Threading.Tasks", "TaskCreationOptions")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), "Run", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{action, cancellationToken, options});
  }
};
// Writing MetadataGetter for method: Fusion::Async::TaskManager::ContinueWhenAll
// Il2CppName: ContinueWhenAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Threading::Tasks::Task* (*)(::ArrayW<::System::Threading::Tasks::Task*>, ::System::Func_2<::System::Threading::CancellationToken, ::System::Threading::Tasks::Task*>*, ::System::Threading::CancellationToken)>(&Fusion::Async::TaskManager::ContinueWhenAll)> {
  static const MethodInfo* get() {
    static auto* precedingTasks = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Threading.Tasks", "Task"), 1)->byval_arg;
    static auto* action = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`2"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System.Threading", "CancellationToken"), ::il2cpp_utils::GetClassFromName("System.Threading.Tasks", "Task")})->byval_arg;
    static auto* cancellationToken = &::il2cpp_utils::GetClassFromName("System.Threading", "CancellationToken")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), "ContinueWhenAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{precedingTasks, action, cancellationToken});
  }
};
// Writing MetadataGetter for method: Fusion::Async::TaskManager::Delay
// Il2CppName: Delay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Threading::Tasks::Task* (*)(int, ::System::Threading::CancellationToken)>(&Fusion::Async::TaskManager::Delay)> {
  static const MethodInfo* get() {
    static auto* delay = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* token = &::il2cpp_utils::GetClassFromName("System.Threading", "CancellationToken")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), "Delay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{delay, token});
  }
};
// Writing MetadataGetter for method: Fusion::Async::TaskManager::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&Fusion::Async::TaskManager::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::Async::TaskManager*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
