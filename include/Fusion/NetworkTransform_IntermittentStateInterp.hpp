// Autogenerated from CppHeaderCreator
// Custom Codegen for GORILLA TAG by chcoal
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: Fusion.NetworkTransform
#include "Fusion/NetworkTransform.hpp"
// Including type: Fusion.NetworkTransform/IInterpolationImplementation
#include "Fusion/NetworkTransform_IInterpolationImplementation.hpp"
// Including type: Fusion.NetworkTransform/PositionRotationValues
#include "Fusion/NetworkTransform_PositionRotationValues.hpp"
// Including type: Fusion.Tick
#include "Fusion/Tick.hpp"
// Including type: Fusion.PlayerRef
#include "Fusion/PlayerRef.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::Fusion::NetworkTransform::IntermittentStateInterp);
DEFINE_IL2CPP_ARG_TYPE(::Fusion::NetworkTransform::IntermittentStateInterp*, "Fusion", "NetworkTransform/IntermittentStateInterp");
// Type namespace: Fusion
namespace Fusion {
  // Size: 0xA0
  #pragma pack(push, 1)
  // Autogenerated type: Fusion.NetworkTransform/IntermittentStateInterp
  // [TokenAttribute] Offset: FFFFFFFF
  class NetworkTransform::IntermittentStateInterp : public ::Il2CppObject/*, public ::Fusion::NetworkTransform::IInterpolationImplementation*/ {
    public:
    // Nested type: ::Fusion::NetworkTransform::IntermittentStateInterp::PositionState
    struct PositionState;
    // Nested type: ::Fusion::NetworkTransform::IntermittentStateInterp::RotationState
    struct RotationState;
    // Size: 0x11
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: Fusion.NetworkTransform/IntermittentStateInterp/PositionState
    // [TokenAttribute] Offset: FFFFFFFF
    struct PositionState/*, public ::System::ValueType*/ {
      public:
      public:
      // public readonly UnityEngine.Vector3 Position
      // Size: 0xC
      // Offset: 0x0
      ::UnityEngine::Vector3 Position;
      // Field size check
      static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
      // public readonly Fusion.Tick Tick
      // Size: 0x4
      // Offset: 0xC
      ::Fusion::Tick Tick;
      // Field size check
      static_assert(sizeof(::Fusion::Tick) == 0x4);
      // public System.Boolean StoppedChanging
      // Size: 0x1
      // Offset: 0x10
      bool StoppedChanging;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: PositionState
      constexpr PositionState(::UnityEngine::Vector3 Position_ = {}, ::Fusion::Tick Tick_ = {}, bool StoppedChanging_ = {}) noexcept : Position{Position_}, Tick{Tick_}, StoppedChanging{StoppedChanging_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public readonly UnityEngine.Vector3 Position
      [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn_Position();
      // Get instance field reference: public readonly Fusion.Tick Tick
      [[deprecated("Use field access instead!")]] ::Fusion::Tick& dyn_Tick();
      // Get instance field reference: public System.Boolean StoppedChanging
      [[deprecated("Use field access instead!")]] bool& dyn_StoppedChanging();
      // public System.Void .ctor(UnityEngine.Vector3 pos, Fusion.Tick tick, System.Boolean stoppedChanging)
      // Offset: 0x2B24918
      // ABORTED: conflicts with another method.  PositionState(::UnityEngine::Vector3 pos, ::Fusion::Tick tick, bool stoppedChanging);
    }; // Fusion.NetworkTransform/IntermittentStateInterp/PositionState
    #pragma pack(pop)
    static check_size<sizeof(NetworkTransform::IntermittentStateInterp::PositionState), 16 + sizeof(bool)> __Fusion_NetworkTransform_IntermittentStateInterp_PositionStateSizeCheck;
    static_assert(sizeof(NetworkTransform::IntermittentStateInterp::PositionState) == 0x11);
    // Size: 0x15
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: Fusion.NetworkTransform/IntermittentStateInterp/RotationState
    // [TokenAttribute] Offset: FFFFFFFF
    struct RotationState/*, public ::System::ValueType*/ {
      public:
      public:
      // public readonly UnityEngine.Quaternion Rotation
      // Size: 0x10
      // Offset: 0x0
      ::UnityEngine::Quaternion Rotation;
      // Field size check
      static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
      // public readonly Fusion.Tick Tick
      // Size: 0x4
      // Offset: 0x10
      ::Fusion::Tick Tick;
      // Field size check
      static_assert(sizeof(::Fusion::Tick) == 0x4);
      // public System.Boolean StoppedChanging
      // Size: 0x1
      // Offset: 0x14
      bool StoppedChanging;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: RotationState
      constexpr RotationState(::UnityEngine::Quaternion Rotation_ = {}, ::Fusion::Tick Tick_ = {}, bool StoppedChanging_ = {}) noexcept : Rotation{Rotation_}, Tick{Tick_}, StoppedChanging{StoppedChanging_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public readonly UnityEngine.Quaternion Rotation
      [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn_Rotation();
      // Get instance field reference: public readonly Fusion.Tick Tick
      [[deprecated("Use field access instead!")]] ::Fusion::Tick& dyn_Tick();
      // Get instance field reference: public System.Boolean StoppedChanging
      [[deprecated("Use field access instead!")]] bool& dyn_StoppedChanging();
      // public System.Void .ctor(UnityEngine.Quaternion rot, Fusion.Tick tick, System.Boolean stoppedChanging)
      // Offset: 0x2B24930
      // ABORTED: conflicts with another method.  RotationState(::UnityEngine::Quaternion rot, ::Fusion::Tick tick, bool stoppedChanging);
    }; // Fusion.NetworkTransform/IntermittentStateInterp/RotationState
    #pragma pack(pop)
    static check_size<sizeof(NetworkTransform::IntermittentStateInterp::RotationState), 20 + sizeof(bool)> __Fusion_NetworkTransform_IntermittentStateInterp_RotationStateSizeCheck;
    static_assert(sizeof(NetworkTransform::IntermittentStateInterp::RotationState) == 0x15);
    public:
    // private Fusion.NetworkTransform _nt
    // Size: 0x8
    // Offset: 0x10
    ::Fusion::NetworkTransform* nt;
    // Field size check
    static_assert(sizeof(::Fusion::NetworkTransform*) == 0x8);
    // private Fusion.NetworkTransform/PositionRotationValues _accumulatedError
    // Size: 0x1C
    // Offset: 0x18
    ::Fusion::NetworkTransform::PositionRotationValues accumulatedError;
    // Field size check
    static_assert(sizeof(::Fusion::NetworkTransform::PositionRotationValues) == 0x1C);
    // private System.Single _lastUpdateSimTime
    // Size: 0x4
    // Offset: 0x34
    float lastUpdateSimTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private Fusion.Tick _latestTeleportPosTick
    // Size: 0x4
    // Offset: 0x38
    ::Fusion::Tick latestTeleportPosTick;
    // Field size check
    static_assert(sizeof(::Fusion::Tick) == 0x4);
    // private Fusion.Tick _latestTeleportRotTick
    // Size: 0x4
    // Offset: 0x3C
    ::Fusion::Tick latestTeleportRotTick;
    // Field size check
    static_assert(sizeof(::Fusion::Tick) == 0x4);
    // private Fusion.PlayerRef _latestStateAuth
    // Size: 0x4
    // Offset: 0x40
    ::Fusion::PlayerRef latestStateAuth;
    // Field size check
    static_assert(sizeof(::Fusion::PlayerRef) == 0x4);
    // private Fusion.Tick _latestSnapshotTick
    // Size: 0x4
    // Offset: 0x44
    ::Fusion::Tick latestSnapshotTick;
    // Field size check
    static_assert(sizeof(::Fusion::Tick) == 0x4);
    // private UnityEngine.Vector3 _currInterpPos
    // Size: 0xC
    // Offset: 0x48
    ::UnityEngine::Vector3 currInterpPos;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector3) == 0xC);
    // private UnityEngine.Quaternion _currInterpRot
    // Size: 0x10
    // Offset: 0x54
    ::UnityEngine::Quaternion currInterpRot;
    // Field size check
    static_assert(sizeof(::UnityEngine::Quaternion) == 0x10);
    // private System.Single _currInterpPosAccTime
    // Size: 0x4
    // Offset: 0x64
    float currInterpPosAccTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single _currInterpRotAccTime
    // Size: 0x4
    // Offset: 0x68
    float currInterpRotAccTime;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single _currPosStateDt
    // Size: 0x4
    // Offset: 0x6C
    float currPosStateDt;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single _currRotStateDt
    // Size: 0x4
    // Offset: 0x70
    float currRotStateDt;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Int32 _posStateHead
    // Size: 0x4
    // Offset: 0x74
    int posStateHead;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _posStateTail
    // Size: 0x4
    // Offset: 0x78
    int posStateTail;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: posStateTail and: posStateBuffer
    char __padding14[0x4] = {};
    // private Fusion.NetworkTransform/IntermittentStateInterp/PositionState[] _posStateBuffer
    // Size: 0x8
    // Offset: 0x80
    ::ArrayW<::Fusion::NetworkTransform::IntermittentStateInterp::PositionState> posStateBuffer;
    // Field size check
    static_assert(sizeof(::ArrayW<::Fusion::NetworkTransform::IntermittentStateInterp::PositionState>) == 0x8);
    // private System.Int32 _rotStateHead
    // Size: 0x4
    // Offset: 0x88
    int rotStateHead;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 _rotStateTail
    // Size: 0x4
    // Offset: 0x8C
    int rotStateTail;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private Fusion.NetworkTransform/IntermittentStateInterp/RotationState[] _rotStateBuffer
    // Size: 0x8
    // Offset: 0x90
    ::ArrayW<::Fusion::NetworkTransform::IntermittentStateInterp::RotationState> rotStateBuffer;
    // Field size check
    static_assert(sizeof(::ArrayW<::Fusion::NetworkTransform::IntermittentStateInterp::RotationState>) == 0x8);
    // private System.Boolean initializationFinished
    // Size: 0x1
    // Offset: 0x98
    bool initializationFinished;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: initializationFinished and: initializationStart
    char __padding19[0x3] = {};
    // private System.Single initializationStart
    // Size: 0x4
    // Offset: 0x9C
    float initializationStart;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    public:
    // Creating interface conversion operator: operator ::Fusion::NetworkTransform::IInterpolationImplementation
    operator ::Fusion::NetworkTransform::IInterpolationImplementation() noexcept {
      return *reinterpret_cast<::Fusion::NetworkTransform::IInterpolationImplementation*>(this);
    }
    // static field const value: static private System.Int32 _initBufferCapacity
    static constexpr const int _initBufferCapacity = 5;
    // Get static field: static private System.Int32 _initBufferCapacity
    static int _get__initBufferCapacity();
    // Set static field: static private System.Int32 _initBufferCapacity
    static void _set__initBufferCapacity(int value);
    // static field const value: static private System.Int32 _bufferIncreaseStep
    static constexpr const int _bufferIncreaseStep = 3;
    // Get static field: static private System.Int32 _bufferIncreaseStep
    static int _get__bufferIncreaseStep();
    // Set static field: static private System.Int32 _bufferIncreaseStep
    static void _set__bufferIncreaseStep(int value);
    // static field const value: static private System.Int32 _bufferMaxSize
    static constexpr const int _bufferMaxSize = 30;
    // Get static field: static private System.Int32 _bufferMaxSize
    static int _get__bufferMaxSize();
    // Set static field: static private System.Int32 _bufferMaxSize
    static void _set__bufferMaxSize(int value);
    // static field const value: static private System.Single _limitExtrapolationSeconds
    static constexpr const float _limitExtrapolationSeconds = 1;
    // Get static field: static private System.Single _limitExtrapolationSeconds
    static float _get__limitExtrapolationSeconds();
    // Set static field: static private System.Single _limitExtrapolationSeconds
    static void _set__limitExtrapolationSeconds(float value);
    // static field const value: static private System.Single initializationDuration
    static constexpr const float initializationDuration = 5;
    // Get static field: static private System.Single initializationDuration
    static float _get_initializationDuration();
    // Set static field: static private System.Single initializationDuration
    static void _set_initializationDuration(float value);
    // static field const value: static private System.Single initializationMaxDeltaTimeIncrease
    static constexpr const float initializationMaxDeltaTimeIncrease = 1.5;
    // Get static field: static private System.Single initializationMaxDeltaTimeIncrease
    static float _get_initializationMaxDeltaTimeIncrease();
    // Set static field: static private System.Single initializationMaxDeltaTimeIncrease
    static void _set_initializationMaxDeltaTimeIncrease(float value);
    // Get instance field reference: private Fusion.NetworkTransform _nt
    [[deprecated("Use field access instead!")]] ::Fusion::NetworkTransform*& dyn__nt();
    // Get instance field reference: private Fusion.NetworkTransform/PositionRotationValues _accumulatedError
    [[deprecated("Use field access instead!")]] ::Fusion::NetworkTransform::PositionRotationValues& dyn__accumulatedError();
    // Get instance field reference: private System.Single _lastUpdateSimTime
    [[deprecated("Use field access instead!")]] float& dyn__lastUpdateSimTime();
    // Get instance field reference: private Fusion.Tick _latestTeleportPosTick
    [[deprecated("Use field access instead!")]] ::Fusion::Tick& dyn__latestTeleportPosTick();
    // Get instance field reference: private Fusion.Tick _latestTeleportRotTick
    [[deprecated("Use field access instead!")]] ::Fusion::Tick& dyn__latestTeleportRotTick();
    // Get instance field reference: private Fusion.PlayerRef _latestStateAuth
    [[deprecated("Use field access instead!")]] ::Fusion::PlayerRef& dyn__latestStateAuth();
    // Get instance field reference: private Fusion.Tick _latestSnapshotTick
    [[deprecated("Use field access instead!")]] ::Fusion::Tick& dyn__latestSnapshotTick();
    // Get instance field reference: private UnityEngine.Vector3 _currInterpPos
    [[deprecated("Use field access instead!")]] ::UnityEngine::Vector3& dyn__currInterpPos();
    // Get instance field reference: private UnityEngine.Quaternion _currInterpRot
    [[deprecated("Use field access instead!")]] ::UnityEngine::Quaternion& dyn__currInterpRot();
    // Get instance field reference: private System.Single _currInterpPosAccTime
    [[deprecated("Use field access instead!")]] float& dyn__currInterpPosAccTime();
    // Get instance field reference: private System.Single _currInterpRotAccTime
    [[deprecated("Use field access instead!")]] float& dyn__currInterpRotAccTime();
    // Get instance field reference: private System.Single _currPosStateDt
    [[deprecated("Use field access instead!")]] float& dyn__currPosStateDt();
    // Get instance field reference: private System.Single _currRotStateDt
    [[deprecated("Use field access instead!")]] float& dyn__currRotStateDt();
    // Get instance field reference: private System.Int32 _posStateHead
    [[deprecated("Use field access instead!")]] int& dyn__posStateHead();
    // Get instance field reference: private System.Int32 _posStateTail
    [[deprecated("Use field access instead!")]] int& dyn__posStateTail();
    // Get instance field reference: private Fusion.NetworkTransform/IntermittentStateInterp/PositionState[] _posStateBuffer
    [[deprecated("Use field access instead!")]] ::ArrayW<::Fusion::NetworkTransform::IntermittentStateInterp::PositionState>& dyn__posStateBuffer();
    // Get instance field reference: private System.Int32 _rotStateHead
    [[deprecated("Use field access instead!")]] int& dyn__rotStateHead();
    // Get instance field reference: private System.Int32 _rotStateTail
    [[deprecated("Use field access instead!")]] int& dyn__rotStateTail();
    // Get instance field reference: private Fusion.NetworkTransform/IntermittentStateInterp/RotationState[] _rotStateBuffer
    [[deprecated("Use field access instead!")]] ::ArrayW<::Fusion::NetworkTransform::IntermittentStateInterp::RotationState>& dyn__rotStateBuffer();
    // Get instance field reference: private System.Boolean initializationFinished
    [[deprecated("Use field access instead!")]] bool& dyn_initializationFinished();
    // Get instance field reference: private System.Single initializationStart
    [[deprecated("Use field access instead!")]] float& dyn_initializationStart();
    // public System.Void Reset(Fusion.NetworkTransform nt)
    // Offset: 0x2B22DD4
    void Reset(::Fusion::NetworkTransform* nt);
    // public System.Boolean TryComputeInterpolatedTransform(out Fusion.NetworkTransform/InterpolatedTransformParameters param)
    // Offset: 0x2B22FC8
    bool TryComputeInterpolatedTransform(ByRef<::Fusion::NetworkTransform::InterpolatedTransformParameters> param);
    // public System.Void AfterApplyInterpolatedTransform()
    // Offset: 0x2B24948
    void AfterApplyInterpolatedTransform();
    // public System.Void .ctor()
    // Offset: 0x2B204F4
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static NetworkTransform::IntermittentStateInterp* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::Fusion::NetworkTransform::IntermittentStateInterp::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<NetworkTransform::IntermittentStateInterp*, creationType>()));
    }
  }; // Fusion.NetworkTransform/IntermittentStateInterp
  #pragma pack(pop)
  static check_size<sizeof(NetworkTransform::IntermittentStateInterp), 156 + sizeof(float)> __Fusion_NetworkTransform_IntermittentStateInterpSizeCheck;
  static_assert(sizeof(NetworkTransform::IntermittentStateInterp) == 0xA0);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Fusion::NetworkTransform::IntermittentStateInterp::RotationState, "Fusion", "NetworkTransform/IntermittentStateInterp/RotationState");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::Fusion::NetworkTransform::IntermittentStateInterp::PositionState, "Fusion", "NetworkTransform/IntermittentStateInterp/PositionState");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: Fusion::NetworkTransform::IntermittentStateInterp::Reset
// Il2CppName: Reset
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::NetworkTransform::IntermittentStateInterp::*)(::Fusion::NetworkTransform*)>(&Fusion::NetworkTransform::IntermittentStateInterp::Reset)> {
  static const MethodInfo* get() {
    static auto* nt = &::il2cpp_utils::GetClassFromName("Fusion", "NetworkTransform")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::NetworkTransform::IntermittentStateInterp*), "Reset", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{nt});
  }
};
// Writing MetadataGetter for method: Fusion::NetworkTransform::IntermittentStateInterp::TryComputeInterpolatedTransform
// Il2CppName: TryComputeInterpolatedTransform
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (Fusion::NetworkTransform::IntermittentStateInterp::*)(ByRef<::Fusion::NetworkTransform::InterpolatedTransformParameters>)>(&Fusion::NetworkTransform::IntermittentStateInterp::TryComputeInterpolatedTransform)> {
  static const MethodInfo* get() {
    static auto* param = &::il2cpp_utils::GetClassFromName("Fusion", "NetworkTransform/InterpolatedTransformParameters")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(Fusion::NetworkTransform::IntermittentStateInterp*), "TryComputeInterpolatedTransform", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{param});
  }
};
// Writing MetadataGetter for method: Fusion::NetworkTransform::IntermittentStateInterp::AfterApplyInterpolatedTransform
// Il2CppName: AfterApplyInterpolatedTransform
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (Fusion::NetworkTransform::IntermittentStateInterp::*)()>(&Fusion::NetworkTransform::IntermittentStateInterp::AfterApplyInterpolatedTransform)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(Fusion::NetworkTransform::IntermittentStateInterp*), "AfterApplyInterpolatedTransform", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: Fusion::NetworkTransform::IntermittentStateInterp::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
